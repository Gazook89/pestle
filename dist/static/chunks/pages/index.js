/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "./node_modules/@svgdotjs/svg.js/dist/svg.esm.js":
/*!*******************************************************!*\
  !*** ./node_modules/@svgdotjs/svg.js/dist/svg.esm.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: function() { return /* binding */ A; },\n/* harmony export */   Animator: function() { return /* binding */ Animator; },\n/* harmony export */   Array: function() { return /* binding */ SVGArray; },\n/* harmony export */   Box: function() { return /* binding */ Box; },\n/* harmony export */   Circle: function() { return /* binding */ Circle; },\n/* harmony export */   ClipPath: function() { return /* binding */ ClipPath; },\n/* harmony export */   Color: function() { return /* binding */ Color; },\n/* harmony export */   Container: function() { return /* binding */ Container; },\n/* harmony export */   Controller: function() { return /* binding */ Controller; },\n/* harmony export */   Defs: function() { return /* binding */ Defs; },\n/* harmony export */   Dom: function() { return /* binding */ Dom; },\n/* harmony export */   Ease: function() { return /* binding */ Ease; },\n/* harmony export */   Element: function() { return /* binding */ Element; },\n/* harmony export */   Ellipse: function() { return /* binding */ Ellipse; },\n/* harmony export */   EventTarget: function() { return /* binding */ EventTarget; },\n/* harmony export */   ForeignObject: function() { return /* binding */ ForeignObject; },\n/* harmony export */   Fragment: function() { return /* binding */ Fragment; },\n/* harmony export */   G: function() { return /* binding */ G; },\n/* harmony export */   Gradient: function() { return /* binding */ Gradient; },\n/* harmony export */   Image: function() { return /* binding */ Image; },\n/* harmony export */   Line: function() { return /* binding */ Line; },\n/* harmony export */   List: function() { return /* binding */ List; },\n/* harmony export */   Marker: function() { return /* binding */ Marker; },\n/* harmony export */   Mask: function() { return /* binding */ Mask; },\n/* harmony export */   Matrix: function() { return /* binding */ Matrix; },\n/* harmony export */   Morphable: function() { return /* binding */ Morphable; },\n/* harmony export */   NonMorphable: function() { return /* binding */ NonMorphable; },\n/* harmony export */   Number: function() { return /* binding */ SVGNumber; },\n/* harmony export */   ObjectBag: function() { return /* binding */ ObjectBag; },\n/* harmony export */   PID: function() { return /* binding */ PID; },\n/* harmony export */   Path: function() { return /* binding */ Path; },\n/* harmony export */   PathArray: function() { return /* binding */ PathArray; },\n/* harmony export */   Pattern: function() { return /* binding */ Pattern; },\n/* harmony export */   Point: function() { return /* binding */ Point; },\n/* harmony export */   PointArray: function() { return /* binding */ PointArray; },\n/* harmony export */   Polygon: function() { return /* binding */ Polygon; },\n/* harmony export */   Polyline: function() { return /* binding */ Polyline; },\n/* harmony export */   Queue: function() { return /* binding */ Queue; },\n/* harmony export */   Rect: function() { return /* binding */ Rect; },\n/* harmony export */   Runner: function() { return /* binding */ Runner; },\n/* harmony export */   SVG: function() { return /* binding */ SVG; },\n/* harmony export */   Shape: function() { return /* binding */ Shape; },\n/* harmony export */   Spring: function() { return /* binding */ Spring; },\n/* harmony export */   Stop: function() { return /* binding */ Stop; },\n/* harmony export */   Style: function() { return /* binding */ Style; },\n/* harmony export */   Svg: function() { return /* binding */ Svg; },\n/* harmony export */   Symbol: function() { return /* binding */ Symbol; },\n/* harmony export */   Text: function() { return /* binding */ Text; },\n/* harmony export */   TextPath: function() { return /* binding */ TextPath; },\n/* harmony export */   Timeline: function() { return /* binding */ Timeline; },\n/* harmony export */   TransformBag: function() { return /* binding */ TransformBag; },\n/* harmony export */   Tspan: function() { return /* binding */ Tspan; },\n/* harmony export */   Use: function() { return /* binding */ Use; },\n/* harmony export */   adopt: function() { return /* binding */ adopt; },\n/* harmony export */   assignNewId: function() { return /* binding */ assignNewId; },\n/* harmony export */   clearEvents: function() { return /* binding */ clearEvents; },\n/* harmony export */   create: function() { return /* binding */ create; },\n/* harmony export */   defaults: function() { return /* binding */ defaults; },\n/* harmony export */   dispatch: function() { return /* binding */ dispatch; },\n/* harmony export */   easing: function() { return /* binding */ easing; },\n/* harmony export */   eid: function() { return /* binding */ eid; },\n/* harmony export */   extend: function() { return /* binding */ extend; },\n/* harmony export */   find: function() { return /* binding */ baseFind; },\n/* harmony export */   getClass: function() { return /* binding */ getClass; },\n/* harmony export */   getEventTarget: function() { return /* binding */ getEventTarget; },\n/* harmony export */   getEvents: function() { return /* binding */ getEvents; },\n/* harmony export */   getWindow: function() { return /* binding */ getWindow; },\n/* harmony export */   makeInstance: function() { return /* binding */ makeInstance; },\n/* harmony export */   makeMorphable: function() { return /* binding */ makeMorphable; },\n/* harmony export */   mockAdopt: function() { return /* binding */ mockAdopt; },\n/* harmony export */   namespaces: function() { return /* binding */ namespaces; },\n/* harmony export */   nodeOrNew: function() { return /* binding */ nodeOrNew; },\n/* harmony export */   off: function() { return /* binding */ off; },\n/* harmony export */   on: function() { return /* binding */ on; },\n/* harmony export */   parser: function() { return /* binding */ parser; },\n/* harmony export */   regex: function() { return /* binding */ regex; },\n/* harmony export */   register: function() { return /* binding */ register; },\n/* harmony export */   registerMorphableType: function() { return /* binding */ registerMorphableType; },\n/* harmony export */   registerWindow: function() { return /* binding */ registerWindow; },\n/* harmony export */   restoreWindow: function() { return /* binding */ restoreWindow; },\n/* harmony export */   root: function() { return /* binding */ root; },\n/* harmony export */   saveWindow: function() { return /* binding */ saveWindow; },\n/* harmony export */   utils: function() { return /* binding */ utils; },\n/* harmony export */   windowEvents: function() { return /* binding */ windowEvents; },\n/* harmony export */   withWindow: function() { return /* binding */ withWindow; },\n/* harmony export */   wrapWithAttrCheck: function() { return /* binding */ wrapWithAttrCheck; }\n/* harmony export */ });\n/*!\n* @svgdotjs/svg.js - A lightweight library for manipulating and animating SVG.\n* @version 3.2.0\n* https://svgjs.dev/\n*\n* @copyright Wout Fierens <wout@mick-wout.com>\n* @license MIT\n*\n* BUILT: Mon Jun 12 2023 10:34:51 GMT+0200 (Central European Summer Time)\n*/;\nconst methods$1 = {};\nconst names = [];\nfunction registerMethods(name, m) {\n  if (Array.isArray(name)) {\n    for (const _name of name) {\n      registerMethods(_name, m);\n    }\n\n    return;\n  }\n\n  if (typeof name === 'object') {\n    for (const _name in name) {\n      registerMethods(_name, name[_name]);\n    }\n\n    return;\n  }\n\n  addMethodNames(Object.getOwnPropertyNames(m));\n  methods$1[name] = Object.assign(methods$1[name] || {}, m);\n}\nfunction getMethodsFor(name) {\n  return methods$1[name] || {};\n}\nfunction getMethodNames() {\n  return [...new Set(names)];\n}\nfunction addMethodNames(_names) {\n  names.push(..._names);\n}\n\n// Map function\nfunction map(array, block) {\n  let i;\n  const il = array.length;\n  const result = [];\n\n  for (i = 0; i < il; i++) {\n    result.push(block(array[i]));\n  }\n\n  return result;\n} // Filter function\n\nfunction filter(array, block) {\n  let i;\n  const il = array.length;\n  const result = [];\n\n  for (i = 0; i < il; i++) {\n    if (block(array[i])) {\n      result.push(array[i]);\n    }\n  }\n\n  return result;\n} // Degrees to radians\n\nfunction radians(d) {\n  return d % 360 * Math.PI / 180;\n} // Radians to degrees\n\nfunction degrees(r) {\n  return r * 180 / Math.PI % 360;\n} // Convert dash-separated-string to camelCase\n\nfunction camelCase(s) {\n  return s.toLowerCase().replace(/-(.)/g, function (m, g) {\n    return g.toUpperCase();\n  });\n} // Convert camel cased string to dash separated\n\nfunction unCamelCase(s) {\n  return s.replace(/([A-Z])/g, function (m, g) {\n    return '-' + g.toLowerCase();\n  });\n} // Capitalize first letter of a string\n\nfunction capitalize(s) {\n  return s.charAt(0).toUpperCase() + s.slice(1);\n} // Calculate proportional width and height values when necessary\n\nfunction proportionalSize(element, width, height, box) {\n  if (width == null || height == null) {\n    box = box || element.bbox();\n\n    if (width == null) {\n      width = box.width / box.height * height;\n    } else if (height == null) {\n      height = box.height / box.width * width;\n    }\n  }\n\n  return {\n    width: width,\n    height: height\n  };\n}\n/**\n * This function adds support for string origins.\n * It searches for an origin in o.origin o.ox and o.originX.\n * This way, origin: {x: 'center', y: 50} can be passed as well as ox: 'center', oy: 50\n**/\n\nfunction getOrigin(o, element) {\n  const origin = o.origin; // First check if origin is in ox or originX\n\n  let ox = o.ox != null ? o.ox : o.originX != null ? o.originX : 'center';\n  let oy = o.oy != null ? o.oy : o.originY != null ? o.originY : 'center'; // Then check if origin was used and overwrite in that case\n\n  if (origin != null) {\n    [ox, oy] = Array.isArray(origin) ? origin : typeof origin === 'object' ? [origin.x, origin.y] : [origin, origin];\n  } // Make sure to only call bbox when actually needed\n\n\n  const condX = typeof ox === 'string';\n  const condY = typeof oy === 'string';\n\n  if (condX || condY) {\n    const {\n      height,\n      width,\n      x,\n      y\n    } = element.bbox(); // And only overwrite if string was passed for this specific axis\n\n    if (condX) {\n      ox = ox.includes('left') ? x : ox.includes('right') ? x + width : x + width / 2;\n    }\n\n    if (condY) {\n      oy = oy.includes('top') ? y : oy.includes('bottom') ? y + height : y + height / 2;\n    }\n  } // Return the origin as it is if it wasn't a string\n\n\n  return [ox, oy];\n}\n\nvar utils = {\n  __proto__: null,\n  map: map,\n  filter: filter,\n  radians: radians,\n  degrees: degrees,\n  camelCase: camelCase,\n  unCamelCase: unCamelCase,\n  capitalize: capitalize,\n  proportionalSize: proportionalSize,\n  getOrigin: getOrigin\n};\n\n// Default namespaces\nconst svg = 'http://www.w3.org/2000/svg';\nconst html = 'http://www.w3.org/1999/xhtml';\nconst xmlns = 'http://www.w3.org/2000/xmlns/';\nconst xlink = 'http://www.w3.org/1999/xlink';\nconst svgjs = 'http://svgjs.dev/svgjs';\n\nvar namespaces = {\n  __proto__: null,\n  svg: svg,\n  html: html,\n  xmlns: xmlns,\n  xlink: xlink,\n  svgjs: svgjs\n};\n\nconst globals = {\n  window: typeof window === 'undefined' ? null : window,\n  document: typeof document === 'undefined' ? null : document\n};\nfunction registerWindow(win = null, doc = null) {\n  globals.window = win;\n  globals.document = doc;\n}\nconst save = {};\nfunction saveWindow() {\n  save.window = globals.window;\n  save.document = globals.document;\n}\nfunction restoreWindow() {\n  globals.window = save.window;\n  globals.document = save.document;\n}\nfunction withWindow(win, fn) {\n  saveWindow();\n  registerWindow(win, win.document);\n  fn(win, win.document);\n  restoreWindow();\n}\nfunction getWindow() {\n  return globals.window;\n}\n\nclass Base {// constructor (node/*, {extensions = []} */) {\n  //   // this.tags = []\n  //   //\n  //   // for (let extension of extensions) {\n  //   //   extension.setup.call(this, node)\n  //   //   this.tags.push(extension.name)\n  //   // }\n  // }\n}\n\nconst elements = {};\nconst root = '___SYMBOL___ROOT___'; // Method for element creation\n\nfunction create(name, ns = svg) {\n  // create element\n  return globals.document.createElementNS(ns, name);\n}\nfunction makeInstance(element, isHTML = false) {\n  if (element instanceof Base) return element;\n\n  if (typeof element === 'object') {\n    return adopter(element);\n  }\n\n  if (element == null) {\n    return new elements[root]();\n  }\n\n  if (typeof element === 'string' && element.charAt(0) !== '<') {\n    return adopter(globals.document.querySelector(element));\n  } // Make sure, that HTML elements are created with the correct namespace\n\n\n  const wrapper = isHTML ? globals.document.createElement('div') : create('svg');\n  wrapper.innerHTML = element; // We can use firstChild here because we know,\n  // that the first char is < and thus an element\n\n  element = adopter(wrapper.firstChild); // make sure, that element doesn't have its wrapper attached\n\n  wrapper.removeChild(wrapper.firstChild);\n  return element;\n}\nfunction nodeOrNew(name, node) {\n  return node && node.ownerDocument && node instanceof node.ownerDocument.defaultView.Node ? node : create(name);\n} // Adopt existing svg elements\n\nfunction adopt(node) {\n  // check for presence of node\n  if (!node) return null; // make sure a node isn't already adopted\n\n  if (node.instance instanceof Base) return node.instance;\n\n  if (node.nodeName === '#document-fragment') {\n    return new elements.Fragment(node);\n  } // initialize variables\n\n\n  let className = capitalize(node.nodeName || 'Dom'); // Make sure that gradients are adopted correctly\n\n  if (className === 'LinearGradient' || className === 'RadialGradient') {\n    className = 'Gradient'; // Fallback to Dom if element is not known\n  } else if (!elements[className]) {\n    className = 'Dom';\n  }\n\n  return new elements[className](node);\n}\nlet adopter = adopt;\nfunction mockAdopt(mock = adopt) {\n  adopter = mock;\n}\nfunction register(element, name = element.name, asRoot = false) {\n  elements[name] = element;\n  if (asRoot) elements[root] = element;\n  addMethodNames(Object.getOwnPropertyNames(element.prototype));\n  return element;\n}\nfunction getClass(name) {\n  return elements[name];\n} // Element id sequence\n\nlet did = 1000; // Get next named element id\n\nfunction eid(name) {\n  return 'Svgjs' + capitalize(name) + did++;\n} // Deep new id assignment\n\nfunction assignNewId(node) {\n  // do the same for SVG child nodes as well\n  for (let i = node.children.length - 1; i >= 0; i--) {\n    assignNewId(node.children[i]);\n  }\n\n  if (node.id) {\n    node.id = eid(node.nodeName);\n    return node;\n  }\n\n  return node;\n} // Method for extending objects\n\nfunction extend(modules, methods) {\n  let key, i;\n  modules = Array.isArray(modules) ? modules : [modules];\n\n  for (i = modules.length - 1; i >= 0; i--) {\n    for (key in methods) {\n      modules[i].prototype[key] = methods[key];\n    }\n  }\n}\nfunction wrapWithAttrCheck(fn) {\n  return function (...args) {\n    const o = args[args.length - 1];\n\n    if (o && o.constructor === Object && !(o instanceof Array)) {\n      return fn.apply(this, args.slice(0, -1)).attr(o);\n    } else {\n      return fn.apply(this, args);\n    }\n  };\n}\n\nfunction siblings() {\n  return this.parent().children();\n} // Get the current position siblings\n\nfunction position() {\n  return this.parent().index(this);\n} // Get the next element (will return null if there is none)\n\nfunction next() {\n  return this.siblings()[this.position() + 1];\n} // Get the next element (will return null if there is none)\n\nfunction prev() {\n  return this.siblings()[this.position() - 1];\n} // Send given element one step forward\n\nfunction forward() {\n  const i = this.position();\n  const p = this.parent(); // move node one step forward\n\n  p.add(this.remove(), i + 1);\n  return this;\n} // Send given element one step backward\n\nfunction backward() {\n  const i = this.position();\n  const p = this.parent();\n  p.add(this.remove(), i ? i - 1 : 0);\n  return this;\n} // Send given element all the way to the front\n\nfunction front() {\n  const p = this.parent(); // Move node forward\n\n  p.add(this.remove());\n  return this;\n} // Send given element all the way to the back\n\nfunction back() {\n  const p = this.parent(); // Move node back\n\n  p.add(this.remove(), 0);\n  return this;\n} // Inserts a given element before the targeted element\n\nfunction before(element) {\n  element = makeInstance(element);\n  element.remove();\n  const i = this.position();\n  this.parent().add(element, i);\n  return this;\n} // Inserts a given element after the targeted element\n\nfunction after(element) {\n  element = makeInstance(element);\n  element.remove();\n  const i = this.position();\n  this.parent().add(element, i + 1);\n  return this;\n}\nfunction insertBefore(element) {\n  element = makeInstance(element);\n  element.before(this);\n  return this;\n}\nfunction insertAfter(element) {\n  element = makeInstance(element);\n  element.after(this);\n  return this;\n}\nregisterMethods('Dom', {\n  siblings,\n  position,\n  next,\n  prev,\n  forward,\n  backward,\n  front,\n  back,\n  before,\n  after,\n  insertBefore,\n  insertAfter\n});\n\n// Parse unit value\nconst numberAndUnit = /^([+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?)([a-z%]*)$/i; // Parse hex value\n\nconst hex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i; // Parse rgb value\n\nconst rgb = /rgb\\((\\d+),(\\d+),(\\d+)\\)/; // Parse reference id\n\nconst reference = /(#[a-z_][a-z0-9\\-_]*)/i; // splits a transformation chain\n\nconst transforms = /\\)\\s*,?\\s*/; // Whitespace\n\nconst whitespace = /\\s/g; // Test hex value\n\nconst isHex = /^#[a-f0-9]{3}$|^#[a-f0-9]{6}$/i; // Test rgb value\n\nconst isRgb = /^rgb\\(/; // Test for blank string\n\nconst isBlank = /^(\\s+)?$/; // Test for numeric string\n\nconst isNumber = /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i; // Test for image url\n\nconst isImage = /\\.(jpg|jpeg|png|gif|svg)(\\?[^=]+.*)?/i; // split at whitespace and comma\n\nconst delimiter = /[\\s,]+/; // Test for path letter\n\nconst isPathLetter = /[MLHVCSQTAZ]/i;\n\nvar regex = {\n  __proto__: null,\n  numberAndUnit: numberAndUnit,\n  hex: hex,\n  rgb: rgb,\n  reference: reference,\n  transforms: transforms,\n  whitespace: whitespace,\n  isHex: isHex,\n  isRgb: isRgb,\n  isBlank: isBlank,\n  isNumber: isNumber,\n  isImage: isImage,\n  delimiter: delimiter,\n  isPathLetter: isPathLetter\n};\n\nfunction classes() {\n  const attr = this.attr('class');\n  return attr == null ? [] : attr.trim().split(delimiter);\n} // Return true if class exists on the node, false otherwise\n\nfunction hasClass(name) {\n  return this.classes().indexOf(name) !== -1;\n} // Add class to the node\n\nfunction addClass(name) {\n  if (!this.hasClass(name)) {\n    const array = this.classes();\n    array.push(name);\n    this.attr('class', array.join(' '));\n  }\n\n  return this;\n} // Remove class from the node\n\nfunction removeClass(name) {\n  if (this.hasClass(name)) {\n    this.attr('class', this.classes().filter(function (c) {\n      return c !== name;\n    }).join(' '));\n  }\n\n  return this;\n} // Toggle the presence of a class on the node\n\nfunction toggleClass(name) {\n  return this.hasClass(name) ? this.removeClass(name) : this.addClass(name);\n}\nregisterMethods('Dom', {\n  classes,\n  hasClass,\n  addClass,\n  removeClass,\n  toggleClass\n});\n\nfunction css(style, val) {\n  const ret = {};\n\n  if (arguments.length === 0) {\n    // get full style as object\n    this.node.style.cssText.split(/\\s*;\\s*/).filter(function (el) {\n      return !!el.length;\n    }).forEach(function (el) {\n      const t = el.split(/\\s*:\\s*/);\n      ret[t[0]] = t[1];\n    });\n    return ret;\n  }\n\n  if (arguments.length < 2) {\n    // get style properties as array\n    if (Array.isArray(style)) {\n      for (const name of style) {\n        const cased = camelCase(name);\n        ret[name] = this.node.style[cased];\n      }\n\n      return ret;\n    } // get style for property\n\n\n    if (typeof style === 'string') {\n      return this.node.style[camelCase(style)];\n    } // set styles in object\n\n\n    if (typeof style === 'object') {\n      for (const name in style) {\n        // set empty string if null/undefined/'' was given\n        this.node.style[camelCase(name)] = style[name] == null || isBlank.test(style[name]) ? '' : style[name];\n      }\n    }\n  } // set style for property\n\n\n  if (arguments.length === 2) {\n    this.node.style[camelCase(style)] = val == null || isBlank.test(val) ? '' : val;\n  }\n\n  return this;\n} // Show element\n\nfunction show() {\n  return this.css('display', '');\n} // Hide element\n\nfunction hide() {\n  return this.css('display', 'none');\n} // Is element visible?\n\nfunction visible() {\n  return this.css('display') !== 'none';\n}\nregisterMethods('Dom', {\n  css,\n  show,\n  hide,\n  visible\n});\n\nfunction data(a, v, r) {\n  if (a == null) {\n    // get an object of attributes\n    return this.data(map(filter(this.node.attributes, el => el.nodeName.indexOf('data-') === 0), el => el.nodeName.slice(5)));\n  } else if (a instanceof Array) {\n    const data = {};\n\n    for (const key of a) {\n      data[key] = this.data(key);\n    }\n\n    return data;\n  } else if (typeof a === 'object') {\n    for (v in a) {\n      this.data(v, a[v]);\n    }\n  } else if (arguments.length < 2) {\n    try {\n      return JSON.parse(this.attr('data-' + a));\n    } catch (e) {\n      return this.attr('data-' + a);\n    }\n  } else {\n    this.attr('data-' + a, v === null ? null : r === true || typeof v === 'string' || typeof v === 'number' ? v : JSON.stringify(v));\n  }\n\n  return this;\n}\nregisterMethods('Dom', {\n  data\n});\n\nfunction remember(k, v) {\n  // remember every item in an object individually\n  if (typeof arguments[0] === 'object') {\n    for (const key in k) {\n      this.remember(key, k[key]);\n    }\n  } else if (arguments.length === 1) {\n    // retrieve memory\n    return this.memory()[k];\n  } else {\n    // store memory\n    this.memory()[k] = v;\n  }\n\n  return this;\n} // Erase a given memory\n\nfunction forget() {\n  if (arguments.length === 0) {\n    this._memory = {};\n  } else {\n    for (let i = arguments.length - 1; i >= 0; i--) {\n      delete this.memory()[arguments[i]];\n    }\n  }\n\n  return this;\n} // This triggers creation of a new hidden class which is not performant\n// However, this function is not rarely used so it will not happen frequently\n// Return local memory object\n\nfunction memory() {\n  return this._memory = this._memory || {};\n}\nregisterMethods('Dom', {\n  remember,\n  forget,\n  memory\n});\n\nfunction sixDigitHex(hex) {\n  return hex.length === 4 ? ['#', hex.substring(1, 2), hex.substring(1, 2), hex.substring(2, 3), hex.substring(2, 3), hex.substring(3, 4), hex.substring(3, 4)].join('') : hex;\n}\n\nfunction componentHex(component) {\n  const integer = Math.round(component);\n  const bounded = Math.max(0, Math.min(255, integer));\n  const hex = bounded.toString(16);\n  return hex.length === 1 ? '0' + hex : hex;\n}\n\nfunction is(object, space) {\n  for (let i = space.length; i--;) {\n    if (object[space[i]] == null) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction getParameters(a, b) {\n  const params = is(a, 'rgb') ? {\n    _a: a.r,\n    _b: a.g,\n    _c: a.b,\n    _d: 0,\n    space: 'rgb'\n  } : is(a, 'xyz') ? {\n    _a: a.x,\n    _b: a.y,\n    _c: a.z,\n    _d: 0,\n    space: 'xyz'\n  } : is(a, 'hsl') ? {\n    _a: a.h,\n    _b: a.s,\n    _c: a.l,\n    _d: 0,\n    space: 'hsl'\n  } : is(a, 'lab') ? {\n    _a: a.l,\n    _b: a.a,\n    _c: a.b,\n    _d: 0,\n    space: 'lab'\n  } : is(a, 'lch') ? {\n    _a: a.l,\n    _b: a.c,\n    _c: a.h,\n    _d: 0,\n    space: 'lch'\n  } : is(a, 'cmyk') ? {\n    _a: a.c,\n    _b: a.m,\n    _c: a.y,\n    _d: a.k,\n    space: 'cmyk'\n  } : {\n    _a: 0,\n    _b: 0,\n    _c: 0,\n    space: 'rgb'\n  };\n  params.space = b || params.space;\n  return params;\n}\n\nfunction cieSpace(space) {\n  if (space === 'lab' || space === 'xyz' || space === 'lch') {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction hueToRgb(p, q, t) {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  if (t < 1 / 6) return p + (q - p) * 6 * t;\n  if (t < 1 / 2) return q;\n  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n  return p;\n}\n\nclass Color {\n  constructor(...inputs) {\n    this.init(...inputs);\n  } // Test if given value is a color\n\n\n  static isColor(color) {\n    return color && (color instanceof Color || this.isRgb(color) || this.test(color));\n  } // Test if given value is an rgb object\n\n\n  static isRgb(color) {\n    return color && typeof color.r === 'number' && typeof color.g === 'number' && typeof color.b === 'number';\n  }\n  /*\n  Generating random colors\n  */\n\n\n  static random(mode = 'vibrant', t, u) {\n    // Get the math modules\n    const {\n      random,\n      round,\n      sin,\n      PI: pi\n    } = Math; // Run the correct generator\n\n    if (mode === 'vibrant') {\n      const l = (81 - 57) * random() + 57;\n      const c = (83 - 45) * random() + 45;\n      const h = 360 * random();\n      const color = new Color(l, c, h, 'lch');\n      return color;\n    } else if (mode === 'sine') {\n      t = t == null ? random() : t;\n      const r = round(80 * sin(2 * pi * t / 0.5 + 0.01) + 150);\n      const g = round(50 * sin(2 * pi * t / 0.5 + 4.6) + 200);\n      const b = round(100 * sin(2 * pi * t / 0.5 + 2.3) + 150);\n      const color = new Color(r, g, b);\n      return color;\n    } else if (mode === 'pastel') {\n      const l = (94 - 86) * random() + 86;\n      const c = (26 - 9) * random() + 9;\n      const h = 360 * random();\n      const color = new Color(l, c, h, 'lch');\n      return color;\n    } else if (mode === 'dark') {\n      const l = 10 + 10 * random();\n      const c = (125 - 75) * random() + 86;\n      const h = 360 * random();\n      const color = new Color(l, c, h, 'lch');\n      return color;\n    } else if (mode === 'rgb') {\n      const r = 255 * random();\n      const g = 255 * random();\n      const b = 255 * random();\n      const color = new Color(r, g, b);\n      return color;\n    } else if (mode === 'lab') {\n      const l = 100 * random();\n      const a = 256 * random() - 128;\n      const b = 256 * random() - 128;\n      const color = new Color(l, a, b, 'lab');\n      return color;\n    } else if (mode === 'grey') {\n      const grey = 255 * random();\n      const color = new Color(grey, grey, grey);\n      return color;\n    } else {\n      throw new Error('Unsupported random color mode');\n    }\n  } // Test if given value is a color string\n\n\n  static test(color) {\n    return typeof color === 'string' && (isHex.test(color) || isRgb.test(color));\n  }\n\n  cmyk() {\n    // Get the rgb values for the current color\n    const {\n      _a,\n      _b,\n      _c\n    } = this.rgb();\n    const [r, g, b] = [_a, _b, _c].map(v => v / 255); // Get the cmyk values in an unbounded format\n\n    const k = Math.min(1 - r, 1 - g, 1 - b);\n\n    if (k === 1) {\n      // Catch the black case\n      return new Color(0, 0, 0, 1, 'cmyk');\n    }\n\n    const c = (1 - r - k) / (1 - k);\n    const m = (1 - g - k) / (1 - k);\n    const y = (1 - b - k) / (1 - k); // Construct the new color\n\n    const color = new Color(c, m, y, k, 'cmyk');\n    return color;\n  }\n\n  hsl() {\n    // Get the rgb values\n    const {\n      _a,\n      _b,\n      _c\n    } = this.rgb();\n    const [r, g, b] = [_a, _b, _c].map(v => v / 255); // Find the maximum and minimum values to get the lightness\n\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const l = (max + min) / 2; // If the r, g, v values are identical then we are grey\n\n    const isGrey = max === min; // Calculate the hue and saturation\n\n    const delta = max - min;\n    const s = isGrey ? 0 : l > 0.5 ? delta / (2 - max - min) : delta / (max + min);\n    const h = isGrey ? 0 : max === r ? ((g - b) / delta + (g < b ? 6 : 0)) / 6 : max === g ? ((b - r) / delta + 2) / 6 : max === b ? ((r - g) / delta + 4) / 6 : 0; // Construct and return the new color\n\n    const color = new Color(360 * h, 100 * s, 100 * l, 'hsl');\n    return color;\n  }\n\n  init(a = 0, b = 0, c = 0, d = 0, space = 'rgb') {\n    // This catches the case when a falsy value is passed like ''\n    a = !a ? 0 : a; // Reset all values in case the init function is rerun with new color space\n\n    if (this.space) {\n      for (const component in this.space) {\n        delete this[this.space[component]];\n      }\n    }\n\n    if (typeof a === 'number') {\n      // Allow for the case that we don't need d...\n      space = typeof d === 'string' ? d : space;\n      d = typeof d === 'string' ? 0 : d; // Assign the values straight to the color\n\n      Object.assign(this, {\n        _a: a,\n        _b: b,\n        _c: c,\n        _d: d,\n        space\n      }); // If the user gave us an array, make the color from it\n    } else if (a instanceof Array) {\n      this.space = b || (typeof a[3] === 'string' ? a[3] : a[4]) || 'rgb';\n      Object.assign(this, {\n        _a: a[0],\n        _b: a[1],\n        _c: a[2],\n        _d: a[3] || 0\n      });\n    } else if (a instanceof Object) {\n      // Set the object up and assign its values directly\n      const values = getParameters(a, b);\n      Object.assign(this, values);\n    } else if (typeof a === 'string') {\n      if (isRgb.test(a)) {\n        const noWhitespace = a.replace(whitespace, '');\n        const [_a, _b, _c] = rgb.exec(noWhitespace).slice(1, 4).map(v => parseInt(v));\n        Object.assign(this, {\n          _a,\n          _b,\n          _c,\n          _d: 0,\n          space: 'rgb'\n        });\n      } else if (isHex.test(a)) {\n        const hexParse = v => parseInt(v, 16);\n\n        const [, _a, _b, _c] = hex.exec(sixDigitHex(a)).map(hexParse);\n        Object.assign(this, {\n          _a,\n          _b,\n          _c,\n          _d: 0,\n          space: 'rgb'\n        });\n      } else throw Error('Unsupported string format, can\\'t construct Color');\n    } // Now add the components as a convenience\n\n\n    const {\n      _a,\n      _b,\n      _c,\n      _d\n    } = this;\n    const components = this.space === 'rgb' ? {\n      r: _a,\n      g: _b,\n      b: _c\n    } : this.space === 'xyz' ? {\n      x: _a,\n      y: _b,\n      z: _c\n    } : this.space === 'hsl' ? {\n      h: _a,\n      s: _b,\n      l: _c\n    } : this.space === 'lab' ? {\n      l: _a,\n      a: _b,\n      b: _c\n    } : this.space === 'lch' ? {\n      l: _a,\n      c: _b,\n      h: _c\n    } : this.space === 'cmyk' ? {\n      c: _a,\n      m: _b,\n      y: _c,\n      k: _d\n    } : {};\n    Object.assign(this, components);\n  }\n\n  lab() {\n    // Get the xyz color\n    const {\n      x,\n      y,\n      z\n    } = this.xyz(); // Get the lab components\n\n    const l = 116 * y - 16;\n    const a = 500 * (x - y);\n    const b = 200 * (y - z); // Construct and return a new color\n\n    const color = new Color(l, a, b, 'lab');\n    return color;\n  }\n\n  lch() {\n    // Get the lab color directly\n    const {\n      l,\n      a,\n      b\n    } = this.lab(); // Get the chromaticity and the hue using polar coordinates\n\n    const c = Math.sqrt(a ** 2 + b ** 2);\n    let h = 180 * Math.atan2(b, a) / Math.PI;\n\n    if (h < 0) {\n      h *= -1;\n      h = 360 - h;\n    } // Make a new color and return it\n\n\n    const color = new Color(l, c, h, 'lch');\n    return color;\n  }\n  /*\n  Conversion Methods\n  */\n\n\n  rgb() {\n    if (this.space === 'rgb') {\n      return this;\n    } else if (cieSpace(this.space)) {\n      // Convert to the xyz color space\n      let {\n        x,\n        y,\n        z\n      } = this;\n\n      if (this.space === 'lab' || this.space === 'lch') {\n        // Get the values in the lab space\n        let {\n          l,\n          a,\n          b\n        } = this;\n\n        if (this.space === 'lch') {\n          const {\n            c,\n            h\n          } = this;\n          const dToR = Math.PI / 180;\n          a = c * Math.cos(dToR * h);\n          b = c * Math.sin(dToR * h);\n        } // Undo the nonlinear function\n\n\n        const yL = (l + 16) / 116;\n        const xL = a / 500 + yL;\n        const zL = yL - b / 200; // Get the xyz values\n\n        const ct = 16 / 116;\n        const mx = 0.008856;\n        const nm = 7.787;\n        x = 0.95047 * (xL ** 3 > mx ? xL ** 3 : (xL - ct) / nm);\n        y = 1.00000 * (yL ** 3 > mx ? yL ** 3 : (yL - ct) / nm);\n        z = 1.08883 * (zL ** 3 > mx ? zL ** 3 : (zL - ct) / nm);\n      } // Convert xyz to unbounded rgb values\n\n\n      const rU = x * 3.2406 + y * -1.5372 + z * -0.4986;\n      const gU = x * -0.9689 + y * 1.8758 + z * 0.0415;\n      const bU = x * 0.0557 + y * -0.2040 + z * 1.0570; // Convert the values to true rgb values\n\n      const pow = Math.pow;\n      const bd = 0.0031308;\n      const r = rU > bd ? 1.055 * pow(rU, 1 / 2.4) - 0.055 : 12.92 * rU;\n      const g = gU > bd ? 1.055 * pow(gU, 1 / 2.4) - 0.055 : 12.92 * gU;\n      const b = bU > bd ? 1.055 * pow(bU, 1 / 2.4) - 0.055 : 12.92 * bU; // Make and return the color\n\n      const color = new Color(255 * r, 255 * g, 255 * b);\n      return color;\n    } else if (this.space === 'hsl') {\n      // https://bgrins.github.io/TinyColor/docs/tinycolor.html\n      // Get the current hsl values\n      let {\n        h,\n        s,\n        l\n      } = this;\n      h /= 360;\n      s /= 100;\n      l /= 100; // If we are grey, then just make the color directly\n\n      if (s === 0) {\n        l *= 255;\n        const color = new Color(l, l, l);\n        return color;\n      } // TODO I have no idea what this does :D If you figure it out, tell me!\n\n\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q; // Get the rgb values\n\n      const r = 255 * hueToRgb(p, q, h + 1 / 3);\n      const g = 255 * hueToRgb(p, q, h);\n      const b = 255 * hueToRgb(p, q, h - 1 / 3); // Make a new color\n\n      const color = new Color(r, g, b);\n      return color;\n    } else if (this.space === 'cmyk') {\n      // https://gist.github.com/felipesabino/5066336\n      // Get the normalised cmyk values\n      const {\n        c,\n        m,\n        y,\n        k\n      } = this; // Get the rgb values\n\n      const r = 255 * (1 - Math.min(1, c * (1 - k) + k));\n      const g = 255 * (1 - Math.min(1, m * (1 - k) + k));\n      const b = 255 * (1 - Math.min(1, y * (1 - k) + k)); // Form the color and return it\n\n      const color = new Color(r, g, b);\n      return color;\n    } else {\n      return this;\n    }\n  }\n\n  toArray() {\n    const {\n      _a,\n      _b,\n      _c,\n      _d,\n      space\n    } = this;\n    return [_a, _b, _c, _d, space];\n  }\n\n  toHex() {\n    const [r, g, b] = this._clamped().map(componentHex);\n\n    return `#${r}${g}${b}`;\n  }\n\n  toRgb() {\n    const [rV, gV, bV] = this._clamped();\n\n    const string = `rgb(${rV},${gV},${bV})`;\n    return string;\n  }\n\n  toString() {\n    return this.toHex();\n  }\n\n  xyz() {\n    // Normalise the red, green and blue values\n    const {\n      _a: r255,\n      _b: g255,\n      _c: b255\n    } = this.rgb();\n    const [r, g, b] = [r255, g255, b255].map(v => v / 255); // Convert to the lab rgb space\n\n    const rL = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;\n    const gL = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;\n    const bL = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92; // Convert to the xyz color space without bounding the values\n\n    const xU = (rL * 0.4124 + gL * 0.3576 + bL * 0.1805) / 0.95047;\n    const yU = (rL * 0.2126 + gL * 0.7152 + bL * 0.0722) / 1.00000;\n    const zU = (rL * 0.0193 + gL * 0.1192 + bL * 0.9505) / 1.08883; // Get the proper xyz values by applying the bounding\n\n    const x = xU > 0.008856 ? Math.pow(xU, 1 / 3) : 7.787 * xU + 16 / 116;\n    const y = yU > 0.008856 ? Math.pow(yU, 1 / 3) : 7.787 * yU + 16 / 116;\n    const z = zU > 0.008856 ? Math.pow(zU, 1 / 3) : 7.787 * zU + 16 / 116; // Make and return the color\n\n    const color = new Color(x, y, z, 'xyz');\n    return color;\n  }\n  /*\n  Input and Output methods\n  */\n\n\n  _clamped() {\n    const {\n      _a,\n      _b,\n      _c\n    } = this.rgb();\n    const {\n      max,\n      min,\n      round\n    } = Math;\n\n    const format = v => max(0, min(round(v), 255));\n\n    return [_a, _b, _c].map(format);\n  }\n  /*\n  Constructing colors\n  */\n\n\n}\n\nclass Point {\n  // Initialize\n  constructor(...args) {\n    this.init(...args);\n  } // Clone point\n\n\n  clone() {\n    return new Point(this);\n  }\n\n  init(x, y) {\n    const base = {\n      x: 0,\n      y: 0\n    }; // ensure source as object\n\n    const source = Array.isArray(x) ? {\n      x: x[0],\n      y: x[1]\n    } : typeof x === 'object' ? {\n      x: x.x,\n      y: x.y\n    } : {\n      x: x,\n      y: y\n    }; // merge source\n\n    this.x = source.x == null ? base.x : source.x;\n    this.y = source.y == null ? base.y : source.y;\n    return this;\n  }\n\n  toArray() {\n    return [this.x, this.y];\n  }\n\n  transform(m) {\n    return this.clone().transformO(m);\n  } // Transform point with matrix\n\n\n  transformO(m) {\n    if (!Matrix.isMatrixLike(m)) {\n      m = new Matrix(m);\n    }\n\n    const {\n      x,\n      y\n    } = this; // Perform the matrix multiplication\n\n    this.x = m.a * x + m.c * y + m.e;\n    this.y = m.b * x + m.d * y + m.f;\n    return this;\n  }\n\n}\nfunction point(x, y) {\n  return new Point(x, y).transformO(this.screenCTM().inverseO());\n}\n\nfunction closeEnough(a, b, threshold) {\n  return Math.abs(b - a) < (threshold || 1e-6);\n}\n\nclass Matrix {\n  constructor(...args) {\n    this.init(...args);\n  }\n\n  static formatTransforms(o) {\n    // Get all of the parameters required to form the matrix\n    const flipBoth = o.flip === 'both' || o.flip === true;\n    const flipX = o.flip && (flipBoth || o.flip === 'x') ? -1 : 1;\n    const flipY = o.flip && (flipBoth || o.flip === 'y') ? -1 : 1;\n    const skewX = o.skew && o.skew.length ? o.skew[0] : isFinite(o.skew) ? o.skew : isFinite(o.skewX) ? o.skewX : 0;\n    const skewY = o.skew && o.skew.length ? o.skew[1] : isFinite(o.skew) ? o.skew : isFinite(o.skewY) ? o.skewY : 0;\n    const scaleX = o.scale && o.scale.length ? o.scale[0] * flipX : isFinite(o.scale) ? o.scale * flipX : isFinite(o.scaleX) ? o.scaleX * flipX : flipX;\n    const scaleY = o.scale && o.scale.length ? o.scale[1] * flipY : isFinite(o.scale) ? o.scale * flipY : isFinite(o.scaleY) ? o.scaleY * flipY : flipY;\n    const shear = o.shear || 0;\n    const theta = o.rotate || o.theta || 0;\n    const origin = new Point(o.origin || o.around || o.ox || o.originX, o.oy || o.originY);\n    const ox = origin.x;\n    const oy = origin.y; // We need Point to be invalid if nothing was passed because we cannot default to 0 here. That is why NaN\n\n    const position = new Point(o.position || o.px || o.positionX || NaN, o.py || o.positionY || NaN);\n    const px = position.x;\n    const py = position.y;\n    const translate = new Point(o.translate || o.tx || o.translateX, o.ty || o.translateY);\n    const tx = translate.x;\n    const ty = translate.y;\n    const relative = new Point(o.relative || o.rx || o.relativeX, o.ry || o.relativeY);\n    const rx = relative.x;\n    const ry = relative.y; // Populate all of the values\n\n    return {\n      scaleX,\n      scaleY,\n      skewX,\n      skewY,\n      shear,\n      theta,\n      rx,\n      ry,\n      tx,\n      ty,\n      ox,\n      oy,\n      px,\n      py\n    };\n  }\n\n  static fromArray(a) {\n    return {\n      a: a[0],\n      b: a[1],\n      c: a[2],\n      d: a[3],\n      e: a[4],\n      f: a[5]\n    };\n  }\n\n  static isMatrixLike(o) {\n    return o.a != null || o.b != null || o.c != null || o.d != null || o.e != null || o.f != null;\n  } // left matrix, right matrix, target matrix which is overwritten\n\n\n  static matrixMultiply(l, r, o) {\n    // Work out the product directly\n    const a = l.a * r.a + l.c * r.b;\n    const b = l.b * r.a + l.d * r.b;\n    const c = l.a * r.c + l.c * r.d;\n    const d = l.b * r.c + l.d * r.d;\n    const e = l.e + l.a * r.e + l.c * r.f;\n    const f = l.f + l.b * r.e + l.d * r.f; // make sure to use local variables because l/r and o could be the same\n\n    o.a = a;\n    o.b = b;\n    o.c = c;\n    o.d = d;\n    o.e = e;\n    o.f = f;\n    return o;\n  }\n\n  around(cx, cy, matrix) {\n    return this.clone().aroundO(cx, cy, matrix);\n  } // Transform around a center point\n\n\n  aroundO(cx, cy, matrix) {\n    const dx = cx || 0;\n    const dy = cy || 0;\n    return this.translateO(-dx, -dy).lmultiplyO(matrix).translateO(dx, dy);\n  } // Clones this matrix\n\n\n  clone() {\n    return new Matrix(this);\n  } // Decomposes this matrix into its affine parameters\n\n\n  decompose(cx = 0, cy = 0) {\n    // Get the parameters from the matrix\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const e = this.e;\n    const f = this.f; // Figure out if the winding direction is clockwise or counterclockwise\n\n    const determinant = a * d - b * c;\n    const ccw = determinant > 0 ? 1 : -1; // Since we only shear in x, we can use the x basis to get the x scale\n    // and the rotation of the resulting matrix\n\n    const sx = ccw * Math.sqrt(a * a + b * b);\n    const thetaRad = Math.atan2(ccw * b, ccw * a);\n    const theta = 180 / Math.PI * thetaRad;\n    const ct = Math.cos(thetaRad);\n    const st = Math.sin(thetaRad); // We can then solve the y basis vector simultaneously to get the other\n    // two affine parameters directly from these parameters\n\n    const lam = (a * c + b * d) / determinant;\n    const sy = c * sx / (lam * a - b) || d * sx / (lam * b + a); // Use the translations\n\n    const tx = e - cx + cx * ct * sx + cy * (lam * ct * sx - st * sy);\n    const ty = f - cy + cx * st * sx + cy * (lam * st * sx + ct * sy); // Construct the decomposition and return it\n\n    return {\n      // Return the affine parameters\n      scaleX: sx,\n      scaleY: sy,\n      shear: lam,\n      rotate: theta,\n      translateX: tx,\n      translateY: ty,\n      originX: cx,\n      originY: cy,\n      // Return the matrix parameters\n      a: this.a,\n      b: this.b,\n      c: this.c,\n      d: this.d,\n      e: this.e,\n      f: this.f\n    };\n  } // Check if two matrices are equal\n\n\n  equals(other) {\n    if (other === this) return true;\n    const comp = new Matrix(other);\n    return closeEnough(this.a, comp.a) && closeEnough(this.b, comp.b) && closeEnough(this.c, comp.c) && closeEnough(this.d, comp.d) && closeEnough(this.e, comp.e) && closeEnough(this.f, comp.f);\n  } // Flip matrix on x or y, at a given offset\n\n\n  flip(axis, around) {\n    return this.clone().flipO(axis, around);\n  }\n\n  flipO(axis, around) {\n    return axis === 'x' ? this.scaleO(-1, 1, around, 0) : axis === 'y' ? this.scaleO(1, -1, 0, around) : this.scaleO(-1, -1, axis, around || axis); // Define an x, y flip point\n  } // Initialize\n\n\n  init(source) {\n    const base = Matrix.fromArray([1, 0, 0, 1, 0, 0]); // ensure source as object\n\n    source = source instanceof Element ? source.matrixify() : typeof source === 'string' ? Matrix.fromArray(source.split(delimiter).map(parseFloat)) : Array.isArray(source) ? Matrix.fromArray(source) : typeof source === 'object' && Matrix.isMatrixLike(source) ? source : typeof source === 'object' ? new Matrix().transform(source) : arguments.length === 6 ? Matrix.fromArray([].slice.call(arguments)) : base; // Merge the source matrix with the base matrix\n\n    this.a = source.a != null ? source.a : base.a;\n    this.b = source.b != null ? source.b : base.b;\n    this.c = source.c != null ? source.c : base.c;\n    this.d = source.d != null ? source.d : base.d;\n    this.e = source.e != null ? source.e : base.e;\n    this.f = source.f != null ? source.f : base.f;\n    return this;\n  }\n\n  inverse() {\n    return this.clone().inverseO();\n  } // Inverses matrix\n\n\n  inverseO() {\n    // Get the current parameters out of the matrix\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const e = this.e;\n    const f = this.f; // Invert the 2x2 matrix in the top left\n\n    const det = a * d - b * c;\n    if (!det) throw new Error('Cannot invert ' + this); // Calculate the top 2x2 matrix\n\n    const na = d / det;\n    const nb = -b / det;\n    const nc = -c / det;\n    const nd = a / det; // Apply the inverted matrix to the top right\n\n    const ne = -(na * e + nc * f);\n    const nf = -(nb * e + nd * f); // Construct the inverted matrix\n\n    this.a = na;\n    this.b = nb;\n    this.c = nc;\n    this.d = nd;\n    this.e = ne;\n    this.f = nf;\n    return this;\n  }\n\n  lmultiply(matrix) {\n    return this.clone().lmultiplyO(matrix);\n  }\n\n  lmultiplyO(matrix) {\n    const r = this;\n    const l = matrix instanceof Matrix ? matrix : new Matrix(matrix);\n    return Matrix.matrixMultiply(l, r, this);\n  } // Left multiplies by the given matrix\n\n\n  multiply(matrix) {\n    return this.clone().multiplyO(matrix);\n  }\n\n  multiplyO(matrix) {\n    // Get the matrices\n    const l = this;\n    const r = matrix instanceof Matrix ? matrix : new Matrix(matrix);\n    return Matrix.matrixMultiply(l, r, this);\n  } // Rotate matrix\n\n\n  rotate(r, cx, cy) {\n    return this.clone().rotateO(r, cx, cy);\n  }\n\n  rotateO(r, cx = 0, cy = 0) {\n    // Convert degrees to radians\n    r = radians(r);\n    const cos = Math.cos(r);\n    const sin = Math.sin(r);\n    const {\n      a,\n      b,\n      c,\n      d,\n      e,\n      f\n    } = this;\n    this.a = a * cos - b * sin;\n    this.b = b * cos + a * sin;\n    this.c = c * cos - d * sin;\n    this.d = d * cos + c * sin;\n    this.e = e * cos - f * sin + cy * sin - cx * cos + cx;\n    this.f = f * cos + e * sin - cx * sin - cy * cos + cy;\n    return this;\n  } // Scale matrix\n\n\n  scale(x, y, cx, cy) {\n    return this.clone().scaleO(...arguments);\n  }\n\n  scaleO(x, y = x, cx = 0, cy = 0) {\n    // Support uniform scaling\n    if (arguments.length === 3) {\n      cy = cx;\n      cx = y;\n      y = x;\n    }\n\n    const {\n      a,\n      b,\n      c,\n      d,\n      e,\n      f\n    } = this;\n    this.a = a * x;\n    this.b = b * y;\n    this.c = c * x;\n    this.d = d * y;\n    this.e = e * x - cx * x + cx;\n    this.f = f * y - cy * y + cy;\n    return this;\n  } // Shear matrix\n\n\n  shear(a, cx, cy) {\n    return this.clone().shearO(a, cx, cy);\n  }\n\n  shearO(lx, cx = 0, cy = 0) {\n    const {\n      a,\n      b,\n      c,\n      d,\n      e,\n      f\n    } = this;\n    this.a = a + b * lx;\n    this.c = c + d * lx;\n    this.e = e + f * lx - cy * lx;\n    return this;\n  } // Skew Matrix\n\n\n  skew(x, y, cx, cy) {\n    return this.clone().skewO(...arguments);\n  }\n\n  skewO(x, y = x, cx = 0, cy = 0) {\n    // support uniformal skew\n    if (arguments.length === 3) {\n      cy = cx;\n      cx = y;\n      y = x;\n    } // Convert degrees to radians\n\n\n    x = radians(x);\n    y = radians(y);\n    const lx = Math.tan(x);\n    const ly = Math.tan(y);\n    const {\n      a,\n      b,\n      c,\n      d,\n      e,\n      f\n    } = this;\n    this.a = a + b * lx;\n    this.b = b + a * ly;\n    this.c = c + d * lx;\n    this.d = d + c * ly;\n    this.e = e + f * lx - cy * lx;\n    this.f = f + e * ly - cx * ly;\n    return this;\n  } // SkewX\n\n\n  skewX(x, cx, cy) {\n    return this.skew(x, 0, cx, cy);\n  } // SkewY\n\n\n  skewY(y, cx, cy) {\n    return this.skew(0, y, cx, cy);\n  }\n\n  toArray() {\n    return [this.a, this.b, this.c, this.d, this.e, this.f];\n  } // Convert matrix to string\n\n\n  toString() {\n    return 'matrix(' + this.a + ',' + this.b + ',' + this.c + ',' + this.d + ',' + this.e + ',' + this.f + ')';\n  } // Transform a matrix into another matrix by manipulating the space\n\n\n  transform(o) {\n    // Check if o is a matrix and then left multiply it directly\n    if (Matrix.isMatrixLike(o)) {\n      const matrix = new Matrix(o);\n      return matrix.multiplyO(this);\n    } // Get the proposed transformations and the current transformations\n\n\n    const t = Matrix.formatTransforms(o);\n    const current = this;\n    const {\n      x: ox,\n      y: oy\n    } = new Point(t.ox, t.oy).transform(current); // Construct the resulting matrix\n\n    const transformer = new Matrix().translateO(t.rx, t.ry).lmultiplyO(current).translateO(-ox, -oy).scaleO(t.scaleX, t.scaleY).skewO(t.skewX, t.skewY).shearO(t.shear).rotateO(t.theta).translateO(ox, oy); // If we want the origin at a particular place, we force it there\n\n    if (isFinite(t.px) || isFinite(t.py)) {\n      const origin = new Point(ox, oy).transform(transformer); // TODO: Replace t.px with isFinite(t.px)\n      // Doesn't work because t.px is also 0 if it wasn't passed\n\n      const dx = isFinite(t.px) ? t.px - origin.x : 0;\n      const dy = isFinite(t.py) ? t.py - origin.y : 0;\n      transformer.translateO(dx, dy);\n    } // Translate now after positioning\n\n\n    transformer.translateO(t.tx, t.ty);\n    return transformer;\n  } // Translate matrix\n\n\n  translate(x, y) {\n    return this.clone().translateO(x, y);\n  }\n\n  translateO(x, y) {\n    this.e += x || 0;\n    this.f += y || 0;\n    return this;\n  }\n\n  valueOf() {\n    return {\n      a: this.a,\n      b: this.b,\n      c: this.c,\n      d: this.d,\n      e: this.e,\n      f: this.f\n    };\n  }\n\n}\nfunction ctm() {\n  return new Matrix(this.node.getCTM());\n}\nfunction screenCTM() {\n  /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537\n     This is needed because FF does not return the transformation matrix\n     for the inner coordinate system when getScreenCTM() is called on nested svgs.\n     However all other Browsers do that */\n  if (typeof this.isRoot === 'function' && !this.isRoot()) {\n    const rect = this.rect(1, 1);\n    const m = rect.node.getScreenCTM();\n    rect.remove();\n    return new Matrix(m);\n  }\n\n  return new Matrix(this.node.getScreenCTM());\n}\nregister(Matrix, 'Matrix');\n\nfunction parser() {\n  // Reuse cached element if possible\n  if (!parser.nodes) {\n    const svg = makeInstance().size(2, 0);\n    svg.node.style.cssText = ['opacity: 0', 'position: absolute', 'left: -100%', 'top: -100%', 'overflow: hidden'].join(';');\n    svg.attr('focusable', 'false');\n    svg.attr('aria-hidden', 'true');\n    const path = svg.path().node;\n    parser.nodes = {\n      svg,\n      path\n    };\n  }\n\n  if (!parser.nodes.svg.node.parentNode) {\n    const b = globals.document.body || globals.document.documentElement;\n    parser.nodes.svg.addTo(b);\n  }\n\n  return parser.nodes;\n}\n\nfunction isNulledBox(box) {\n  return !box.width && !box.height && !box.x && !box.y;\n}\nfunction domContains(node) {\n  return node === globals.document || (globals.document.documentElement.contains || function (node) {\n    // This is IE - it does not support contains() for top-level SVGs\n    while (node.parentNode) {\n      node = node.parentNode;\n    }\n\n    return node === globals.document;\n  }).call(globals.document.documentElement, node);\n}\nclass Box {\n  constructor(...args) {\n    this.init(...args);\n  }\n\n  addOffset() {\n    // offset by window scroll position, because getBoundingClientRect changes when window is scrolled\n    this.x += globals.window.pageXOffset;\n    this.y += globals.window.pageYOffset;\n    return new Box(this);\n  }\n\n  init(source) {\n    const base = [0, 0, 0, 0];\n    source = typeof source === 'string' ? source.split(delimiter).map(parseFloat) : Array.isArray(source) ? source : typeof source === 'object' ? [source.left != null ? source.left : source.x, source.top != null ? source.top : source.y, source.width, source.height] : arguments.length === 4 ? [].slice.call(arguments) : base;\n    this.x = source[0] || 0;\n    this.y = source[1] || 0;\n    this.width = this.w = source[2] || 0;\n    this.height = this.h = source[3] || 0; // Add more bounding box properties\n\n    this.x2 = this.x + this.w;\n    this.y2 = this.y + this.h;\n    this.cx = this.x + this.w / 2;\n    this.cy = this.y + this.h / 2;\n    return this;\n  }\n\n  isNulled() {\n    return isNulledBox(this);\n  } // Merge rect box with another, return a new instance\n\n\n  merge(box) {\n    const x = Math.min(this.x, box.x);\n    const y = Math.min(this.y, box.y);\n    const width = Math.max(this.x + this.width, box.x + box.width) - x;\n    const height = Math.max(this.y + this.height, box.y + box.height) - y;\n    return new Box(x, y, width, height);\n  }\n\n  toArray() {\n    return [this.x, this.y, this.width, this.height];\n  }\n\n  toString() {\n    return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height;\n  }\n\n  transform(m) {\n    if (!(m instanceof Matrix)) {\n      m = new Matrix(m);\n    }\n\n    let xMin = Infinity;\n    let xMax = -Infinity;\n    let yMin = Infinity;\n    let yMax = -Infinity;\n    const pts = [new Point(this.x, this.y), new Point(this.x2, this.y), new Point(this.x, this.y2), new Point(this.x2, this.y2)];\n    pts.forEach(function (p) {\n      p = p.transform(m);\n      xMin = Math.min(xMin, p.x);\n      xMax = Math.max(xMax, p.x);\n      yMin = Math.min(yMin, p.y);\n      yMax = Math.max(yMax, p.y);\n    });\n    return new Box(xMin, yMin, xMax - xMin, yMax - yMin);\n  }\n\n}\n\nfunction getBox(el, getBBoxFn, retry) {\n  let box;\n\n  try {\n    // Try to get the box with the provided function\n    box = getBBoxFn(el.node); // If the box is worthless and not even in the dom, retry\n    // by throwing an error here...\n\n    if (isNulledBox(box) && !domContains(el.node)) {\n      throw new Error('Element not in the dom');\n    }\n  } catch (e) {\n    // ... and calling the retry handler here\n    box = retry(el);\n  }\n\n  return box;\n}\n\nfunction bbox() {\n  // Function to get bbox is getBBox()\n  const getBBox = node => node.getBBox(); // Take all measures so that a stupid browser renders the element\n  // so we can get the bbox from it when we try again\n\n\n  const retry = el => {\n    try {\n      const clone = el.clone().addTo(parser().svg).show();\n      const box = clone.node.getBBox();\n      clone.remove();\n      return box;\n    } catch (e) {\n      // We give up...\n      throw new Error(`Getting bbox of element \"${el.node.nodeName}\" is not possible: ${e.toString()}`);\n    }\n  };\n\n  const box = getBox(this, getBBox, retry);\n  const bbox = new Box(box);\n  return bbox;\n}\nfunction rbox(el) {\n  const getRBox = node => node.getBoundingClientRect();\n\n  const retry = el => {\n    // There is no point in trying tricks here because if we insert the element into the dom ourselves\n    // it obviously will be at the wrong position\n    throw new Error(`Getting rbox of element \"${el.node.nodeName}\" is not possible`);\n  };\n\n  const box = getBox(this, getRBox, retry);\n  const rbox = new Box(box); // If an element was passed, we want the bbox in the coordinate system of that element\n\n  if (el) {\n    return rbox.transform(el.screenCTM().inverseO());\n  } // Else we want it in absolute screen coordinates\n  // Therefore we need to add the scrollOffset\n\n\n  return rbox.addOffset();\n} // Checks whether the given point is inside the bounding box\n\nfunction inside(x, y) {\n  const box = this.bbox();\n  return x > box.x && y > box.y && x < box.x + box.width && y < box.y + box.height;\n}\nregisterMethods({\n  viewbox: {\n    viewbox(x, y, width, height) {\n      // act as getter\n      if (x == null) return new Box(this.attr('viewBox')); // act as setter\n\n      return this.attr('viewBox', new Box(x, y, width, height));\n    },\n\n    zoom(level, point) {\n      // Its best to rely on the attributes here and here is why:\n      // clientXYZ: Doesn't work on non-root svgs because they dont have a CSSBox (silly!)\n      // getBoundingClientRect: Doesn't work because Chrome just ignores width and height of nested svgs completely\n      //                        that means, their clientRect is always as big as the content.\n      //                        Furthermore this size is incorrect if the element is further transformed by its parents\n      // computedStyle: Only returns meaningful values if css was used with px. We dont go this route here!\n      // getBBox: returns the bounding box of its content - that doesn't help!\n      let {\n        width,\n        height\n      } = this.attr(['width', 'height']); // Width and height is a string when a number with a unit is present which we can't use\n      // So we try clientXYZ\n\n      if (!width && !height || typeof width === 'string' || typeof height === 'string') {\n        width = this.node.clientWidth;\n        height = this.node.clientHeight;\n      } // Giving up...\n\n\n      if (!width || !height) {\n        throw new Error('Impossible to get absolute width and height. Please provide an absolute width and height attribute on the zooming element');\n      }\n\n      const v = this.viewbox();\n      const zoomX = width / v.width;\n      const zoomY = height / v.height;\n      const zoom = Math.min(zoomX, zoomY);\n\n      if (level == null) {\n        return zoom;\n      }\n\n      let zoomAmount = zoom / level; // Set the zoomAmount to the highest value which is safe to process and recover from\n      // The * 100 is a bit of wiggle room for the matrix transformation\n\n      if (zoomAmount === Infinity) zoomAmount = Number.MAX_SAFE_INTEGER / 100;\n      point = point || new Point(width / 2 / zoomX + v.x, height / 2 / zoomY + v.y);\n      const box = new Box(v).transform(new Matrix({\n        scale: zoomAmount,\n        origin: point\n      }));\n      return this.viewbox(box);\n    }\n\n  }\n});\nregister(Box, 'Box');\n\nclass List extends Array {\n  constructor(arr = [], ...args) {\n    super(arr, ...args);\n    if (typeof arr === 'number') return this;\n    this.length = 0;\n    this.push(...arr);\n  }\n\n}\nextend([List], {\n  each(fnOrMethodName, ...args) {\n    if (typeof fnOrMethodName === 'function') {\n      return this.map((el, i, arr) => {\n        return fnOrMethodName.call(el, el, i, arr);\n      });\n    } else {\n      return this.map(el => {\n        return el[fnOrMethodName](...args);\n      });\n    }\n  },\n\n  toArray() {\n    return Array.prototype.concat.apply([], this);\n  }\n\n});\nconst reserved = ['toArray', 'constructor', 'each'];\n\nList.extend = function (methods) {\n  methods = methods.reduce((obj, name) => {\n    // Don't overwrite own methods\n    if (reserved.includes(name)) return obj; // Don't add private methods\n\n    if (name[0] === '_') return obj; // Relay every call to each()\n\n    obj[name] = function (...attrs) {\n      return this.each(name, ...attrs);\n    };\n\n    return obj;\n  }, {});\n  extend([List], methods);\n};\n\nfunction baseFind(query, parent) {\n  return new List(map((parent || globals.document).querySelectorAll(query), function (node) {\n    return adopt(node);\n  }));\n} // Scoped find method\n\nfunction find(query) {\n  return baseFind(query, this.node);\n}\nfunction findOne(query) {\n  return adopt(this.node.querySelector(query));\n}\n\nlet listenerId = 0;\nconst windowEvents = {};\nfunction getEvents(instance) {\n  let n = instance.getEventHolder(); // We dont want to save events in global space\n\n  if (n === globals.window) n = windowEvents;\n  if (!n.events) n.events = {};\n  return n.events;\n}\nfunction getEventTarget(instance) {\n  return instance.getEventTarget();\n}\nfunction clearEvents(instance) {\n  let n = instance.getEventHolder();\n  if (n === globals.window) n = windowEvents;\n  if (n.events) n.events = {};\n} // Add event binder in the SVG namespace\n\nfunction on(node, events, listener, binding, options) {\n  const l = listener.bind(binding || node);\n  const instance = makeInstance(node);\n  const bag = getEvents(instance);\n  const n = getEventTarget(instance); // events can be an array of events or a string of events\n\n  events = Array.isArray(events) ? events : events.split(delimiter); // add id to listener\n\n  if (!listener._svgjsListenerId) {\n    listener._svgjsListenerId = ++listenerId;\n  }\n\n  events.forEach(function (event) {\n    const ev = event.split('.')[0];\n    const ns = event.split('.')[1] || '*'; // ensure valid object\n\n    bag[ev] = bag[ev] || {};\n    bag[ev][ns] = bag[ev][ns] || {}; // reference listener\n\n    bag[ev][ns][listener._svgjsListenerId] = l; // add listener\n\n    n.addEventListener(ev, l, options || false);\n  });\n} // Add event unbinder in the SVG namespace\n\nfunction off(node, events, listener, options) {\n  const instance = makeInstance(node);\n  const bag = getEvents(instance);\n  const n = getEventTarget(instance); // listener can be a function or a number\n\n  if (typeof listener === 'function') {\n    listener = listener._svgjsListenerId;\n    if (!listener) return;\n  } // events can be an array of events or a string or undefined\n\n\n  events = Array.isArray(events) ? events : (events || '').split(delimiter);\n  events.forEach(function (event) {\n    const ev = event && event.split('.')[0];\n    const ns = event && event.split('.')[1];\n    let namespace, l;\n\n    if (listener) {\n      // remove listener reference\n      if (bag[ev] && bag[ev][ns || '*']) {\n        // removeListener\n        n.removeEventListener(ev, bag[ev][ns || '*'][listener], options || false);\n        delete bag[ev][ns || '*'][listener];\n      }\n    } else if (ev && ns) {\n      // remove all listeners for a namespaced event\n      if (bag[ev] && bag[ev][ns]) {\n        for (l in bag[ev][ns]) {\n          off(n, [ev, ns].join('.'), l);\n        }\n\n        delete bag[ev][ns];\n      }\n    } else if (ns) {\n      // remove all listeners for a specific namespace\n      for (event in bag) {\n        for (namespace in bag[event]) {\n          if (ns === namespace) {\n            off(n, [event, ns].join('.'));\n          }\n        }\n      }\n    } else if (ev) {\n      // remove all listeners for the event\n      if (bag[ev]) {\n        for (namespace in bag[ev]) {\n          off(n, [ev, namespace].join('.'));\n        }\n\n        delete bag[ev];\n      }\n    } else {\n      // remove all listeners on a given node\n      for (event in bag) {\n        off(n, event);\n      }\n\n      clearEvents(instance);\n    }\n  });\n}\nfunction dispatch(node, event, data, options) {\n  const n = getEventTarget(node); // Dispatch event\n\n  if (event instanceof globals.window.Event) {\n    n.dispatchEvent(event);\n  } else {\n    event = new globals.window.CustomEvent(event, {\n      detail: data,\n      cancelable: true,\n      ...options\n    });\n    n.dispatchEvent(event);\n  }\n\n  return event;\n}\n\nclass EventTarget extends Base {\n  addEventListener() {}\n\n  dispatch(event, data, options) {\n    return dispatch(this, event, data, options);\n  }\n\n  dispatchEvent(event) {\n    const bag = this.getEventHolder().events;\n    if (!bag) return true;\n    const events = bag[event.type];\n\n    for (const i in events) {\n      for (const j in events[i]) {\n        events[i][j](event);\n      }\n    }\n\n    return !event.defaultPrevented;\n  } // Fire given event\n\n\n  fire(event, data, options) {\n    this.dispatch(event, data, options);\n    return this;\n  }\n\n  getEventHolder() {\n    return this;\n  }\n\n  getEventTarget() {\n    return this;\n  } // Unbind event from listener\n\n\n  off(event, listener, options) {\n    off(this, event, listener, options);\n    return this;\n  } // Bind given event to listener\n\n\n  on(event, listener, binding, options) {\n    on(this, event, listener, binding, options);\n    return this;\n  }\n\n  removeEventListener() {}\n\n}\nregister(EventTarget, 'EventTarget');\n\nfunction noop() {} // Default animation values\n\nconst timeline = {\n  duration: 400,\n  ease: '>',\n  delay: 0\n}; // Default attribute values\n\nconst attrs = {\n  // fill and stroke\n  'fill-opacity': 1,\n  'stroke-opacity': 1,\n  'stroke-width': 0,\n  'stroke-linejoin': 'miter',\n  'stroke-linecap': 'butt',\n  fill: '#000000',\n  stroke: '#000000',\n  opacity: 1,\n  // position\n  x: 0,\n  y: 0,\n  cx: 0,\n  cy: 0,\n  // size\n  width: 0,\n  height: 0,\n  // radius\n  r: 0,\n  rx: 0,\n  ry: 0,\n  // gradient\n  offset: 0,\n  'stop-opacity': 1,\n  'stop-color': '#000000',\n  // text\n  'text-anchor': 'start'\n};\n\nvar defaults = {\n  __proto__: null,\n  noop: noop,\n  timeline: timeline,\n  attrs: attrs\n};\n\nclass SVGArray extends Array {\n  constructor(...args) {\n    super(...args);\n    this.init(...args);\n  }\n\n  clone() {\n    return new this.constructor(this);\n  }\n\n  init(arr) {\n    // This catches the case, that native map tries to create an array with new Array(1)\n    if (typeof arr === 'number') return this;\n    this.length = 0;\n    this.push(...this.parse(arr));\n    return this;\n  } // Parse whitespace separated string\n\n\n  parse(array = []) {\n    // If already is an array, no need to parse it\n    if (array instanceof Array) return array;\n    return array.trim().split(delimiter).map(parseFloat);\n  }\n\n  toArray() {\n    return Array.prototype.concat.apply([], this);\n  }\n\n  toSet() {\n    return new Set(this);\n  }\n\n  toString() {\n    return this.join(' ');\n  } // Flattens the array if needed\n\n\n  valueOf() {\n    const ret = [];\n    ret.push(...this);\n    return ret;\n  }\n\n}\n\nclass SVGNumber {\n  // Initialize\n  constructor(...args) {\n    this.init(...args);\n  }\n\n  convert(unit) {\n    return new SVGNumber(this.value, unit);\n  } // Divide number\n\n\n  divide(number) {\n    number = new SVGNumber(number);\n    return new SVGNumber(this / number, this.unit || number.unit);\n  }\n\n  init(value, unit) {\n    unit = Array.isArray(value) ? value[1] : unit;\n    value = Array.isArray(value) ? value[0] : value; // initialize defaults\n\n    this.value = 0;\n    this.unit = unit || ''; // parse value\n\n    if (typeof value === 'number') {\n      // ensure a valid numeric value\n      this.value = isNaN(value) ? 0 : !isFinite(value) ? value < 0 ? -3.4e+38 : +3.4e+38 : value;\n    } else if (typeof value === 'string') {\n      unit = value.match(numberAndUnit);\n\n      if (unit) {\n        // make value numeric\n        this.value = parseFloat(unit[1]); // normalize\n\n        if (unit[5] === '%') {\n          this.value /= 100;\n        } else if (unit[5] === 's') {\n          this.value *= 1000;\n        } // store unit\n\n\n        this.unit = unit[5];\n      }\n    } else {\n      if (value instanceof SVGNumber) {\n        this.value = value.valueOf();\n        this.unit = value.unit;\n      }\n    }\n\n    return this;\n  } // Subtract number\n\n\n  minus(number) {\n    number = new SVGNumber(number);\n    return new SVGNumber(this - number, this.unit || number.unit);\n  } // Add number\n\n\n  plus(number) {\n    number = new SVGNumber(number);\n    return new SVGNumber(this + number, this.unit || number.unit);\n  } // Multiply number\n\n\n  times(number) {\n    number = new SVGNumber(number);\n    return new SVGNumber(this * number, this.unit || number.unit);\n  }\n\n  toArray() {\n    return [this.value, this.unit];\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n  toString() {\n    return (this.unit === '%' ? ~~(this.value * 1e8) / 1e6 : this.unit === 's' ? this.value / 1e3 : this.value) + this.unit;\n  }\n\n  valueOf() {\n    return this.value;\n  }\n\n}\n\nconst hooks = [];\nfunction registerAttrHook(fn) {\n  hooks.push(fn);\n} // Set svg element attribute\n\nfunction attr(attr, val, ns) {\n  // act as full getter\n  if (attr == null) {\n    // get an object of attributes\n    attr = {};\n    val = this.node.attributes;\n\n    for (const node of val) {\n      attr[node.nodeName] = isNumber.test(node.nodeValue) ? parseFloat(node.nodeValue) : node.nodeValue;\n    }\n\n    return attr;\n  } else if (attr instanceof Array) {\n    // loop through array and get all values\n    return attr.reduce((last, curr) => {\n      last[curr] = this.attr(curr);\n      return last;\n    }, {});\n  } else if (typeof attr === 'object' && attr.constructor === Object) {\n    // apply every attribute individually if an object is passed\n    for (val in attr) this.attr(val, attr[val]);\n  } else if (val === null) {\n    // remove value\n    this.node.removeAttribute(attr);\n  } else if (val == null) {\n    // act as a getter if the first and only argument is not an object\n    val = this.node.getAttribute(attr);\n    return val == null ? attrs[attr] : isNumber.test(val) ? parseFloat(val) : val;\n  } else {\n    // Loop through hooks and execute them to convert value\n    val = hooks.reduce((_val, hook) => {\n      return hook(attr, _val, this);\n    }, val); // ensure correct numeric values (also accepts NaN and Infinity)\n\n    if (typeof val === 'number') {\n      val = new SVGNumber(val);\n    } else if (Color.isColor(val)) {\n      // ensure full hex color\n      val = new Color(val);\n    } else if (val.constructor === Array) {\n      // Check for plain arrays and parse array values\n      val = new SVGArray(val);\n    } // if the passed attribute is leading...\n\n\n    if (attr === 'leading') {\n      // ... call the leading method instead\n      if (this.leading) {\n        this.leading(val);\n      }\n    } else {\n      // set given attribute on node\n      typeof ns === 'string' ? this.node.setAttributeNS(ns, attr, val.toString()) : this.node.setAttribute(attr, val.toString());\n    } // rebuild if required\n\n\n    if (this.rebuild && (attr === 'font-size' || attr === 'x')) {\n      this.rebuild();\n    }\n  }\n\n  return this;\n}\n\nclass Dom extends EventTarget {\n  constructor(node, attrs) {\n    super();\n    this.node = node;\n    this.type = node.nodeName;\n\n    if (attrs && node !== attrs) {\n      this.attr(attrs);\n    }\n  } // Add given element at a position\n\n\n  add(element, i) {\n    element = makeInstance(element); // If non-root svg nodes are added we have to remove their namespaces\n\n    if (element.removeNamespace && this.node instanceof globals.window.SVGElement) {\n      element.removeNamespace();\n    }\n\n    if (i == null) {\n      this.node.appendChild(element.node);\n    } else if (element.node !== this.node.childNodes[i]) {\n      this.node.insertBefore(element.node, this.node.childNodes[i]);\n    }\n\n    return this;\n  } // Add element to given container and return self\n\n\n  addTo(parent, i) {\n    return makeInstance(parent).put(this, i);\n  } // Returns all child elements\n\n\n  children() {\n    return new List(map(this.node.children, function (node) {\n      return adopt(node);\n    }));\n  } // Remove all elements in this container\n\n\n  clear() {\n    // remove children\n    while (this.node.hasChildNodes()) {\n      this.node.removeChild(this.node.lastChild);\n    }\n\n    return this;\n  } // Clone element\n\n\n  clone(deep = true, assignNewIds = true) {\n    // write dom data to the dom so the clone can pickup the data\n    this.writeDataToDom(); // clone element\n\n    let nodeClone = this.node.cloneNode(deep);\n\n    if (assignNewIds) {\n      // assign new id\n      nodeClone = assignNewId(nodeClone);\n    }\n\n    return new this.constructor(nodeClone);\n  } // Iterates over all children and invokes a given block\n\n\n  each(block, deep) {\n    const children = this.children();\n    let i, il;\n\n    for (i = 0, il = children.length; i < il; i++) {\n      block.apply(children[i], [i, children]);\n\n      if (deep) {\n        children[i].each(block, deep);\n      }\n    }\n\n    return this;\n  }\n\n  element(nodeName, attrs) {\n    return this.put(new Dom(create(nodeName), attrs));\n  } // Get first child\n\n\n  first() {\n    return adopt(this.node.firstChild);\n  } // Get a element at the given index\n\n\n  get(i) {\n    return adopt(this.node.childNodes[i]);\n  }\n\n  getEventHolder() {\n    return this.node;\n  }\n\n  getEventTarget() {\n    return this.node;\n  } // Checks if the given element is a child\n\n\n  has(element) {\n    return this.index(element) >= 0;\n  }\n\n  html(htmlOrFn, outerHTML) {\n    return this.xml(htmlOrFn, outerHTML, html);\n  } // Get / set id\n\n\n  id(id) {\n    // generate new id if no id set\n    if (typeof id === 'undefined' && !this.node.id) {\n      this.node.id = eid(this.type);\n    } // don't set directly with this.node.id to make `null` work correctly\n\n\n    return this.attr('id', id);\n  } // Gets index of given element\n\n\n  index(element) {\n    return [].slice.call(this.node.childNodes).indexOf(element.node);\n  } // Get the last child\n\n\n  last() {\n    return adopt(this.node.lastChild);\n  } // matches the element vs a css selector\n\n\n  matches(selector) {\n    const el = this.node;\n    const matcher = el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector || null;\n    return matcher && matcher.call(el, selector);\n  } // Returns the parent element instance\n\n\n  parent(type) {\n    let parent = this; // check for parent\n\n    if (!parent.node.parentNode) return null; // get parent element\n\n    parent = adopt(parent.node.parentNode);\n    if (!type) return parent; // loop through ancestors if type is given\n\n    do {\n      if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent;\n    } while (parent = adopt(parent.node.parentNode));\n\n    return parent;\n  } // Basically does the same as `add()` but returns the added element instead\n\n\n  put(element, i) {\n    element = makeInstance(element);\n    this.add(element, i);\n    return element;\n  } // Add element to given container and return container\n\n\n  putIn(parent, i) {\n    return makeInstance(parent).add(this, i);\n  } // Remove element\n\n\n  remove() {\n    if (this.parent()) {\n      this.parent().removeElement(this);\n    }\n\n    return this;\n  } // Remove a given child\n\n\n  removeElement(element) {\n    this.node.removeChild(element.node);\n    return this;\n  } // Replace this with element\n\n\n  replace(element) {\n    element = makeInstance(element);\n\n    if (this.node.parentNode) {\n      this.node.parentNode.replaceChild(element.node, this.node);\n    }\n\n    return element;\n  }\n\n  round(precision = 2, map = null) {\n    const factor = 10 ** precision;\n    const attrs = this.attr(map);\n\n    for (const i in attrs) {\n      if (typeof attrs[i] === 'number') {\n        attrs[i] = Math.round(attrs[i] * factor) / factor;\n      }\n    }\n\n    this.attr(attrs);\n    return this;\n  } // Import / Export raw svg\n\n\n  svg(svgOrFn, outerSVG) {\n    return this.xml(svgOrFn, outerSVG, svg);\n  } // Return id on string conversion\n\n\n  toString() {\n    return this.id();\n  }\n\n  words(text) {\n    // This is faster than removing all children and adding a new one\n    this.node.textContent = text;\n    return this;\n  }\n\n  wrap(node) {\n    const parent = this.parent();\n\n    if (!parent) {\n      return this.addTo(node);\n    }\n\n    const position = parent.index(this);\n    return parent.put(node, position).put(this);\n  } // write svgjs data to the dom\n\n\n  writeDataToDom() {\n    // dump variables recursively\n    this.each(function () {\n      this.writeDataToDom();\n    });\n    return this;\n  } // Import / Export raw svg\n\n\n  xml(xmlOrFn, outerXML, ns) {\n    if (typeof xmlOrFn === 'boolean') {\n      ns = outerXML;\n      outerXML = xmlOrFn;\n      xmlOrFn = null;\n    } // act as getter if no svg string is given\n\n\n    if (xmlOrFn == null || typeof xmlOrFn === 'function') {\n      // The default for exports is, that the outerNode is included\n      outerXML = outerXML == null ? true : outerXML; // write svgjs data to the dom\n\n      this.writeDataToDom();\n      let current = this; // An export modifier was passed\n\n      if (xmlOrFn != null) {\n        current = adopt(current.node.cloneNode(true)); // If the user wants outerHTML we need to process this node, too\n\n        if (outerXML) {\n          const result = xmlOrFn(current);\n          current = result || current; // The user does not want this node? Well, then he gets nothing\n\n          if (result === false) return '';\n        } // Deep loop through all children and apply modifier\n\n\n        current.each(function () {\n          const result = xmlOrFn(this);\n\n          const _this = result || this; // If modifier returns false, discard node\n\n\n          if (result === false) {\n            this.remove(); // If modifier returns new node, use it\n          } else if (result && this !== _this) {\n            this.replace(_this);\n          }\n        }, true);\n      } // Return outer or inner content\n\n\n      return outerXML ? current.node.outerHTML : current.node.innerHTML;\n    } // Act as setter if we got a string\n    // The default for import is, that the current node is not replaced\n\n\n    outerXML = outerXML == null ? false : outerXML; // Create temporary holder\n\n    const well = create('wrapper', ns);\n    const fragment = globals.document.createDocumentFragment(); // Dump raw svg\n\n    well.innerHTML = xmlOrFn; // Transplant nodes into the fragment\n\n    for (let len = well.children.length; len--;) {\n      fragment.appendChild(well.firstElementChild);\n    }\n\n    const parent = this.parent(); // Add the whole fragment at once\n\n    return outerXML ? this.replace(fragment) && parent : this.add(fragment);\n  }\n\n}\nextend(Dom, {\n  attr,\n  find,\n  findOne\n});\nregister(Dom, 'Dom');\n\nclass Element extends Dom {\n  constructor(node, attrs) {\n    super(node, attrs); // initialize data object\n\n    this.dom = {}; // create circular reference\n\n    this.node.instance = this;\n\n    if (node.hasAttribute('svgjs:data')) {\n      // pull svgjs data from the dom (getAttributeNS doesn't work in html5)\n      this.setData(JSON.parse(node.getAttribute('svgjs:data')) || {});\n    }\n  } // Move element by its center\n\n\n  center(x, y) {\n    return this.cx(x).cy(y);\n  } // Move by center over x-axis\n\n\n  cx(x) {\n    return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2);\n  } // Move by center over y-axis\n\n\n  cy(y) {\n    return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2);\n  } // Get defs\n\n\n  defs() {\n    const root = this.root();\n    return root && root.defs();\n  } // Relative move over x and y axes\n\n\n  dmove(x, y) {\n    return this.dx(x).dy(y);\n  } // Relative move over x axis\n\n\n  dx(x = 0) {\n    return this.x(new SVGNumber(x).plus(this.x()));\n  } // Relative move over y axis\n\n\n  dy(y = 0) {\n    return this.y(new SVGNumber(y).plus(this.y()));\n  }\n\n  getEventHolder() {\n    return this;\n  } // Set height of element\n\n\n  height(height) {\n    return this.attr('height', height);\n  } // Move element to given x and y values\n\n\n  move(x, y) {\n    return this.x(x).y(y);\n  } // return array of all ancestors of given type up to the root svg\n\n\n  parents(until = this.root()) {\n    const isSelector = typeof until === 'string';\n\n    if (!isSelector) {\n      until = makeInstance(until);\n    }\n\n    const parents = new List();\n    let parent = this;\n\n    while ((parent = parent.parent()) && parent.node !== globals.document && parent.nodeName !== '#document-fragment') {\n      parents.push(parent);\n\n      if (!isSelector && parent.node === until.node) {\n        break;\n      }\n\n      if (isSelector && parent.matches(until)) {\n        break;\n      }\n\n      if (parent.node === this.root().node) {\n        // We worked our way to the root and didn't match `until`\n        return null;\n      }\n    }\n\n    return parents;\n  } // Get referenced element form attribute value\n\n\n  reference(attr) {\n    attr = this.attr(attr);\n    if (!attr) return null;\n    const m = (attr + '').match(reference);\n    return m ? makeInstance(m[1]) : null;\n  } // Get parent document\n\n\n  root() {\n    const p = this.parent(getClass(root));\n    return p && p.root();\n  } // set given data to the elements data property\n\n\n  setData(o) {\n    this.dom = o;\n    return this;\n  } // Set element size to given width and height\n\n\n  size(width, height) {\n    const p = proportionalSize(this, width, height);\n    return this.width(new SVGNumber(p.width)).height(new SVGNumber(p.height));\n  } // Set width of element\n\n\n  width(width) {\n    return this.attr('width', width);\n  } // write svgjs data to the dom\n\n\n  writeDataToDom() {\n    // remove previously set data\n    this.node.removeAttribute('svgjs:data');\n\n    if (Object.keys(this.dom).length) {\n      this.node.setAttribute('svgjs:data', JSON.stringify(this.dom)); // see #428\n    }\n\n    return super.writeDataToDom();\n  } // Move over x-axis\n\n\n  x(x) {\n    return this.attr('x', x);\n  } // Move over y-axis\n\n\n  y(y) {\n    return this.attr('y', y);\n  }\n\n}\nextend(Element, {\n  bbox,\n  rbox,\n  inside,\n  point,\n  ctm,\n  screenCTM\n});\nregister(Element, 'Element');\n\nconst sugar = {\n  stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset'],\n  fill: ['color', 'opacity', 'rule'],\n  prefix: function (t, a) {\n    return a === 'color' ? t : t + '-' + a;\n  }\n} // Add sugar for fill and stroke\n;\n['fill', 'stroke'].forEach(function (m) {\n  const extension = {};\n  let i;\n\n  extension[m] = function (o) {\n    if (typeof o === 'undefined') {\n      return this.attr(m);\n    }\n\n    if (typeof o === 'string' || o instanceof Color || Color.isRgb(o) || o instanceof Element) {\n      this.attr(m, o);\n    } else {\n      // set all attributes from sugar.fill and sugar.stroke list\n      for (i = sugar[m].length - 1; i >= 0; i--) {\n        if (o[sugar[m][i]] != null) {\n          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]]);\n        }\n      }\n    }\n\n    return this;\n  };\n\n  registerMethods(['Element', 'Runner'], extension);\n});\nregisterMethods(['Element', 'Runner'], {\n  // Let the user set the matrix directly\n  matrix: function (mat, b, c, d, e, f) {\n    // Act as a getter\n    if (mat == null) {\n      return new Matrix(this);\n    } // Act as a setter, the user can pass a matrix or a set of numbers\n\n\n    return this.attr('transform', new Matrix(mat, b, c, d, e, f));\n  },\n  // Map rotation to transform\n  rotate: function (angle, cx, cy) {\n    return this.transform({\n      rotate: angle,\n      ox: cx,\n      oy: cy\n    }, true);\n  },\n  // Map skew to transform\n  skew: function (x, y, cx, cy) {\n    return arguments.length === 1 || arguments.length === 3 ? this.transform({\n      skew: x,\n      ox: y,\n      oy: cx\n    }, true) : this.transform({\n      skew: [x, y],\n      ox: cx,\n      oy: cy\n    }, true);\n  },\n  shear: function (lam, cx, cy) {\n    return this.transform({\n      shear: lam,\n      ox: cx,\n      oy: cy\n    }, true);\n  },\n  // Map scale to transform\n  scale: function (x, y, cx, cy) {\n    return arguments.length === 1 || arguments.length === 3 ? this.transform({\n      scale: x,\n      ox: y,\n      oy: cx\n    }, true) : this.transform({\n      scale: [x, y],\n      ox: cx,\n      oy: cy\n    }, true);\n  },\n  // Map translate to transform\n  translate: function (x, y) {\n    return this.transform({\n      translate: [x, y]\n    }, true);\n  },\n  // Map relative translations to transform\n  relative: function (x, y) {\n    return this.transform({\n      relative: [x, y]\n    }, true);\n  },\n  // Map flip to transform\n  flip: function (direction = 'both', origin = 'center') {\n    if ('xybothtrue'.indexOf(direction) === -1) {\n      origin = direction;\n      direction = 'both';\n    }\n\n    return this.transform({\n      flip: direction,\n      origin: origin\n    }, true);\n  },\n  // Opacity\n  opacity: function (value) {\n    return this.attr('opacity', value);\n  }\n});\nregisterMethods('radius', {\n  // Add x and y radius\n  radius: function (x, y = x) {\n    const type = (this._element || this).type;\n    return type === 'radialGradient' ? this.attr('r', new SVGNumber(x)) : this.rx(x).ry(y);\n  }\n});\nregisterMethods('Path', {\n  // Get path length\n  length: function () {\n    return this.node.getTotalLength();\n  },\n  // Get point at length\n  pointAt: function (length) {\n    return new Point(this.node.getPointAtLength(length));\n  }\n});\nregisterMethods(['Element', 'Runner'], {\n  // Set font\n  font: function (a, v) {\n    if (typeof a === 'object') {\n      for (v in a) this.font(v, a[v]);\n\n      return this;\n    }\n\n    return a === 'leading' ? this.leading(v) : a === 'anchor' ? this.attr('text-anchor', v) : a === 'size' || a === 'family' || a === 'weight' || a === 'stretch' || a === 'variant' || a === 'style' ? this.attr('font-' + a, v) : this.attr(a, v);\n  }\n}); // Add events to elements\n\nconst methods = ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', 'mouseenter', 'mouseleave', 'touchstart', 'touchmove', 'touchleave', 'touchend', 'touchcancel'].reduce(function (last, event) {\n  // add event to Element\n  const fn = function (f) {\n    if (f === null) {\n      this.off(event);\n    } else {\n      this.on(event, f);\n    }\n\n    return this;\n  };\n\n  last[event] = fn;\n  return last;\n}, {});\nregisterMethods('Element', methods);\n\nfunction untransform() {\n  return this.attr('transform', null);\n} // merge the whole transformation chain into one matrix and returns it\n\nfunction matrixify() {\n  const matrix = (this.attr('transform') || '' // split transformations\n  ).split(transforms).slice(0, -1).map(function (str) {\n    // generate key => value pairs\n    const kv = str.trim().split('(');\n    return [kv[0], kv[1].split(delimiter).map(function (str) {\n      return parseFloat(str);\n    })];\n  }).reverse() // merge every transformation into one matrix\n  .reduce(function (matrix, transform) {\n    if (transform[0] === 'matrix') {\n      return matrix.lmultiply(Matrix.fromArray(transform[1]));\n    }\n\n    return matrix[transform[0]].apply(matrix, transform[1]);\n  }, new Matrix());\n  return matrix;\n} // add an element to another parent without changing the visual representation on the screen\n\nfunction toParent(parent, i) {\n  if (this === parent) return this;\n  const ctm = this.screenCTM();\n  const pCtm = parent.screenCTM().inverse();\n  this.addTo(parent, i).untransform().transform(pCtm.multiply(ctm));\n  return this;\n} // same as above with parent equals root-svg\n\nfunction toRoot(i) {\n  return this.toParent(this.root(), i);\n} // Add transformations\n\nfunction transform(o, relative) {\n  // Act as a getter if no object was passed\n  if (o == null || typeof o === 'string') {\n    const decomposed = new Matrix(this).decompose();\n    return o == null ? decomposed : decomposed[o];\n  }\n\n  if (!Matrix.isMatrixLike(o)) {\n    // Set the origin according to the defined transform\n    o = { ...o,\n      origin: getOrigin(o, this)\n    };\n  } // The user can pass a boolean, an Element or an Matrix or nothing\n\n\n  const cleanRelative = relative === true ? this : relative || false;\n  const result = new Matrix(cleanRelative).transform(o);\n  return this.attr('transform', result);\n}\nregisterMethods('Element', {\n  untransform,\n  matrixify,\n  toParent,\n  toRoot,\n  transform\n});\n\nclass Container extends Element {\n  flatten(parent = this, index) {\n    this.each(function () {\n      if (this instanceof Container) {\n        return this.flatten().ungroup();\n      }\n    });\n    return this;\n  }\n\n  ungroup(parent = this.parent(), index = parent.index(this)) {\n    // when parent != this, we want append all elements to the end\n    index = index === -1 ? parent.children().length : index;\n    this.each(function (i, children) {\n      // reverse each\n      return children[children.length - i - 1].toParent(parent, index);\n    });\n    return this.remove();\n  }\n\n}\nregister(Container, 'Container');\n\nclass Defs extends Container {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('defs', node), attrs);\n  }\n\n  flatten() {\n    return this;\n  }\n\n  ungroup() {\n    return this;\n  }\n\n}\nregister(Defs, 'Defs');\n\nclass Shape extends Element {}\nregister(Shape, 'Shape');\n\nfunction rx(rx) {\n  return this.attr('rx', rx);\n} // Radius y value\n\nfunction ry(ry) {\n  return this.attr('ry', ry);\n} // Move over x-axis\n\nfunction x$3(x) {\n  return x == null ? this.cx() - this.rx() : this.cx(x + this.rx());\n} // Move over y-axis\n\nfunction y$3(y) {\n  return y == null ? this.cy() - this.ry() : this.cy(y + this.ry());\n} // Move by center over x-axis\n\nfunction cx$1(x) {\n  return this.attr('cx', x);\n} // Move by center over y-axis\n\nfunction cy$1(y) {\n  return this.attr('cy', y);\n} // Set width of element\n\nfunction width$2(width) {\n  return width == null ? this.rx() * 2 : this.rx(new SVGNumber(width).divide(2));\n} // Set height of element\n\nfunction height$2(height) {\n  return height == null ? this.ry() * 2 : this.ry(new SVGNumber(height).divide(2));\n}\n\nvar circled = {\n  __proto__: null,\n  rx: rx,\n  ry: ry,\n  x: x$3,\n  y: y$3,\n  cx: cx$1,\n  cy: cy$1,\n  width: width$2,\n  height: height$2\n};\n\nclass Ellipse extends Shape {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('ellipse', node), attrs);\n  }\n\n  size(width, height) {\n    const p = proportionalSize(this, width, height);\n    return this.rx(new SVGNumber(p.width).divide(2)).ry(new SVGNumber(p.height).divide(2));\n  }\n\n}\nextend(Ellipse, circled);\nregisterMethods('Container', {\n  // Create an ellipse\n  ellipse: wrapWithAttrCheck(function (width = 0, height = width) {\n    return this.put(new Ellipse()).size(width, height).move(0, 0);\n  })\n});\nregister(Ellipse, 'Ellipse');\n\nclass Fragment extends Dom {\n  constructor(node = globals.document.createDocumentFragment()) {\n    super(node);\n  } // Import / Export raw xml\n\n\n  xml(xmlOrFn, outerXML, ns) {\n    if (typeof xmlOrFn === 'boolean') {\n      ns = outerXML;\n      outerXML = xmlOrFn;\n      xmlOrFn = null;\n    } // because this is a fragment we have to put all elements into a wrapper first\n    // before we can get the innerXML from it\n\n\n    if (xmlOrFn == null || typeof xmlOrFn === 'function') {\n      const wrapper = new Dom(create('wrapper', ns));\n      wrapper.add(this.node.cloneNode(true));\n      return wrapper.xml(false, ns);\n    } // Act as setter if we got a string\n\n\n    return super.xml(xmlOrFn, false, ns);\n  }\n\n}\n\nregister(Fragment, 'Fragment');\n\nfunction from(x, y) {\n  return (this._element || this).type === 'radialGradient' ? this.attr({\n    fx: new SVGNumber(x),\n    fy: new SVGNumber(y)\n  }) : this.attr({\n    x1: new SVGNumber(x),\n    y1: new SVGNumber(y)\n  });\n}\nfunction to(x, y) {\n  return (this._element || this).type === 'radialGradient' ? this.attr({\n    cx: new SVGNumber(x),\n    cy: new SVGNumber(y)\n  }) : this.attr({\n    x2: new SVGNumber(x),\n    y2: new SVGNumber(y)\n  });\n}\n\nvar gradiented = {\n  __proto__: null,\n  from: from,\n  to: to\n};\n\nclass Gradient extends Container {\n  constructor(type, attrs) {\n    super(nodeOrNew(type + 'Gradient', typeof type === 'string' ? null : type), attrs);\n  } // custom attr to handle transform\n\n\n  attr(a, b, c) {\n    if (a === 'transform') a = 'gradientTransform';\n    return super.attr(a, b, c);\n  }\n\n  bbox() {\n    return new Box();\n  }\n\n  targets() {\n    return baseFind('svg [fill*=' + this.id() + ']');\n  } // Alias string conversion to fill\n\n\n  toString() {\n    return this.url();\n  } // Update gradient\n\n\n  update(block) {\n    // remove all stops\n    this.clear(); // invoke passed block\n\n    if (typeof block === 'function') {\n      block.call(this, this);\n    }\n\n    return this;\n  } // Return the fill id\n\n\n  url() {\n    return 'url(#' + this.id() + ')';\n  }\n\n}\nextend(Gradient, gradiented);\nregisterMethods({\n  Container: {\n    // Create gradient element in defs\n    gradient(...args) {\n      return this.defs().gradient(...args);\n    }\n\n  },\n  // define gradient\n  Defs: {\n    gradient: wrapWithAttrCheck(function (type, block) {\n      return this.put(new Gradient(type)).update(block);\n    })\n  }\n});\nregister(Gradient, 'Gradient');\n\nclass Pattern extends Container {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('pattern', node), attrs);\n  } // custom attr to handle transform\n\n\n  attr(a, b, c) {\n    if (a === 'transform') a = 'patternTransform';\n    return super.attr(a, b, c);\n  }\n\n  bbox() {\n    return new Box();\n  }\n\n  targets() {\n    return baseFind('svg [fill*=' + this.id() + ']');\n  } // Alias string conversion to fill\n\n\n  toString() {\n    return this.url();\n  } // Update pattern by rebuilding\n\n\n  update(block) {\n    // remove content\n    this.clear(); // invoke passed block\n\n    if (typeof block === 'function') {\n      block.call(this, this);\n    }\n\n    return this;\n  } // Return the fill id\n\n\n  url() {\n    return 'url(#' + this.id() + ')';\n  }\n\n}\nregisterMethods({\n  Container: {\n    // Create pattern element in defs\n    pattern(...args) {\n      return this.defs().pattern(...args);\n    }\n\n  },\n  Defs: {\n    pattern: wrapWithAttrCheck(function (width, height, block) {\n      return this.put(new Pattern()).update(block).attr({\n        x: 0,\n        y: 0,\n        width: width,\n        height: height,\n        patternUnits: 'userSpaceOnUse'\n      });\n    })\n  }\n});\nregister(Pattern, 'Pattern');\n\nclass Image extends Shape {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('image', node), attrs);\n  } // (re)load image\n\n\n  load(url, callback) {\n    if (!url) return this;\n    const img = new globals.window.Image();\n    on(img, 'load', function (e) {\n      const p = this.parent(Pattern); // ensure image size\n\n      if (this.width() === 0 && this.height() === 0) {\n        this.size(img.width, img.height);\n      }\n\n      if (p instanceof Pattern) {\n        // ensure pattern size if not set\n        if (p.width() === 0 && p.height() === 0) {\n          p.size(this.width(), this.height());\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback.call(this, e);\n      }\n    }, this);\n    on(img, 'load error', function () {\n      // dont forget to unbind memory leaking events\n      off(img);\n    });\n    return this.attr('href', img.src = url, xlink);\n  }\n\n}\nregisterAttrHook(function (attr, val, _this) {\n  // convert image fill and stroke to patterns\n  if (attr === 'fill' || attr === 'stroke') {\n    if (isImage.test(val)) {\n      val = _this.root().defs().image(val);\n    }\n  }\n\n  if (val instanceof Image) {\n    val = _this.root().defs().pattern(0, 0, pattern => {\n      pattern.add(val);\n    });\n  }\n\n  return val;\n});\nregisterMethods({\n  Container: {\n    // create image element, load image and set its size\n    image: wrapWithAttrCheck(function (source, callback) {\n      return this.put(new Image()).size(0, 0).load(source, callback);\n    })\n  }\n});\nregister(Image, 'Image');\n\nclass PointArray extends SVGArray {\n  // Get bounding box of points\n  bbox() {\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    let minX = Infinity;\n    let minY = Infinity;\n    this.forEach(function (el) {\n      maxX = Math.max(el[0], maxX);\n      maxY = Math.max(el[1], maxY);\n      minX = Math.min(el[0], minX);\n      minY = Math.min(el[1], minY);\n    });\n    return new Box(minX, minY, maxX - minX, maxY - minY);\n  } // Move point string\n\n\n  move(x, y) {\n    const box = this.bbox(); // get relative offset\n\n    x -= box.x;\n    y -= box.y; // move every point\n\n    if (!isNaN(x) && !isNaN(y)) {\n      for (let i = this.length - 1; i >= 0; i--) {\n        this[i] = [this[i][0] + x, this[i][1] + y];\n      }\n    }\n\n    return this;\n  } // Parse point string and flat array\n\n\n  parse(array = [0, 0]) {\n    const points = []; // if it is an array, we flatten it and therefore clone it to 1 depths\n\n    if (array instanceof Array) {\n      array = Array.prototype.concat.apply([], array);\n    } else {\n      // Else, it is considered as a string\n      // parse points\n      array = array.trim().split(delimiter).map(parseFloat);\n    } // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints\n    // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.\n\n\n    if (array.length % 2 !== 0) array.pop(); // wrap points in two-tuples\n\n    for (let i = 0, len = array.length; i < len; i = i + 2) {\n      points.push([array[i], array[i + 1]]);\n    }\n\n    return points;\n  } // Resize poly string\n\n\n  size(width, height) {\n    let i;\n    const box = this.bbox(); // recalculate position of all points according to new size\n\n    for (i = this.length - 1; i >= 0; i--) {\n      if (box.width) this[i][0] = (this[i][0] - box.x) * width / box.width + box.x;\n      if (box.height) this[i][1] = (this[i][1] - box.y) * height / box.height + box.y;\n    }\n\n    return this;\n  } // Convert array to line object\n\n\n  toLine() {\n    return {\n      x1: this[0][0],\n      y1: this[0][1],\n      x2: this[1][0],\n      y2: this[1][1]\n    };\n  } // Convert array to string\n\n\n  toString() {\n    const array = []; // convert to a poly point string\n\n    for (let i = 0, il = this.length; i < il; i++) {\n      array.push(this[i].join(','));\n    }\n\n    return array.join(' ');\n  }\n\n  transform(m) {\n    return this.clone().transformO(m);\n  } // transform points with matrix (similar to Point.transform)\n\n\n  transformO(m) {\n    if (!Matrix.isMatrixLike(m)) {\n      m = new Matrix(m);\n    }\n\n    for (let i = this.length; i--;) {\n      // Perform the matrix multiplication\n      const [x, y] = this[i];\n      this[i][0] = m.a * x + m.c * y + m.e;\n      this[i][1] = m.b * x + m.d * y + m.f;\n    }\n\n    return this;\n  }\n\n}\n\nconst MorphArray = PointArray; // Move by left top corner over x-axis\n\nfunction x$2(x) {\n  return x == null ? this.bbox().x : this.move(x, this.bbox().y);\n} // Move by left top corner over y-axis\n\nfunction y$2(y) {\n  return y == null ? this.bbox().y : this.move(this.bbox().x, y);\n} // Set width of element\n\nfunction width$1(width) {\n  const b = this.bbox();\n  return width == null ? b.width : this.size(width, b.height);\n} // Set height of element\n\nfunction height$1(height) {\n  const b = this.bbox();\n  return height == null ? b.height : this.size(b.width, height);\n}\n\nvar pointed = {\n  __proto__: null,\n  MorphArray: MorphArray,\n  x: x$2,\n  y: y$2,\n  width: width$1,\n  height: height$1\n};\n\nclass Line extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('line', node), attrs);\n  } // Get array\n\n\n  array() {\n    return new PointArray([[this.attr('x1'), this.attr('y1')], [this.attr('x2'), this.attr('y2')]]);\n  } // Move by left top corner\n\n\n  move(x, y) {\n    return this.attr(this.array().move(x, y).toLine());\n  } // Overwrite native plot() method\n\n\n  plot(x1, y1, x2, y2) {\n    if (x1 == null) {\n      return this.array();\n    } else if (typeof y1 !== 'undefined') {\n      x1 = {\n        x1,\n        y1,\n        x2,\n        y2\n      };\n    } else {\n      x1 = new PointArray(x1).toLine();\n    }\n\n    return this.attr(x1);\n  } // Set element size to given width and height\n\n\n  size(width, height) {\n    const p = proportionalSize(this, width, height);\n    return this.attr(this.array().size(p.width, p.height).toLine());\n  }\n\n}\nextend(Line, pointed);\nregisterMethods({\n  Container: {\n    // Create a line element\n    line: wrapWithAttrCheck(function (...args) {\n      // make sure plot is called as a setter\n      // x1 is not necessarily a number, it can also be an array, a string and a PointArray\n      return Line.prototype.plot.apply(this.put(new Line()), args[0] != null ? args : [0, 0, 0, 0]);\n    })\n  }\n});\nregister(Line, 'Line');\n\nclass Marker extends Container {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('marker', node), attrs);\n  } // Set height of element\n\n\n  height(height) {\n    return this.attr('markerHeight', height);\n  }\n\n  orient(orient) {\n    return this.attr('orient', orient);\n  } // Set marker refX and refY\n\n\n  ref(x, y) {\n    return this.attr('refX', x).attr('refY', y);\n  } // Return the fill id\n\n\n  toString() {\n    return 'url(#' + this.id() + ')';\n  } // Update marker\n\n\n  update(block) {\n    // remove all content\n    this.clear(); // invoke passed block\n\n    if (typeof block === 'function') {\n      block.call(this, this);\n    }\n\n    return this;\n  } // Set width of element\n\n\n  width(width) {\n    return this.attr('markerWidth', width);\n  }\n\n}\nregisterMethods({\n  Container: {\n    marker(...args) {\n      // Create marker element in defs\n      return this.defs().marker(...args);\n    }\n\n  },\n  Defs: {\n    // Create marker\n    marker: wrapWithAttrCheck(function (width, height, block) {\n      // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto\n      return this.put(new Marker()).size(width, height).ref(width / 2, height / 2).viewbox(0, 0, width, height).attr('orient', 'auto').update(block);\n    })\n  },\n  marker: {\n    // Create and attach markers\n    marker(marker, width, height, block) {\n      let attr = ['marker']; // Build attribute name\n\n      if (marker !== 'all') attr.push(marker);\n      attr = attr.join('-'); // Set marker attribute\n\n      marker = arguments[1] instanceof Marker ? arguments[1] : this.defs().marker(width, height, block);\n      return this.attr(attr, marker);\n    }\n\n  }\n});\nregister(Marker, 'Marker');\n\n/***\nBase Class\n==========\nThe base stepper class that will be\n***/\n\nfunction makeSetterGetter(k, f) {\n  return function (v) {\n    if (v == null) return this[k];\n    this[k] = v;\n    if (f) f.call(this);\n    return this;\n  };\n}\n\nconst easing = {\n  '-': function (pos) {\n    return pos;\n  },\n  '<>': function (pos) {\n    return -Math.cos(pos * Math.PI) / 2 + 0.5;\n  },\n  '>': function (pos) {\n    return Math.sin(pos * Math.PI / 2);\n  },\n  '<': function (pos) {\n    return -Math.cos(pos * Math.PI / 2) + 1;\n  },\n  bezier: function (x1, y1, x2, y2) {\n    // see https://www.w3.org/TR/css-easing-1/#cubic-bezier-algo\n    return function (t) {\n      if (t < 0) {\n        if (x1 > 0) {\n          return y1 / x1 * t;\n        } else if (x2 > 0) {\n          return y2 / x2 * t;\n        } else {\n          return 0;\n        }\n      } else if (t > 1) {\n        if (x2 < 1) {\n          return (1 - y2) / (1 - x2) * t + (y2 - x2) / (1 - x2);\n        } else if (x1 < 1) {\n          return (1 - y1) / (1 - x1) * t + (y1 - x1) / (1 - x1);\n        } else {\n          return 1;\n        }\n      } else {\n        return 3 * t * (1 - t) ** 2 * y1 + 3 * t ** 2 * (1 - t) * y2 + t ** 3;\n      }\n    };\n  },\n  // see https://www.w3.org/TR/css-easing-1/#step-timing-function-algo\n  steps: function (steps, stepPosition = 'end') {\n    // deal with \"jump-\" prefix\n    stepPosition = stepPosition.split('-').reverse()[0];\n    let jumps = steps;\n\n    if (stepPosition === 'none') {\n      --jumps;\n    } else if (stepPosition === 'both') {\n      ++jumps;\n    } // The beforeFlag is essentially useless\n\n\n    return (t, beforeFlag = false) => {\n      // Step is called currentStep in referenced url\n      let step = Math.floor(t * steps);\n      const jumping = t * step % 1 === 0;\n\n      if (stepPosition === 'start' || stepPosition === 'both') {\n        ++step;\n      }\n\n      if (beforeFlag && jumping) {\n        --step;\n      }\n\n      if (t >= 0 && step < 0) {\n        step = 0;\n      }\n\n      if (t <= 1 && step > jumps) {\n        step = jumps;\n      }\n\n      return step / jumps;\n    };\n  }\n};\nclass Stepper {\n  done() {\n    return false;\n  }\n\n}\n/***\nEasing Functions\n================\n***/\n\nclass Ease extends Stepper {\n  constructor(fn = timeline.ease) {\n    super();\n    this.ease = easing[fn] || fn;\n  }\n\n  step(from, to, pos) {\n    if (typeof from !== 'number') {\n      return pos < 1 ? from : to;\n    }\n\n    return from + (to - from) * this.ease(pos);\n  }\n\n}\n/***\nController Types\n================\n***/\n\nclass Controller extends Stepper {\n  constructor(fn) {\n    super();\n    this.stepper = fn;\n  }\n\n  done(c) {\n    return c.done;\n  }\n\n  step(current, target, dt, c) {\n    return this.stepper(current, target, dt, c);\n  }\n\n}\n\nfunction recalculate() {\n  // Apply the default parameters\n  const duration = (this._duration || 500) / 1000;\n  const overshoot = this._overshoot || 0; // Calculate the PID natural response\n\n  const eps = 1e-10;\n  const pi = Math.PI;\n  const os = Math.log(overshoot / 100 + eps);\n  const zeta = -os / Math.sqrt(pi * pi + os * os);\n  const wn = 3.9 / (zeta * duration); // Calculate the Spring values\n\n  this.d = 2 * zeta * wn;\n  this.k = wn * wn;\n}\n\nclass Spring extends Controller {\n  constructor(duration = 500, overshoot = 0) {\n    super();\n    this.duration(duration).overshoot(overshoot);\n  }\n\n  step(current, target, dt, c) {\n    if (typeof current === 'string') return current;\n    c.done = dt === Infinity;\n    if (dt === Infinity) return target;\n    if (dt === 0) return current;\n    if (dt > 100) dt = 16;\n    dt /= 1000; // Get the previous velocity\n\n    const velocity = c.velocity || 0; // Apply the control to get the new position and store it\n\n    const acceleration = -this.d * velocity - this.k * (current - target);\n    const newPosition = current + velocity * dt + acceleration * dt * dt / 2; // Store the velocity\n\n    c.velocity = velocity + acceleration * dt; // Figure out if we have converged, and if so, pass the value\n\n    c.done = Math.abs(target - newPosition) + Math.abs(velocity) < 0.002;\n    return c.done ? target : newPosition;\n  }\n\n}\nextend(Spring, {\n  duration: makeSetterGetter('_duration', recalculate),\n  overshoot: makeSetterGetter('_overshoot', recalculate)\n});\nclass PID extends Controller {\n  constructor(p = 0.1, i = 0.01, d = 0, windup = 1000) {\n    super();\n    this.p(p).i(i).d(d).windup(windup);\n  }\n\n  step(current, target, dt, c) {\n    if (typeof current === 'string') return current;\n    c.done = dt === Infinity;\n    if (dt === Infinity) return target;\n    if (dt === 0) return current;\n    const p = target - current;\n    let i = (c.integral || 0) + p * dt;\n    const d = (p - (c.error || 0)) / dt;\n    const windup = this._windup; // antiwindup\n\n    if (windup !== false) {\n      i = Math.max(-windup, Math.min(i, windup));\n    }\n\n    c.error = p;\n    c.integral = i;\n    c.done = Math.abs(p) < 0.001;\n    return c.done ? target : current + (this.P * p + this.I * i + this.D * d);\n  }\n\n}\nextend(PID, {\n  windup: makeSetterGetter('_windup'),\n  p: makeSetterGetter('P'),\n  i: makeSetterGetter('I'),\n  d: makeSetterGetter('D')\n});\n\nconst segmentParameters = {\n  M: 2,\n  L: 2,\n  H: 1,\n  V: 1,\n  C: 6,\n  S: 4,\n  Q: 4,\n  T: 2,\n  A: 7,\n  Z: 0\n};\nconst pathHandlers = {\n  M: function (c, p, p0) {\n    p.x = p0.x = c[0];\n    p.y = p0.y = c[1];\n    return ['M', p.x, p.y];\n  },\n  L: function (c, p) {\n    p.x = c[0];\n    p.y = c[1];\n    return ['L', c[0], c[1]];\n  },\n  H: function (c, p) {\n    p.x = c[0];\n    return ['H', c[0]];\n  },\n  V: function (c, p) {\n    p.y = c[0];\n    return ['V', c[0]];\n  },\n  C: function (c, p) {\n    p.x = c[4];\n    p.y = c[5];\n    return ['C', c[0], c[1], c[2], c[3], c[4], c[5]];\n  },\n  S: function (c, p) {\n    p.x = c[2];\n    p.y = c[3];\n    return ['S', c[0], c[1], c[2], c[3]];\n  },\n  Q: function (c, p) {\n    p.x = c[2];\n    p.y = c[3];\n    return ['Q', c[0], c[1], c[2], c[3]];\n  },\n  T: function (c, p) {\n    p.x = c[0];\n    p.y = c[1];\n    return ['T', c[0], c[1]];\n  },\n  Z: function (c, p, p0) {\n    p.x = p0.x;\n    p.y = p0.y;\n    return ['Z'];\n  },\n  A: function (c, p) {\n    p.x = c[5];\n    p.y = c[6];\n    return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]];\n  }\n};\nconst mlhvqtcsaz = 'mlhvqtcsaz'.split('');\n\nfor (let i = 0, il = mlhvqtcsaz.length; i < il; ++i) {\n  pathHandlers[mlhvqtcsaz[i]] = function (i) {\n    return function (c, p, p0) {\n      if (i === 'H') c[0] = c[0] + p.x;else if (i === 'V') c[0] = c[0] + p.y;else if (i === 'A') {\n        c[5] = c[5] + p.x;\n        c[6] = c[6] + p.y;\n      } else {\n        for (let j = 0, jl = c.length; j < jl; ++j) {\n          c[j] = c[j] + (j % 2 ? p.y : p.x);\n        }\n      }\n      return pathHandlers[i](c, p, p0);\n    };\n  }(mlhvqtcsaz[i].toUpperCase());\n}\n\nfunction makeAbsolut(parser) {\n  const command = parser.segment[0];\n  return pathHandlers[command](parser.segment.slice(1), parser.p, parser.p0);\n}\n\nfunction segmentComplete(parser) {\n  return parser.segment.length && parser.segment.length - 1 === segmentParameters[parser.segment[0].toUpperCase()];\n}\n\nfunction startNewSegment(parser, token) {\n  parser.inNumber && finalizeNumber(parser, false);\n  const pathLetter = isPathLetter.test(token);\n\n  if (pathLetter) {\n    parser.segment = [token];\n  } else {\n    const lastCommand = parser.lastCommand;\n    const small = lastCommand.toLowerCase();\n    const isSmall = lastCommand === small;\n    parser.segment = [small === 'm' ? isSmall ? 'l' : 'L' : lastCommand];\n  }\n\n  parser.inSegment = true;\n  parser.lastCommand = parser.segment[0];\n  return pathLetter;\n}\n\nfunction finalizeNumber(parser, inNumber) {\n  if (!parser.inNumber) throw new Error('Parser Error');\n  parser.number && parser.segment.push(parseFloat(parser.number));\n  parser.inNumber = inNumber;\n  parser.number = '';\n  parser.pointSeen = false;\n  parser.hasExponent = false;\n\n  if (segmentComplete(parser)) {\n    finalizeSegment(parser);\n  }\n}\n\nfunction finalizeSegment(parser) {\n  parser.inSegment = false;\n\n  if (parser.absolute) {\n    parser.segment = makeAbsolut(parser);\n  }\n\n  parser.segments.push(parser.segment);\n}\n\nfunction isArcFlag(parser) {\n  if (!parser.segment.length) return false;\n  const isArc = parser.segment[0].toUpperCase() === 'A';\n  const length = parser.segment.length;\n  return isArc && (length === 4 || length === 5);\n}\n\nfunction isExponential(parser) {\n  return parser.lastToken.toUpperCase() === 'E';\n}\n\nfunction pathParser(d, toAbsolute = true) {\n  let index = 0;\n  let token = '';\n  const parser = {\n    segment: [],\n    inNumber: false,\n    number: '',\n    lastToken: '',\n    inSegment: false,\n    segments: [],\n    pointSeen: false,\n    hasExponent: false,\n    absolute: toAbsolute,\n    p0: new Point(),\n    p: new Point()\n  };\n\n  while (parser.lastToken = token, token = d.charAt(index++)) {\n    if (!parser.inSegment) {\n      if (startNewSegment(parser, token)) {\n        continue;\n      }\n    }\n\n    if (token === '.') {\n      if (parser.pointSeen || parser.hasExponent) {\n        finalizeNumber(parser, false);\n        --index;\n        continue;\n      }\n\n      parser.inNumber = true;\n      parser.pointSeen = true;\n      parser.number += token;\n      continue;\n    }\n\n    if (!isNaN(parseInt(token))) {\n      if (parser.number === '0' || isArcFlag(parser)) {\n        parser.inNumber = true;\n        parser.number = token;\n        finalizeNumber(parser, true);\n        continue;\n      }\n\n      parser.inNumber = true;\n      parser.number += token;\n      continue;\n    }\n\n    if (token === ' ' || token === ',') {\n      if (parser.inNumber) {\n        finalizeNumber(parser, false);\n      }\n\n      continue;\n    }\n\n    if (token === '-') {\n      if (parser.inNumber && !isExponential(parser)) {\n        finalizeNumber(parser, false);\n        --index;\n        continue;\n      }\n\n      parser.number += token;\n      parser.inNumber = true;\n      continue;\n    }\n\n    if (token.toUpperCase() === 'E') {\n      parser.number += token;\n      parser.hasExponent = true;\n      continue;\n    }\n\n    if (isPathLetter.test(token)) {\n      if (parser.inNumber) {\n        finalizeNumber(parser, false);\n      } else if (!segmentComplete(parser)) {\n        throw new Error('parser Error');\n      } else {\n        finalizeSegment(parser);\n      }\n\n      --index;\n    }\n  }\n\n  if (parser.inNumber) {\n    finalizeNumber(parser, false);\n  }\n\n  if (parser.inSegment && segmentComplete(parser)) {\n    finalizeSegment(parser);\n  }\n\n  return parser.segments;\n}\n\nfunction arrayToString(a) {\n  let s = '';\n\n  for (let i = 0, il = a.length; i < il; i++) {\n    s += a[i][0];\n\n    if (a[i][1] != null) {\n      s += a[i][1];\n\n      if (a[i][2] != null) {\n        s += ' ';\n        s += a[i][2];\n\n        if (a[i][3] != null) {\n          s += ' ';\n          s += a[i][3];\n          s += ' ';\n          s += a[i][4];\n\n          if (a[i][5] != null) {\n            s += ' ';\n            s += a[i][5];\n            s += ' ';\n            s += a[i][6];\n\n            if (a[i][7] != null) {\n              s += ' ';\n              s += a[i][7];\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return s + ' ';\n}\n\nclass PathArray extends SVGArray {\n  // Get bounding box of path\n  bbox() {\n    parser().path.setAttribute('d', this.toString());\n    return new Box(parser.nodes.path.getBBox());\n  } // Move path string\n\n\n  move(x, y) {\n    // get bounding box of current situation\n    const box = this.bbox(); // get relative offset\n\n    x -= box.x;\n    y -= box.y;\n\n    if (!isNaN(x) && !isNaN(y)) {\n      // move every point\n      for (let l, i = this.length - 1; i >= 0; i--) {\n        l = this[i][0];\n\n        if (l === 'M' || l === 'L' || l === 'T') {\n          this[i][1] += x;\n          this[i][2] += y;\n        } else if (l === 'H') {\n          this[i][1] += x;\n        } else if (l === 'V') {\n          this[i][1] += y;\n        } else if (l === 'C' || l === 'S' || l === 'Q') {\n          this[i][1] += x;\n          this[i][2] += y;\n          this[i][3] += x;\n          this[i][4] += y;\n\n          if (l === 'C') {\n            this[i][5] += x;\n            this[i][6] += y;\n          }\n        } else if (l === 'A') {\n          this[i][6] += x;\n          this[i][7] += y;\n        }\n      }\n    }\n\n    return this;\n  } // Absolutize and parse path to array\n\n\n  parse(d = 'M0 0') {\n    if (Array.isArray(d)) {\n      d = Array.prototype.concat.apply([], d).toString();\n    }\n\n    return pathParser(d);\n  } // Resize path string\n\n\n  size(width, height) {\n    // get bounding box of current situation\n    const box = this.bbox();\n    let i, l; // If the box width or height is 0 then we ignore\n    // transformations on the respective axis\n\n    box.width = box.width === 0 ? 1 : box.width;\n    box.height = box.height === 0 ? 1 : box.height; // recalculate position of all points according to new size\n\n    for (i = this.length - 1; i >= 0; i--) {\n      l = this[i][0];\n\n      if (l === 'M' || l === 'L' || l === 'T') {\n        this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;\n        this[i][2] = (this[i][2] - box.y) * height / box.height + box.y;\n      } else if (l === 'H') {\n        this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;\n      } else if (l === 'V') {\n        this[i][1] = (this[i][1] - box.y) * height / box.height + box.y;\n      } else if (l === 'C' || l === 'S' || l === 'Q') {\n        this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;\n        this[i][2] = (this[i][2] - box.y) * height / box.height + box.y;\n        this[i][3] = (this[i][3] - box.x) * width / box.width + box.x;\n        this[i][4] = (this[i][4] - box.y) * height / box.height + box.y;\n\n        if (l === 'C') {\n          this[i][5] = (this[i][5] - box.x) * width / box.width + box.x;\n          this[i][6] = (this[i][6] - box.y) * height / box.height + box.y;\n        }\n      } else if (l === 'A') {\n        // resize radii\n        this[i][1] = this[i][1] * width / box.width;\n        this[i][2] = this[i][2] * height / box.height; // move position values\n\n        this[i][6] = (this[i][6] - box.x) * width / box.width + box.x;\n        this[i][7] = (this[i][7] - box.y) * height / box.height + box.y;\n      }\n    }\n\n    return this;\n  } // Convert array to string\n\n\n  toString() {\n    return arrayToString(this);\n  }\n\n}\n\nconst getClassForType = value => {\n  const type = typeof value;\n\n  if (type === 'number') {\n    return SVGNumber;\n  } else if (type === 'string') {\n    if (Color.isColor(value)) {\n      return Color;\n    } else if (delimiter.test(value)) {\n      return isPathLetter.test(value) ? PathArray : SVGArray;\n    } else if (numberAndUnit.test(value)) {\n      return SVGNumber;\n    } else {\n      return NonMorphable;\n    }\n  } else if (morphableTypes.indexOf(value.constructor) > -1) {\n    return value.constructor;\n  } else if (Array.isArray(value)) {\n    return SVGArray;\n  } else if (type === 'object') {\n    return ObjectBag;\n  } else {\n    return NonMorphable;\n  }\n};\n\nclass Morphable {\n  constructor(stepper) {\n    this._stepper = stepper || new Ease('-');\n    this._from = null;\n    this._to = null;\n    this._type = null;\n    this._context = null;\n    this._morphObj = null;\n  }\n\n  at(pos) {\n    return this._morphObj.morph(this._from, this._to, pos, this._stepper, this._context);\n  }\n\n  done() {\n    const complete = this._context.map(this._stepper.done).reduce(function (last, curr) {\n      return last && curr;\n    }, true);\n\n    return complete;\n  }\n\n  from(val) {\n    if (val == null) {\n      return this._from;\n    }\n\n    this._from = this._set(val);\n    return this;\n  }\n\n  stepper(stepper) {\n    if (stepper == null) return this._stepper;\n    this._stepper = stepper;\n    return this;\n  }\n\n  to(val) {\n    if (val == null) {\n      return this._to;\n    }\n\n    this._to = this._set(val);\n    return this;\n  }\n\n  type(type) {\n    // getter\n    if (type == null) {\n      return this._type;\n    } // setter\n\n\n    this._type = type;\n    return this;\n  }\n\n  _set(value) {\n    if (!this._type) {\n      this.type(getClassForType(value));\n    }\n\n    let result = new this._type(value);\n\n    if (this._type === Color) {\n      result = this._to ? result[this._to[4]]() : this._from ? result[this._from[4]]() : result;\n    }\n\n    if (this._type === ObjectBag) {\n      result = this._to ? result.align(this._to) : this._from ? result.align(this._from) : result;\n    }\n\n    result = result.toConsumable();\n    this._morphObj = this._morphObj || new this._type();\n    this._context = this._context || Array.apply(null, Array(result.length)).map(Object).map(function (o) {\n      o.done = true;\n      return o;\n    });\n    return result;\n  }\n\n}\nclass NonMorphable {\n  constructor(...args) {\n    this.init(...args);\n  }\n\n  init(val) {\n    val = Array.isArray(val) ? val[0] : val;\n    this.value = val;\n    return this;\n  }\n\n  toArray() {\n    return [this.value];\n  }\n\n  valueOf() {\n    return this.value;\n  }\n\n}\nclass TransformBag {\n  constructor(...args) {\n    this.init(...args);\n  }\n\n  init(obj) {\n    if (Array.isArray(obj)) {\n      obj = {\n        scaleX: obj[0],\n        scaleY: obj[1],\n        shear: obj[2],\n        rotate: obj[3],\n        translateX: obj[4],\n        translateY: obj[5],\n        originX: obj[6],\n        originY: obj[7]\n      };\n    }\n\n    Object.assign(this, TransformBag.defaults, obj);\n    return this;\n  }\n\n  toArray() {\n    const v = this;\n    return [v.scaleX, v.scaleY, v.shear, v.rotate, v.translateX, v.translateY, v.originX, v.originY];\n  }\n\n}\nTransformBag.defaults = {\n  scaleX: 1,\n  scaleY: 1,\n  shear: 0,\n  rotate: 0,\n  translateX: 0,\n  translateY: 0,\n  originX: 0,\n  originY: 0\n};\n\nconst sortByKey = (a, b) => {\n  return a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0;\n};\n\nclass ObjectBag {\n  constructor(...args) {\n    this.init(...args);\n  }\n\n  align(other) {\n    const values = this.values;\n\n    for (let i = 0, il = values.length; i < il; ++i) {\n      // If the type is the same we only need to check if the color is in the correct format\n      if (values[i + 1] === other[i + 1]) {\n        if (values[i + 1] === Color && other[i + 7] !== values[i + 7]) {\n          const space = other[i + 7];\n          const color = new Color(this.values.splice(i + 3, 5))[space]().toArray();\n          this.values.splice(i + 3, 0, ...color);\n        }\n\n        i += values[i + 2] + 2;\n        continue;\n      }\n\n      if (!other[i + 1]) {\n        return this;\n      } // The types differ, so we overwrite the new type with the old one\n      // And initialize it with the types default (e.g. black for color or 0 for number)\n\n\n      const defaultObject = new other[i + 1]().toArray(); // Than we fix the values array\n\n      const toDelete = values[i + 2] + 3;\n      values.splice(i, toDelete, other[i], other[i + 1], other[i + 2], ...defaultObject);\n      i += values[i + 2] + 2;\n    }\n\n    return this;\n  }\n\n  init(objOrArr) {\n    this.values = [];\n\n    if (Array.isArray(objOrArr)) {\n      this.values = objOrArr.slice();\n      return;\n    }\n\n    objOrArr = objOrArr || {};\n    const entries = [];\n\n    for (const i in objOrArr) {\n      const Type = getClassForType(objOrArr[i]);\n      const val = new Type(objOrArr[i]).toArray();\n      entries.push([i, Type, val.length, ...val]);\n    }\n\n    entries.sort(sortByKey);\n    this.values = entries.reduce((last, curr) => last.concat(curr), []);\n    return this;\n  }\n\n  toArray() {\n    return this.values;\n  }\n\n  valueOf() {\n    const obj = {};\n    const arr = this.values; // for (var i = 0, len = arr.length; i < len; i += 2) {\n\n    while (arr.length) {\n      const key = arr.shift();\n      const Type = arr.shift();\n      const num = arr.shift();\n      const values = arr.splice(0, num);\n      obj[key] = new Type(values); // .valueOf()\n    }\n\n    return obj;\n  }\n\n}\nconst morphableTypes = [NonMorphable, TransformBag, ObjectBag];\nfunction registerMorphableType(type = []) {\n  morphableTypes.push(...[].concat(type));\n}\nfunction makeMorphable() {\n  extend(morphableTypes, {\n    to(val) {\n      return new Morphable().type(this.constructor).from(this.toArray()) // this.valueOf())\n      .to(val);\n    },\n\n    fromArray(arr) {\n      this.init(arr);\n      return this;\n    },\n\n    toConsumable() {\n      return this.toArray();\n    },\n\n    morph(from, to, pos, stepper, context) {\n      const mapper = function (i, index) {\n        return stepper.step(i, to[index], pos, context[index], context);\n      };\n\n      return this.fromArray(from.map(mapper));\n    }\n\n  });\n}\n\nclass Path extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('path', node), attrs);\n  } // Get array\n\n\n  array() {\n    return this._array || (this._array = new PathArray(this.attr('d')));\n  } // Clear array cache\n\n\n  clear() {\n    delete this._array;\n    return this;\n  } // Set height of element\n\n\n  height(height) {\n    return height == null ? this.bbox().height : this.size(this.bbox().width, height);\n  } // Move by left top corner\n\n\n  move(x, y) {\n    return this.attr('d', this.array().move(x, y));\n  } // Plot new path\n\n\n  plot(d) {\n    return d == null ? this.array() : this.clear().attr('d', typeof d === 'string' ? d : this._array = new PathArray(d));\n  } // Set element size to given width and height\n\n\n  size(width, height) {\n    const p = proportionalSize(this, width, height);\n    return this.attr('d', this.array().size(p.width, p.height));\n  } // Set width of element\n\n\n  width(width) {\n    return width == null ? this.bbox().width : this.size(width, this.bbox().height);\n  } // Move by left top corner over x-axis\n\n\n  x(x) {\n    return x == null ? this.bbox().x : this.move(x, this.bbox().y);\n  } // Move by left top corner over y-axis\n\n\n  y(y) {\n    return y == null ? this.bbox().y : this.move(this.bbox().x, y);\n  }\n\n} // Define morphable array\n\nPath.prototype.MorphArray = PathArray; // Add parent method\n\nregisterMethods({\n  Container: {\n    // Create a wrapped path element\n    path: wrapWithAttrCheck(function (d) {\n      // make sure plot is called as a setter\n      return this.put(new Path()).plot(d || new PathArray());\n    })\n  }\n});\nregister(Path, 'Path');\n\nfunction array() {\n  return this._array || (this._array = new PointArray(this.attr('points')));\n} // Clear array cache\n\nfunction clear() {\n  delete this._array;\n  return this;\n} // Move by left top corner\n\nfunction move$2(x, y) {\n  return this.attr('points', this.array().move(x, y));\n} // Plot new path\n\nfunction plot(p) {\n  return p == null ? this.array() : this.clear().attr('points', typeof p === 'string' ? p : this._array = new PointArray(p));\n} // Set element size to given width and height\n\nfunction size$1(width, height) {\n  const p = proportionalSize(this, width, height);\n  return this.attr('points', this.array().size(p.width, p.height));\n}\n\nvar poly = {\n  __proto__: null,\n  array: array,\n  clear: clear,\n  move: move$2,\n  plot: plot,\n  size: size$1\n};\n\nclass Polygon extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('polygon', node), attrs);\n  }\n\n}\nregisterMethods({\n  Container: {\n    // Create a wrapped polygon element\n    polygon: wrapWithAttrCheck(function (p) {\n      // make sure plot is called as a setter\n      return this.put(new Polygon()).plot(p || new PointArray());\n    })\n  }\n});\nextend(Polygon, pointed);\nextend(Polygon, poly);\nregister(Polygon, 'Polygon');\n\nclass Polyline extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('polyline', node), attrs);\n  }\n\n}\nregisterMethods({\n  Container: {\n    // Create a wrapped polygon element\n    polyline: wrapWithAttrCheck(function (p) {\n      // make sure plot is called as a setter\n      return this.put(new Polyline()).plot(p || new PointArray());\n    })\n  }\n});\nextend(Polyline, pointed);\nextend(Polyline, poly);\nregister(Polyline, 'Polyline');\n\nclass Rect extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('rect', node), attrs);\n  }\n\n}\nextend(Rect, {\n  rx,\n  ry\n});\nregisterMethods({\n  Container: {\n    // Create a rect element\n    rect: wrapWithAttrCheck(function (width, height) {\n      return this.put(new Rect()).size(width, height);\n    })\n  }\n});\nregister(Rect, 'Rect');\n\nclass Queue {\n  constructor() {\n    this._first = null;\n    this._last = null;\n  } // Shows us the first item in the list\n\n\n  first() {\n    return this._first && this._first.value;\n  } // Shows us the last item in the list\n\n\n  last() {\n    return this._last && this._last.value;\n  }\n\n  push(value) {\n    // An item stores an id and the provided value\n    const item = typeof value.next !== 'undefined' ? value : {\n      value: value,\n      next: null,\n      prev: null\n    }; // Deal with the queue being empty or populated\n\n    if (this._last) {\n      item.prev = this._last;\n      this._last.next = item;\n      this._last = item;\n    } else {\n      this._last = item;\n      this._first = item;\n    } // Return the current item\n\n\n    return item;\n  } // Removes the item that was returned from the push\n\n\n  remove(item) {\n    // Relink the previous item\n    if (item.prev) item.prev.next = item.next;\n    if (item.next) item.next.prev = item.prev;\n    if (item === this._last) this._last = item.prev;\n    if (item === this._first) this._first = item.next; // Invalidate item\n\n    item.prev = null;\n    item.next = null;\n  }\n\n  shift() {\n    // Check if we have a value\n    const remove = this._first;\n    if (!remove) return null; // If we do, remove it and relink things\n\n    this._first = remove.next;\n    if (this._first) this._first.prev = null;\n    this._last = this._first ? this._last : null;\n    return remove.value;\n  }\n\n}\n\nconst Animator = {\n  nextDraw: null,\n  frames: new Queue(),\n  timeouts: new Queue(),\n  immediates: new Queue(),\n  timer: () => globals.window.performance || globals.window.Date,\n  transforms: [],\n\n  frame(fn) {\n    // Store the node\n    const node = Animator.frames.push({\n      run: fn\n    }); // Request an animation frame if we don't have one\n\n    if (Animator.nextDraw === null) {\n      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);\n    } // Return the node so we can remove it easily\n\n\n    return node;\n  },\n\n  timeout(fn, delay) {\n    delay = delay || 0; // Work out when the event should fire\n\n    const time = Animator.timer().now() + delay; // Add the timeout to the end of the queue\n\n    const node = Animator.timeouts.push({\n      run: fn,\n      time: time\n    }); // Request another animation frame if we need one\n\n    if (Animator.nextDraw === null) {\n      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);\n    }\n\n    return node;\n  },\n\n  immediate(fn) {\n    // Add the immediate fn to the end of the queue\n    const node = Animator.immediates.push(fn); // Request another animation frame if we need one\n\n    if (Animator.nextDraw === null) {\n      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);\n    }\n\n    return node;\n  },\n\n  cancelFrame(node) {\n    node != null && Animator.frames.remove(node);\n  },\n\n  clearTimeout(node) {\n    node != null && Animator.timeouts.remove(node);\n  },\n\n  cancelImmediate(node) {\n    node != null && Animator.immediates.remove(node);\n  },\n\n  _draw(now) {\n    // Run all the timeouts we can run, if they are not ready yet, add them\n    // to the end of the queue immediately! (bad timeouts!!! [sarcasm])\n    let nextTimeout = null;\n    const lastTimeout = Animator.timeouts.last();\n\n    while (nextTimeout = Animator.timeouts.shift()) {\n      // Run the timeout if its time, or push it to the end\n      if (now >= nextTimeout.time) {\n        nextTimeout.run();\n      } else {\n        Animator.timeouts.push(nextTimeout);\n      } // If we hit the last item, we should stop shifting out more items\n\n\n      if (nextTimeout === lastTimeout) break;\n    } // Run all of the animation frames\n\n\n    let nextFrame = null;\n    const lastFrame = Animator.frames.last();\n\n    while (nextFrame !== lastFrame && (nextFrame = Animator.frames.shift())) {\n      nextFrame.run(now);\n    }\n\n    let nextImmediate = null;\n\n    while (nextImmediate = Animator.immediates.shift()) {\n      nextImmediate();\n    } // If we have remaining timeouts or frames, draw until we don't anymore\n\n\n    Animator.nextDraw = Animator.timeouts.first() || Animator.frames.first() ? globals.window.requestAnimationFrame(Animator._draw) : null;\n  }\n\n};\n\nconst makeSchedule = function (runnerInfo) {\n  const start = runnerInfo.start;\n  const duration = runnerInfo.runner.duration();\n  const end = start + duration;\n  return {\n    start: start,\n    duration: duration,\n    end: end,\n    runner: runnerInfo.runner\n  };\n};\n\nconst defaultSource = function () {\n  const w = globals.window;\n  return (w.performance || w.Date).now();\n};\n\nclass Timeline extends EventTarget {\n  // Construct a new timeline on the given element\n  constructor(timeSource = defaultSource) {\n    super();\n    this._timeSource = timeSource; // Store the timing variables\n\n    this._startTime = 0;\n    this._speed = 1.0; // Determines how long a runner is hold in memory. Can be a dt or true/false\n\n    this._persist = 0; // Keep track of the running animations and their starting parameters\n\n    this._nextFrame = null;\n    this._paused = true;\n    this._runners = [];\n    this._runnerIds = [];\n    this._lastRunnerId = -1;\n    this._time = 0;\n    this._lastSourceTime = 0;\n    this._lastStepTime = 0; // Make sure that step is always called in class context\n\n    this._step = this._stepFn.bind(this, false);\n    this._stepImmediate = this._stepFn.bind(this, true);\n  }\n\n  active() {\n    return !!this._nextFrame;\n  }\n\n  finish() {\n    // Go to end and pause\n    this.time(this.getEndTimeOfTimeline() + 1);\n    return this.pause();\n  } // Calculates the end of the timeline\n\n\n  getEndTime() {\n    const lastRunnerInfo = this.getLastRunnerInfo();\n    const lastDuration = lastRunnerInfo ? lastRunnerInfo.runner.duration() : 0;\n    const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time;\n    return lastStartTime + lastDuration;\n  }\n\n  getEndTimeOfTimeline() {\n    const endTimes = this._runners.map(i => i.start + i.runner.duration());\n\n    return Math.max(0, ...endTimes);\n  }\n\n  getLastRunnerInfo() {\n    return this.getRunnerInfoById(this._lastRunnerId);\n  }\n\n  getRunnerInfoById(id) {\n    return this._runners[this._runnerIds.indexOf(id)] || null;\n  }\n\n  pause() {\n    this._paused = true;\n    return this._continue();\n  }\n\n  persist(dtOrForever) {\n    if (dtOrForever == null) return this._persist;\n    this._persist = dtOrForever;\n    return this;\n  }\n\n  play() {\n    // Now make sure we are not paused and continue the animation\n    this._paused = false;\n    return this.updateTime()._continue();\n  }\n\n  reverse(yes) {\n    const currentSpeed = this.speed();\n    if (yes == null) return this.speed(-currentSpeed);\n    const positive = Math.abs(currentSpeed);\n    return this.speed(yes ? -positive : positive);\n  } // schedules a runner on the timeline\n\n\n  schedule(runner, delay, when) {\n    if (runner == null) {\n      return this._runners.map(makeSchedule);\n    } // The start time for the next animation can either be given explicitly,\n    // derived from the current timeline time or it can be relative to the\n    // last start time to chain animations directly\n\n\n    let absoluteStartTime = 0;\n    const endTime = this.getEndTime();\n    delay = delay || 0; // Work out when to start the animation\n\n    if (when == null || when === 'last' || when === 'after') {\n      // Take the last time and increment\n      absoluteStartTime = endTime;\n    } else if (when === 'absolute' || when === 'start') {\n      absoluteStartTime = delay;\n      delay = 0;\n    } else if (when === 'now') {\n      absoluteStartTime = this._time;\n    } else if (when === 'relative') {\n      const runnerInfo = this.getRunnerInfoById(runner.id);\n\n      if (runnerInfo) {\n        absoluteStartTime = runnerInfo.start + delay;\n        delay = 0;\n      }\n    } else if (when === 'with-last') {\n      const lastRunnerInfo = this.getLastRunnerInfo();\n      const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time;\n      absoluteStartTime = lastStartTime;\n    } else {\n      throw new Error('Invalid value for the \"when\" parameter');\n    } // Manage runner\n\n\n    runner.unschedule();\n    runner.timeline(this);\n    const persist = runner.persist();\n    const runnerInfo = {\n      persist: persist === null ? this._persist : persist,\n      start: absoluteStartTime + delay,\n      runner\n    };\n    this._lastRunnerId = runner.id;\n\n    this._runners.push(runnerInfo);\n\n    this._runners.sort((a, b) => a.start - b.start);\n\n    this._runnerIds = this._runners.map(info => info.runner.id);\n\n    this.updateTime()._continue();\n\n    return this;\n  }\n\n  seek(dt) {\n    return this.time(this._time + dt);\n  }\n\n  source(fn) {\n    if (fn == null) return this._timeSource;\n    this._timeSource = fn;\n    return this;\n  }\n\n  speed(speed) {\n    if (speed == null) return this._speed;\n    this._speed = speed;\n    return this;\n  }\n\n  stop() {\n    // Go to start and pause\n    this.time(0);\n    return this.pause();\n  }\n\n  time(time) {\n    if (time == null) return this._time;\n    this._time = time;\n    return this._continue(true);\n  } // Remove the runner from this timeline\n\n\n  unschedule(runner) {\n    const index = this._runnerIds.indexOf(runner.id);\n\n    if (index < 0) return this;\n\n    this._runners.splice(index, 1);\n\n    this._runnerIds.splice(index, 1);\n\n    runner.timeline(null);\n    return this;\n  } // Makes sure, that after pausing the time doesn't jump\n\n\n  updateTime() {\n    if (!this.active()) {\n      this._lastSourceTime = this._timeSource();\n    }\n\n    return this;\n  } // Checks if we are running and continues the animation\n\n\n  _continue(immediateStep = false) {\n    Animator.cancelFrame(this._nextFrame);\n    this._nextFrame = null;\n    if (immediateStep) return this._stepImmediate();\n    if (this._paused) return this;\n    this._nextFrame = Animator.frame(this._step);\n    return this;\n  }\n\n  _stepFn(immediateStep = false) {\n    // Get the time delta from the last time and update the time\n    const time = this._timeSource();\n\n    let dtSource = time - this._lastSourceTime;\n    if (immediateStep) dtSource = 0;\n    const dtTime = this._speed * dtSource + (this._time - this._lastStepTime);\n    this._lastSourceTime = time; // Only update the time if we use the timeSource.\n    // Otherwise use the current time\n\n    if (!immediateStep) {\n      // Update the time\n      this._time += dtTime;\n      this._time = this._time < 0 ? 0 : this._time;\n    }\n\n    this._lastStepTime = this._time;\n    this.fire('time', this._time); // This is for the case that the timeline was seeked so that the time\n    // is now before the startTime of the runner. That is why we need to set\n    // the runner to position 0\n    // FIXME:\n    // However, resetting in insertion order leads to bugs. Considering the case,\n    // where 2 runners change the same attribute but in different times,\n    // resetting both of them will lead to the case where the later defined\n    // runner always wins the reset even if the other runner started earlier\n    // and therefore should win the attribute battle\n    // this can be solved by resetting them backwards\n\n    for (let k = this._runners.length; k--;) {\n      // Get and run the current runner and ignore it if its inactive\n      const runnerInfo = this._runners[k];\n      const runner = runnerInfo.runner; // Make sure that we give the actual difference\n      // between runner start time and now\n\n      const dtToStart = this._time - runnerInfo.start; // Dont run runner if not started yet\n      // and try to reset it\n\n      if (dtToStart <= 0) {\n        runner.reset();\n      }\n    } // Run all of the runners directly\n\n\n    let runnersLeft = false;\n\n    for (let i = 0, len = this._runners.length; i < len; i++) {\n      // Get and run the current runner and ignore it if its inactive\n      const runnerInfo = this._runners[i];\n      const runner = runnerInfo.runner;\n      let dt = dtTime; // Make sure that we give the actual difference\n      // between runner start time and now\n\n      const dtToStart = this._time - runnerInfo.start; // Dont run runner if not started yet\n\n      if (dtToStart <= 0) {\n        runnersLeft = true;\n        continue;\n      } else if (dtToStart < dt) {\n        // Adjust dt to make sure that animation is on point\n        dt = dtToStart;\n      }\n\n      if (!runner.active()) continue; // If this runner is still going, signal that we need another animation\n      // frame, otherwise, remove the completed runner\n\n      const finished = runner.step(dt).done;\n\n      if (!finished) {\n        runnersLeft = true; // continue\n      } else if (runnerInfo.persist !== true) {\n        // runner is finished. And runner might get removed\n        const endTime = runner.duration() - runner.time() + this._time;\n\n        if (endTime + runnerInfo.persist < this._time) {\n          // Delete runner and correct index\n          runner.unschedule();\n          --i;\n          --len;\n        }\n      }\n    } // Basically: we continue when there are runners right from us in time\n    // when -->, and when runners are left from us when <--\n\n\n    if (runnersLeft && !(this._speed < 0 && this._time === 0) || this._runnerIds.length && this._speed < 0 && this._time > 0) {\n      this._continue();\n    } else {\n      this.pause();\n      this.fire('finished');\n    }\n\n    return this;\n  }\n\n}\nregisterMethods({\n  Element: {\n    timeline: function (timeline) {\n      if (timeline == null) {\n        this._timeline = this._timeline || new Timeline();\n        return this._timeline;\n      } else {\n        this._timeline = timeline;\n        return this;\n      }\n    }\n  }\n});\n\nclass Runner extends EventTarget {\n  constructor(options) {\n    super(); // Store a unique id on the runner, so that we can identify it later\n\n    this.id = Runner.id++; // Ensure a default value\n\n    options = options == null ? timeline.duration : options; // Ensure that we get a controller\n\n    options = typeof options === 'function' ? new Controller(options) : options; // Declare all of the variables\n\n    this._element = null;\n    this._timeline = null;\n    this.done = false;\n    this._queue = []; // Work out the stepper and the duration\n\n    this._duration = typeof options === 'number' && options;\n    this._isDeclarative = options instanceof Controller;\n    this._stepper = this._isDeclarative ? options : new Ease(); // We copy the current values from the timeline because they can change\n\n    this._history = {}; // Store the state of the runner\n\n    this.enabled = true;\n    this._time = 0;\n    this._lastTime = 0; // At creation, the runner is in reset state\n\n    this._reseted = true; // Save transforms applied to this runner\n\n    this.transforms = new Matrix();\n    this.transformId = 1; // Looping variables\n\n    this._haveReversed = false;\n    this._reverse = false;\n    this._loopsDone = 0;\n    this._swing = false;\n    this._wait = 0;\n    this._times = 1;\n    this._frameId = null; // Stores how long a runner is stored after being done\n\n    this._persist = this._isDeclarative ? true : null;\n  }\n\n  static sanitise(duration, delay, when) {\n    // Initialise the default parameters\n    let times = 1;\n    let swing = false;\n    let wait = 0;\n    duration = duration || timeline.duration;\n    delay = delay || timeline.delay;\n    when = when || 'last'; // If we have an object, unpack the values\n\n    if (typeof duration === 'object' && !(duration instanceof Stepper)) {\n      delay = duration.delay || delay;\n      when = duration.when || when;\n      swing = duration.swing || swing;\n      times = duration.times || times;\n      wait = duration.wait || wait;\n      duration = duration.duration || timeline.duration;\n    }\n\n    return {\n      duration: duration,\n      delay: delay,\n      swing: swing,\n      times: times,\n      wait: wait,\n      when: when\n    };\n  }\n\n  active(enabled) {\n    if (enabled == null) return this.enabled;\n    this.enabled = enabled;\n    return this;\n  }\n  /*\n  Private Methods\n  ===============\n  Methods that shouldn't be used externally\n  */\n\n\n  addTransform(transform, index) {\n    this.transforms.lmultiplyO(transform);\n    return this;\n  }\n\n  after(fn) {\n    return this.on('finished', fn);\n  }\n\n  animate(duration, delay, when) {\n    const o = Runner.sanitise(duration, delay, when);\n    const runner = new Runner(o.duration);\n    if (this._timeline) runner.timeline(this._timeline);\n    if (this._element) runner.element(this._element);\n    return runner.loop(o).schedule(o.delay, o.when);\n  }\n\n  clearTransform() {\n    this.transforms = new Matrix();\n    return this;\n  } // TODO: Keep track of all transformations so that deletion is faster\n\n\n  clearTransformsFromQueue() {\n    if (!this.done || !this._timeline || !this._timeline._runnerIds.includes(this.id)) {\n      this._queue = this._queue.filter(item => {\n        return !item.isTransform;\n      });\n    }\n  }\n\n  delay(delay) {\n    return this.animate(0, delay);\n  }\n\n  duration() {\n    return this._times * (this._wait + this._duration) - this._wait;\n  }\n\n  during(fn) {\n    return this.queue(null, fn);\n  }\n\n  ease(fn) {\n    this._stepper = new Ease(fn);\n    return this;\n  }\n  /*\n  Runner Definitions\n  ==================\n  These methods help us define the runtime behaviour of the Runner or they\n  help us make new runners from the current runner\n  */\n\n\n  element(element) {\n    if (element == null) return this._element;\n    this._element = element;\n\n    element._prepareRunner();\n\n    return this;\n  }\n\n  finish() {\n    return this.step(Infinity);\n  }\n\n  loop(times, swing, wait) {\n    // Deal with the user passing in an object\n    if (typeof times === 'object') {\n      swing = times.swing;\n      wait = times.wait;\n      times = times.times;\n    } // Sanitise the values and store them\n\n\n    this._times = times || Infinity;\n    this._swing = swing || false;\n    this._wait = wait || 0; // Allow true to be passed\n\n    if (this._times === true) {\n      this._times = Infinity;\n    }\n\n    return this;\n  }\n\n  loops(p) {\n    const loopDuration = this._duration + this._wait;\n\n    if (p == null) {\n      const loopsDone = Math.floor(this._time / loopDuration);\n      const relativeTime = this._time - loopsDone * loopDuration;\n      const position = relativeTime / this._duration;\n      return Math.min(loopsDone + position, this._times);\n    }\n\n    const whole = Math.floor(p);\n    const partial = p % 1;\n    const time = loopDuration * whole + this._duration * partial;\n    return this.time(time);\n  }\n\n  persist(dtOrForever) {\n    if (dtOrForever == null) return this._persist;\n    this._persist = dtOrForever;\n    return this;\n  }\n\n  position(p) {\n    // Get all of the variables we need\n    const x = this._time;\n    const d = this._duration;\n    const w = this._wait;\n    const t = this._times;\n    const s = this._swing;\n    const r = this._reverse;\n    let position;\n\n    if (p == null) {\n      /*\n      This function converts a time to a position in the range [0, 1]\n      The full explanation can be found in this desmos demonstration\n        https://www.desmos.com/calculator/u4fbavgche\n      The logic is slightly simplified here because we can use booleans\n      */\n      // Figure out the value without thinking about the start or end time\n      const f = function (x) {\n        const swinging = s * Math.floor(x % (2 * (w + d)) / (w + d));\n        const backwards = swinging && !r || !swinging && r;\n        const uncliped = Math.pow(-1, backwards) * (x % (w + d)) / d + backwards;\n        const clipped = Math.max(Math.min(uncliped, 1), 0);\n        return clipped;\n      }; // Figure out the value by incorporating the start time\n\n\n      const endTime = t * (w + d) - w;\n      position = x <= 0 ? Math.round(f(1e-5)) : x < endTime ? f(x) : Math.round(f(endTime - 1e-5));\n      return position;\n    } // Work out the loops done and add the position to the loops done\n\n\n    const loopsDone = Math.floor(this.loops());\n    const swingForward = s && loopsDone % 2 === 0;\n    const forwards = swingForward && !r || r && swingForward;\n    position = loopsDone + (forwards ? p : 1 - p);\n    return this.loops(position);\n  }\n\n  progress(p) {\n    if (p == null) {\n      return Math.min(1, this._time / this.duration());\n    }\n\n    return this.time(p * this.duration());\n  }\n  /*\n  Basic Functionality\n  ===================\n  These methods allow us to attach basic functions to the runner directly\n  */\n\n\n  queue(initFn, runFn, retargetFn, isTransform) {\n    this._queue.push({\n      initialiser: initFn || noop,\n      runner: runFn || noop,\n      retarget: retargetFn,\n      isTransform: isTransform,\n      initialised: false,\n      finished: false\n    });\n\n    const timeline = this.timeline();\n    timeline && this.timeline()._continue();\n    return this;\n  }\n\n  reset() {\n    if (this._reseted) return this;\n    this.time(0);\n    this._reseted = true;\n    return this;\n  }\n\n  reverse(reverse) {\n    this._reverse = reverse == null ? !this._reverse : reverse;\n    return this;\n  }\n\n  schedule(timeline, delay, when) {\n    // The user doesn't need to pass a timeline if we already have one\n    if (!(timeline instanceof Timeline)) {\n      when = delay;\n      delay = timeline;\n      timeline = this.timeline();\n    } // If there is no timeline, yell at the user...\n\n\n    if (!timeline) {\n      throw Error('Runner cannot be scheduled without timeline');\n    } // Schedule the runner on the timeline provided\n\n\n    timeline.schedule(this, delay, when);\n    return this;\n  }\n\n  step(dt) {\n    // If we are inactive, this stepper just gets skipped\n    if (!this.enabled) return this; // Update the time and get the new position\n\n    dt = dt == null ? 16 : dt;\n    this._time += dt;\n    const position = this.position(); // Figure out if we need to run the stepper in this frame\n\n    const running = this._lastPosition !== position && this._time >= 0;\n    this._lastPosition = position; // Figure out if we just started\n\n    const duration = this.duration();\n    const justStarted = this._lastTime <= 0 && this._time > 0;\n    const justFinished = this._lastTime < duration && this._time >= duration;\n    this._lastTime = this._time;\n\n    if (justStarted) {\n      this.fire('start', this);\n    } // Work out if the runner is finished set the done flag here so animations\n    // know, that they are running in the last step (this is good for\n    // transformations which can be merged)\n\n\n    const declarative = this._isDeclarative;\n    this.done = !declarative && !justFinished && this._time >= duration; // Runner is running. So its not in reset state anymore\n\n    this._reseted = false;\n    let converged = false; // Call initialise and the run function\n\n    if (running || declarative) {\n      this._initialise(running); // clear the transforms on this runner so they dont get added again and again\n\n\n      this.transforms = new Matrix();\n      converged = this._run(declarative ? dt : position);\n      this.fire('step', this);\n    } // correct the done flag here\n    // declarative animations itself know when they converged\n\n\n    this.done = this.done || converged && declarative;\n\n    if (justFinished) {\n      this.fire('finished', this);\n    }\n\n    return this;\n  }\n  /*\n  Runner animation methods\n  ========================\n  Control how the animation plays\n  */\n\n\n  time(time) {\n    if (time == null) {\n      return this._time;\n    }\n\n    const dt = time - this._time;\n    this.step(dt);\n    return this;\n  }\n\n  timeline(timeline) {\n    // check explicitly for undefined so we can set the timeline to null\n    if (typeof timeline === 'undefined') return this._timeline;\n    this._timeline = timeline;\n    return this;\n  }\n\n  unschedule() {\n    const timeline = this.timeline();\n    timeline && timeline.unschedule(this);\n    return this;\n  } // Run each initialise function in the runner if required\n\n\n  _initialise(running) {\n    // If we aren't running, we shouldn't initialise when not declarative\n    if (!running && !this._isDeclarative) return; // Loop through all of the initialisers\n\n    for (let i = 0, len = this._queue.length; i < len; ++i) {\n      // Get the current initialiser\n      const current = this._queue[i]; // Determine whether we need to initialise\n\n      const needsIt = this._isDeclarative || !current.initialised && running;\n      running = !current.finished; // Call the initialiser if we need to\n\n      if (needsIt && running) {\n        current.initialiser.call(this);\n        current.initialised = true;\n      }\n    }\n  } // Save a morpher to the morpher list so that we can retarget it later\n\n\n  _rememberMorpher(method, morpher) {\n    this._history[method] = {\n      morpher: morpher,\n      caller: this._queue[this._queue.length - 1]\n    }; // We have to resume the timeline in case a controller\n    // is already done without being ever run\n    // This can happen when e.g. this is done:\n    //    anim = el.animate(new SVG.Spring)\n    // and later\n    //    anim.move(...)\n\n    if (this._isDeclarative) {\n      const timeline = this.timeline();\n      timeline && timeline.play();\n    }\n  } // Try to set the target for a morpher if the morpher exists, otherwise\n  // Run each run function for the position or dt given\n\n\n  _run(positionOrDt) {\n    // Run all of the _queue directly\n    let allfinished = true;\n\n    for (let i = 0, len = this._queue.length; i < len; ++i) {\n      // Get the current function to run\n      const current = this._queue[i]; // Run the function if its not finished, we keep track of the finished\n      // flag for the sake of declarative _queue\n\n      const converged = current.runner.call(this, positionOrDt);\n      current.finished = current.finished || converged === true;\n      allfinished = allfinished && current.finished;\n    } // We report when all of the constructors are finished\n\n\n    return allfinished;\n  } // do nothing and return false\n\n\n  _tryRetarget(method, target, extra) {\n    if (this._history[method]) {\n      // if the last method wasn't even initialised, throw it away\n      if (!this._history[method].caller.initialised) {\n        const index = this._queue.indexOf(this._history[method].caller);\n\n        this._queue.splice(index, 1);\n\n        return false;\n      } // for the case of transformations, we use the special retarget function\n      // which has access to the outer scope\n\n\n      if (this._history[method].caller.retarget) {\n        this._history[method].caller.retarget.call(this, target, extra); // for everything else a simple morpher change is sufficient\n\n      } else {\n        this._history[method].morpher.to(target);\n      }\n\n      this._history[method].caller.finished = false;\n      const timeline = this.timeline();\n      timeline && timeline.play();\n      return true;\n    }\n\n    return false;\n  }\n\n}\nRunner.id = 0;\nclass FakeRunner {\n  constructor(transforms = new Matrix(), id = -1, done = true) {\n    this.transforms = transforms;\n    this.id = id;\n    this.done = done;\n  }\n\n  clearTransformsFromQueue() {}\n\n}\nextend([Runner, FakeRunner], {\n  mergeWith(runner) {\n    return new FakeRunner(runner.transforms.lmultiply(this.transforms), runner.id);\n  }\n\n}); // FakeRunner.emptyRunner = new FakeRunner()\n\nconst lmultiply = (last, curr) => last.lmultiplyO(curr);\n\nconst getRunnerTransform = runner => runner.transforms;\n\nfunction mergeTransforms() {\n  // Find the matrix to apply to the element and apply it\n  const runners = this._transformationRunners.runners;\n  const netTransform = runners.map(getRunnerTransform).reduce(lmultiply, new Matrix());\n  this.transform(netTransform);\n\n  this._transformationRunners.merge();\n\n  if (this._transformationRunners.length() === 1) {\n    this._frameId = null;\n  }\n}\n\nclass RunnerArray {\n  constructor() {\n    this.runners = [];\n    this.ids = [];\n  }\n\n  add(runner) {\n    if (this.runners.includes(runner)) return;\n    const id = runner.id + 1;\n    this.runners.push(runner);\n    this.ids.push(id);\n    return this;\n  }\n\n  clearBefore(id) {\n    const deleteCnt = this.ids.indexOf(id + 1) || 1;\n    this.ids.splice(0, deleteCnt, 0);\n    this.runners.splice(0, deleteCnt, new FakeRunner()).forEach(r => r.clearTransformsFromQueue());\n    return this;\n  }\n\n  edit(id, newRunner) {\n    const index = this.ids.indexOf(id + 1);\n    this.ids.splice(index, 1, id + 1);\n    this.runners.splice(index, 1, newRunner);\n    return this;\n  }\n\n  getByID(id) {\n    return this.runners[this.ids.indexOf(id + 1)];\n  }\n\n  length() {\n    return this.ids.length;\n  }\n\n  merge() {\n    let lastRunner = null;\n\n    for (let i = 0; i < this.runners.length; ++i) {\n      const runner = this.runners[i];\n      const condition = lastRunner && runner.done && lastRunner.done // don't merge runner when persisted on timeline\n      && (!runner._timeline || !runner._timeline._runnerIds.includes(runner.id)) && (!lastRunner._timeline || !lastRunner._timeline._runnerIds.includes(lastRunner.id));\n\n      if (condition) {\n        // the +1 happens in the function\n        this.remove(runner.id);\n        const newRunner = runner.mergeWith(lastRunner);\n        this.edit(lastRunner.id, newRunner);\n        lastRunner = newRunner;\n        --i;\n      } else {\n        lastRunner = runner;\n      }\n    }\n\n    return this;\n  }\n\n  remove(id) {\n    const index = this.ids.indexOf(id + 1);\n    this.ids.splice(index, 1);\n    this.runners.splice(index, 1);\n    return this;\n  }\n\n}\nregisterMethods({\n  Element: {\n    animate(duration, delay, when) {\n      const o = Runner.sanitise(duration, delay, when);\n      const timeline = this.timeline();\n      return new Runner(o.duration).loop(o).element(this).timeline(timeline.play()).schedule(o.delay, o.when);\n    },\n\n    delay(by, when) {\n      return this.animate(0, by, when);\n    },\n\n    // this function searches for all runners on the element and deletes the ones\n    // which run before the current one. This is because absolute transformations\n    // overwrite anything anyway so there is no need to waste time computing\n    // other runners\n    _clearTransformRunnersBefore(currentRunner) {\n      this._transformationRunners.clearBefore(currentRunner.id);\n    },\n\n    _currentTransform(current) {\n      return this._transformationRunners.runners // we need the equal sign here to make sure, that also transformations\n      // on the same runner which execute before the current transformation are\n      // taken into account\n      .filter(runner => runner.id <= current.id).map(getRunnerTransform).reduce(lmultiply, new Matrix());\n    },\n\n    _addRunner(runner) {\n      this._transformationRunners.add(runner); // Make sure that the runner merge is executed at the very end of\n      // all Animator functions. That is why we use immediate here to execute\n      // the merge right after all frames are run\n\n\n      Animator.cancelImmediate(this._frameId);\n      this._frameId = Animator.immediate(mergeTransforms.bind(this));\n    },\n\n    _prepareRunner() {\n      if (this._frameId == null) {\n        this._transformationRunners = new RunnerArray().add(new FakeRunner(new Matrix(this)));\n      }\n    }\n\n  }\n}); // Will output the elements from array A that are not in the array B\n\nconst difference = (a, b) => a.filter(x => !b.includes(x));\n\nextend(Runner, {\n  attr(a, v) {\n    return this.styleAttr('attr', a, v);\n  },\n\n  // Add animatable styles\n  css(s, v) {\n    return this.styleAttr('css', s, v);\n  },\n\n  styleAttr(type, nameOrAttrs, val) {\n    if (typeof nameOrAttrs === 'string') {\n      return this.styleAttr(type, {\n        [nameOrAttrs]: val\n      });\n    }\n\n    let attrs = nameOrAttrs;\n    if (this._tryRetarget(type, attrs)) return this;\n    let morpher = new Morphable(this._stepper).to(attrs);\n    let keys = Object.keys(attrs);\n    this.queue(function () {\n      morpher = morpher.from(this.element()[type](keys));\n    }, function (pos) {\n      this.element()[type](morpher.at(pos).valueOf());\n      return morpher.done();\n    }, function (newToAttrs) {\n      // Check if any new keys were added\n      const newKeys = Object.keys(newToAttrs);\n      const differences = difference(newKeys, keys); // If their are new keys, initialize them and add them to morpher\n\n      if (differences.length) {\n        // Get the values\n        const addedFromAttrs = this.element()[type](differences); // Get the already initialized values\n\n        const oldFromAttrs = new ObjectBag(morpher.from()).valueOf(); // Merge old and new\n\n        Object.assign(oldFromAttrs, addedFromAttrs);\n        morpher.from(oldFromAttrs);\n      } // Get the object from the morpher\n\n\n      const oldToAttrs = new ObjectBag(morpher.to()).valueOf(); // Merge in new attributes\n\n      Object.assign(oldToAttrs, newToAttrs); // Change morpher target\n\n      morpher.to(oldToAttrs); // Make sure that we save the work we did so we don't need it to do again\n\n      keys = newKeys;\n      attrs = newToAttrs;\n    });\n\n    this._rememberMorpher(type, morpher);\n\n    return this;\n  },\n\n  zoom(level, point) {\n    if (this._tryRetarget('zoom', level, point)) return this;\n    let morpher = new Morphable(this._stepper).to(new SVGNumber(level));\n    this.queue(function () {\n      morpher = morpher.from(this.element().zoom());\n    }, function (pos) {\n      this.element().zoom(morpher.at(pos), point);\n      return morpher.done();\n    }, function (newLevel, newPoint) {\n      point = newPoint;\n      morpher.to(newLevel);\n    });\n\n    this._rememberMorpher('zoom', morpher);\n\n    return this;\n  },\n\n  /**\n   ** absolute transformations\n   **/\n  //\n  // M v -----|-----(D M v = F v)------|----->  T v\n  //\n  // 1. define the final state (T) and decompose it (once)\n  //    t = [tx, ty, the, lam, sy, sx]\n  // 2. on every frame: pull the current state of all previous transforms\n  //    (M - m can change)\n  //   and then write this as m = [tx0, ty0, the0, lam0, sy0, sx0]\n  // 3. Find the interpolated matrix F(pos) = m + pos * (t - m)\n  //   - Note F(0) = M\n  //   - Note F(1) = T\n  // 4. Now you get the delta matrix as a result: D = F * inv(M)\n  transform(transforms, relative, affine) {\n    // If we have a declarative function, we should retarget it if possible\n    relative = transforms.relative || relative;\n\n    if (this._isDeclarative && !relative && this._tryRetarget('transform', transforms)) {\n      return this;\n    } // Parse the parameters\n\n\n    const isMatrix = Matrix.isMatrixLike(transforms);\n    affine = transforms.affine != null ? transforms.affine : affine != null ? affine : !isMatrix; // Create a morpher and set its type\n\n    const morpher = new Morphable(this._stepper).type(affine ? TransformBag : Matrix);\n    let origin;\n    let element;\n    let current;\n    let currentAngle;\n    let startTransform;\n\n    function setup() {\n      // make sure element and origin is defined\n      element = element || this.element();\n      origin = origin || getOrigin(transforms, element);\n      startTransform = new Matrix(relative ? undefined : element); // add the runner to the element so it can merge transformations\n\n      element._addRunner(this); // Deactivate all transforms that have run so far if we are absolute\n\n\n      if (!relative) {\n        element._clearTransformRunnersBefore(this);\n      }\n    }\n\n    function run(pos) {\n      // clear all other transforms before this in case something is saved\n      // on this runner. We are absolute. We dont need these!\n      if (!relative) this.clearTransform();\n      const {\n        x,\n        y\n      } = new Point(origin).transform(element._currentTransform(this));\n      let target = new Matrix({ ...transforms,\n        origin: [x, y]\n      });\n      let start = this._isDeclarative && current ? current : startTransform;\n\n      if (affine) {\n        target = target.decompose(x, y);\n        start = start.decompose(x, y); // Get the current and target angle as it was set\n\n        const rTarget = target.rotate;\n        const rCurrent = start.rotate; // Figure out the shortest path to rotate directly\n\n        const possibilities = [rTarget - 360, rTarget, rTarget + 360];\n        const distances = possibilities.map(a => Math.abs(a - rCurrent));\n        const shortest = Math.min(...distances);\n        const index = distances.indexOf(shortest);\n        target.rotate = possibilities[index];\n      }\n\n      if (relative) {\n        // we have to be careful here not to overwrite the rotation\n        // with the rotate method of Matrix\n        if (!isMatrix) {\n          target.rotate = transforms.rotate || 0;\n        }\n\n        if (this._isDeclarative && currentAngle) {\n          start.rotate = currentAngle;\n        }\n      }\n\n      morpher.from(start);\n      morpher.to(target);\n      const affineParameters = morpher.at(pos);\n      currentAngle = affineParameters.rotate;\n      current = new Matrix(affineParameters);\n      this.addTransform(current);\n\n      element._addRunner(this);\n\n      return morpher.done();\n    }\n\n    function retarget(newTransforms) {\n      // only get a new origin if it changed since the last call\n      if ((newTransforms.origin || 'center').toString() !== (transforms.origin || 'center').toString()) {\n        origin = getOrigin(newTransforms, element);\n      } // overwrite the old transformations with the new ones\n\n\n      transforms = { ...newTransforms,\n        origin\n      };\n    }\n\n    this.queue(setup, run, retarget, true);\n    this._isDeclarative && this._rememberMorpher('transform', morpher);\n    return this;\n  },\n\n  // Animatable x-axis\n  x(x, relative) {\n    return this._queueNumber('x', x);\n  },\n\n  // Animatable y-axis\n  y(y) {\n    return this._queueNumber('y', y);\n  },\n\n  dx(x = 0) {\n    return this._queueNumberDelta('x', x);\n  },\n\n  dy(y = 0) {\n    return this._queueNumberDelta('y', y);\n  },\n\n  dmove(x, y) {\n    return this.dx(x).dy(y);\n  },\n\n  _queueNumberDelta(method, to) {\n    to = new SVGNumber(to); // Try to change the target if we have this method already registered\n\n    if (this._tryRetarget(method, to)) return this; // Make a morpher and queue the animation\n\n    const morpher = new Morphable(this._stepper).to(to);\n    let from = null;\n    this.queue(function () {\n      from = this.element()[method]();\n      morpher.from(from);\n      morpher.to(from + to);\n    }, function (pos) {\n      this.element()[method](morpher.at(pos));\n      return morpher.done();\n    }, function (newTo) {\n      morpher.to(from + new SVGNumber(newTo));\n    }); // Register the morpher so that if it is changed again, we can retarget it\n\n    this._rememberMorpher(method, morpher);\n\n    return this;\n  },\n\n  _queueObject(method, to) {\n    // Try to change the target if we have this method already registered\n    if (this._tryRetarget(method, to)) return this; // Make a morpher and queue the animation\n\n    const morpher = new Morphable(this._stepper).to(to);\n    this.queue(function () {\n      morpher.from(this.element()[method]());\n    }, function (pos) {\n      this.element()[method](morpher.at(pos));\n      return morpher.done();\n    }); // Register the morpher so that if it is changed again, we can retarget it\n\n    this._rememberMorpher(method, morpher);\n\n    return this;\n  },\n\n  _queueNumber(method, value) {\n    return this._queueObject(method, new SVGNumber(value));\n  },\n\n  // Animatable center x-axis\n  cx(x) {\n    return this._queueNumber('cx', x);\n  },\n\n  // Animatable center y-axis\n  cy(y) {\n    return this._queueNumber('cy', y);\n  },\n\n  // Add animatable move\n  move(x, y) {\n    return this.x(x).y(y);\n  },\n\n  // Add animatable center\n  center(x, y) {\n    return this.cx(x).cy(y);\n  },\n\n  // Add animatable size\n  size(width, height) {\n    // animate bbox based size for all other elements\n    let box;\n\n    if (!width || !height) {\n      box = this._element.bbox();\n    }\n\n    if (!width) {\n      width = box.width / box.height * height;\n    }\n\n    if (!height) {\n      height = box.height / box.width * width;\n    }\n\n    return this.width(width).height(height);\n  },\n\n  // Add animatable width\n  width(width) {\n    return this._queueNumber('width', width);\n  },\n\n  // Add animatable height\n  height(height) {\n    return this._queueNumber('height', height);\n  },\n\n  // Add animatable plot\n  plot(a, b, c, d) {\n    // Lines can be plotted with 4 arguments\n    if (arguments.length === 4) {\n      return this.plot([a, b, c, d]);\n    }\n\n    if (this._tryRetarget('plot', a)) return this;\n    const morpher = new Morphable(this._stepper).type(this._element.MorphArray).to(a);\n    this.queue(function () {\n      morpher.from(this._element.array());\n    }, function (pos) {\n      this._element.plot(morpher.at(pos));\n\n      return morpher.done();\n    });\n\n    this._rememberMorpher('plot', morpher);\n\n    return this;\n  },\n\n  // Add leading method\n  leading(value) {\n    return this._queueNumber('leading', value);\n  },\n\n  // Add animatable viewbox\n  viewbox(x, y, width, height) {\n    return this._queueObject('viewbox', new Box(x, y, width, height));\n  },\n\n  update(o) {\n    if (typeof o !== 'object') {\n      return this.update({\n        offset: arguments[0],\n        color: arguments[1],\n        opacity: arguments[2]\n      });\n    }\n\n    if (o.opacity != null) this.attr('stop-opacity', o.opacity);\n    if (o.color != null) this.attr('stop-color', o.color);\n    if (o.offset != null) this.attr('offset', o.offset);\n    return this;\n  }\n\n});\nextend(Runner, {\n  rx,\n  ry,\n  from,\n  to\n});\nregister(Runner, 'Runner');\n\nclass Svg extends Container {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('svg', node), attrs);\n    this.namespace();\n  } // Creates and returns defs element\n\n\n  defs() {\n    if (!this.isRoot()) return this.root().defs();\n    return adopt(this.node.querySelector('defs')) || this.put(new Defs());\n  }\n\n  isRoot() {\n    return !this.node.parentNode || !(this.node.parentNode instanceof globals.window.SVGElement) && this.node.parentNode.nodeName !== '#document-fragment';\n  } // Add namespaces\n\n\n  namespace() {\n    if (!this.isRoot()) return this.root().namespace();\n    return this.attr({\n      xmlns: svg,\n      version: '1.1'\n    }).attr('xmlns:xlink', xlink, xmlns).attr('xmlns:svgjs', svgjs, xmlns);\n  }\n\n  removeNamespace() {\n    return this.attr({\n      xmlns: null,\n      version: null\n    }).attr('xmlns:xlink', null, xmlns).attr('xmlns:svgjs', null, xmlns);\n  } // Check if this is a root svg\n  // If not, call root() from this element\n\n\n  root() {\n    if (this.isRoot()) return this;\n    return super.root();\n  }\n\n}\nregisterMethods({\n  Container: {\n    // Create nested svg document\n    nested: wrapWithAttrCheck(function () {\n      return this.put(new Svg());\n    })\n  }\n});\nregister(Svg, 'Svg', true);\n\nclass Symbol extends Container {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('symbol', node), attrs);\n  }\n\n}\nregisterMethods({\n  Container: {\n    symbol: wrapWithAttrCheck(function () {\n      return this.put(new Symbol());\n    })\n  }\n});\nregister(Symbol, 'Symbol');\n\nfunction plain(text) {\n  // clear if build mode is disabled\n  if (this._build === false) {\n    this.clear();\n  } // create text node\n\n\n  this.node.appendChild(globals.document.createTextNode(text));\n  return this;\n} // Get length of text element\n\nfunction length() {\n  return this.node.getComputedTextLength();\n} // Move over x-axis\n// Text is moved by its bounding box\n// text-anchor does NOT matter\n\nfunction x$1(x, box = this.bbox()) {\n  if (x == null) {\n    return box.x;\n  }\n\n  return this.attr('x', this.attr('x') + x - box.x);\n} // Move over y-axis\n\nfunction y$1(y, box = this.bbox()) {\n  if (y == null) {\n    return box.y;\n  }\n\n  return this.attr('y', this.attr('y') + y - box.y);\n}\nfunction move$1(x, y, box = this.bbox()) {\n  return this.x(x, box).y(y, box);\n} // Move center over x-axis\n\nfunction cx(x, box = this.bbox()) {\n  if (x == null) {\n    return box.cx;\n  }\n\n  return this.attr('x', this.attr('x') + x - box.cx);\n} // Move center over y-axis\n\nfunction cy(y, box = this.bbox()) {\n  if (y == null) {\n    return box.cy;\n  }\n\n  return this.attr('y', this.attr('y') + y - box.cy);\n}\nfunction center(x, y, box = this.bbox()) {\n  return this.cx(x, box).cy(y, box);\n}\nfunction ax(x) {\n  return this.attr('x', x);\n}\nfunction ay(y) {\n  return this.attr('y', y);\n}\nfunction amove(x, y) {\n  return this.ax(x).ay(y);\n} // Enable / disable build mode\n\nfunction build(build) {\n  this._build = !!build;\n  return this;\n}\n\nvar textable = {\n  __proto__: null,\n  plain: plain,\n  length: length,\n  x: x$1,\n  y: y$1,\n  move: move$1,\n  cx: cx,\n  cy: cy,\n  center: center,\n  ax: ax,\n  ay: ay,\n  amove: amove,\n  build: build\n};\n\nclass Text extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('text', node), attrs);\n    this.dom.leading = new SVGNumber(1.3); // store leading value for rebuilding\n\n    this._rebuild = true; // enable automatic updating of dy values\n\n    this._build = false; // disable build mode for adding multiple lines\n  } // Set / get leading\n\n\n  leading(value) {\n    // act as getter\n    if (value == null) {\n      return this.dom.leading;\n    } // act as setter\n\n\n    this.dom.leading = new SVGNumber(value);\n    return this.rebuild();\n  } // Rebuild appearance type\n\n\n  rebuild(rebuild) {\n    // store new rebuild flag if given\n    if (typeof rebuild === 'boolean') {\n      this._rebuild = rebuild;\n    } // define position of all lines\n\n\n    if (this._rebuild) {\n      const self = this;\n      let blankLineOffset = 0;\n      const leading = this.dom.leading;\n      this.each(function (i) {\n        const fontSize = globals.window.getComputedStyle(this.node).getPropertyValue('font-size');\n        const dy = leading * new SVGNumber(fontSize);\n\n        if (this.dom.newLined) {\n          this.attr('x', self.attr('x'));\n\n          if (this.text() === '\\n') {\n            blankLineOffset += dy;\n          } else {\n            this.attr('dy', i ? dy + blankLineOffset : 0);\n            blankLineOffset = 0;\n          }\n        }\n      });\n      this.fire('rebuild');\n    }\n\n    return this;\n  } // overwrite method from parent to set data properly\n\n\n  setData(o) {\n    this.dom = o;\n    this.dom.leading = new SVGNumber(o.leading || 1.3);\n    return this;\n  } // Set the text content\n\n\n  text(text) {\n    // act as getter\n    if (text === undefined) {\n      const children = this.node.childNodes;\n      let firstLine = 0;\n      text = '';\n\n      for (let i = 0, len = children.length; i < len; ++i) {\n        // skip textPaths - they are no lines\n        if (children[i].nodeName === 'textPath') {\n          if (i === 0) firstLine = 1;\n          continue;\n        } // add newline if its not the first child and newLined is set to true\n\n\n        if (i !== firstLine && children[i].nodeType !== 3 && adopt(children[i]).dom.newLined === true) {\n          text += '\\n';\n        } // add content of this node\n\n\n        text += children[i].textContent;\n      }\n\n      return text;\n    } // remove existing content\n\n\n    this.clear().build(true);\n\n    if (typeof text === 'function') {\n      // call block\n      text.call(this, this);\n    } else {\n      // store text and make sure text is not blank\n      text = (text + '').split('\\n'); // build new lines\n\n      for (let j = 0, jl = text.length; j < jl; j++) {\n        this.newLine(text[j]);\n      }\n    } // disable build mode and rebuild lines\n\n\n    return this.build(false).rebuild();\n  }\n\n}\nextend(Text, textable);\nregisterMethods({\n  Container: {\n    // Create text element\n    text: wrapWithAttrCheck(function (text = '') {\n      return this.put(new Text()).text(text);\n    }),\n    // Create plain text element\n    plain: wrapWithAttrCheck(function (text = '') {\n      return this.put(new Text()).plain(text);\n    })\n  }\n});\nregister(Text, 'Text');\n\nclass Tspan extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('tspan', node), attrs);\n    this._build = false; // disable build mode for adding multiple lines\n  } // Shortcut dx\n\n\n  dx(dx) {\n    return this.attr('dx', dx);\n  } // Shortcut dy\n\n\n  dy(dy) {\n    return this.attr('dy', dy);\n  } // Create new line\n\n\n  newLine() {\n    // mark new line\n    this.dom.newLined = true; // fetch parent\n\n    const text = this.parent(); // early return in case we are not in a text element\n\n    if (!(text instanceof Text)) {\n      return this;\n    }\n\n    const i = text.index(this);\n    const fontSize = globals.window.getComputedStyle(this.node).getPropertyValue('font-size');\n    const dy = text.dom.leading * new SVGNumber(fontSize); // apply new position\n\n    return this.dy(i ? dy : 0).attr('x', text.x());\n  } // Set text content\n\n\n  text(text) {\n    if (text == null) return this.node.textContent + (this.dom.newLined ? '\\n' : '');\n\n    if (typeof text === 'function') {\n      this.clear().build(true);\n      text.call(this, this);\n      this.build(false);\n    } else {\n      this.plain(text);\n    }\n\n    return this;\n  }\n\n}\nextend(Tspan, textable);\nregisterMethods({\n  Tspan: {\n    tspan: wrapWithAttrCheck(function (text = '') {\n      const tspan = new Tspan(); // clear if build mode is disabled\n\n      if (!this._build) {\n        this.clear();\n      } // add new tspan\n\n\n      return this.put(tspan).text(text);\n    })\n  },\n  Text: {\n    newLine: function (text = '') {\n      return this.tspan(text).newLine();\n    }\n  }\n});\nregister(Tspan, 'Tspan');\n\nclass Circle extends Shape {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('circle', node), attrs);\n  }\n\n  radius(r) {\n    return this.attr('r', r);\n  } // Radius x value\n\n\n  rx(rx) {\n    return this.attr('r', rx);\n  } // Alias radius x value\n\n\n  ry(ry) {\n    return this.rx(ry);\n  }\n\n  size(size) {\n    return this.radius(new SVGNumber(size).divide(2));\n  }\n\n}\nextend(Circle, {\n  x: x$3,\n  y: y$3,\n  cx: cx$1,\n  cy: cy$1,\n  width: width$2,\n  height: height$2\n});\nregisterMethods({\n  Container: {\n    // Create circle element\n    circle: wrapWithAttrCheck(function (size = 0) {\n      return this.put(new Circle()).size(size).move(0, 0);\n    })\n  }\n});\nregister(Circle, 'Circle');\n\nclass ClipPath extends Container {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('clipPath', node), attrs);\n  } // Unclip all clipped elements and remove itself\n\n\n  remove() {\n    // unclip all targets\n    this.targets().forEach(function (el) {\n      el.unclip();\n    }); // remove clipPath from parent\n\n    return super.remove();\n  }\n\n  targets() {\n    return baseFind('svg [clip-path*=' + this.id() + ']');\n  }\n\n}\nregisterMethods({\n  Container: {\n    // Create clipping element\n    clip: wrapWithAttrCheck(function () {\n      return this.defs().put(new ClipPath());\n    })\n  },\n  Element: {\n    // Distribute clipPath to svg element\n    clipper() {\n      return this.reference('clip-path');\n    },\n\n    clipWith(element) {\n      // use given clip or create a new one\n      const clipper = element instanceof ClipPath ? element : this.parent().clip().add(element); // apply mask\n\n      return this.attr('clip-path', 'url(#' + clipper.id() + ')');\n    },\n\n    // Unclip element\n    unclip() {\n      return this.attr('clip-path', null);\n    }\n\n  }\n});\nregister(ClipPath, 'ClipPath');\n\nclass ForeignObject extends Element {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('foreignObject', node), attrs);\n  }\n\n}\nregisterMethods({\n  Container: {\n    foreignObject: wrapWithAttrCheck(function (width, height) {\n      return this.put(new ForeignObject()).size(width, height);\n    })\n  }\n});\nregister(ForeignObject, 'ForeignObject');\n\nfunction dmove(dx, dy) {\n  this.children().forEach((child, i) => {\n    let bbox; // We have to wrap this for elements that dont have a bbox\n    // e.g. title and other descriptive elements\n\n    try {\n      // Get the childs bbox\n      bbox = child.bbox();\n    } catch (e) {\n      return;\n    } // Get childs matrix\n\n\n    const m = new Matrix(child); // Translate childs matrix by amount and\n    // transform it back into parents space\n\n    const matrix = m.translate(dx, dy).transform(m.inverse()); // Calculate new x and y from old box\n\n    const p = new Point(bbox.x, bbox.y).transform(matrix); // Move element\n\n    child.move(p.x, p.y);\n  });\n  return this;\n}\nfunction dx(dx) {\n  return this.dmove(dx, 0);\n}\nfunction dy(dy) {\n  return this.dmove(0, dy);\n}\nfunction height(height, box = this.bbox()) {\n  if (height == null) return box.height;\n  return this.size(box.width, height, box);\n}\nfunction move(x = 0, y = 0, box = this.bbox()) {\n  const dx = x - box.x;\n  const dy = y - box.y;\n  return this.dmove(dx, dy);\n}\nfunction size(width, height, box = this.bbox()) {\n  const p = proportionalSize(this, width, height, box);\n  const scaleX = p.width / box.width;\n  const scaleY = p.height / box.height;\n  this.children().forEach((child, i) => {\n    const o = new Point(box).transform(new Matrix(child).inverse());\n    child.scale(scaleX, scaleY, o.x, o.y);\n  });\n  return this;\n}\nfunction width(width, box = this.bbox()) {\n  if (width == null) return box.width;\n  return this.size(width, box.height, box);\n}\nfunction x(x, box = this.bbox()) {\n  if (x == null) return box.x;\n  return this.move(x, box.y, box);\n}\nfunction y(y, box = this.bbox()) {\n  if (y == null) return box.y;\n  return this.move(box.x, y, box);\n}\n\nvar containerGeometry = {\n  __proto__: null,\n  dmove: dmove,\n  dx: dx,\n  dy: dy,\n  height: height,\n  move: move,\n  size: size,\n  width: width,\n  x: x,\n  y: y\n};\n\nclass G extends Container {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('g', node), attrs);\n  }\n\n}\nextend(G, containerGeometry);\nregisterMethods({\n  Container: {\n    // Create a group element\n    group: wrapWithAttrCheck(function () {\n      return this.put(new G());\n    })\n  }\n});\nregister(G, 'G');\n\nclass A extends Container {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('a', node), attrs);\n  } // Link target attribute\n\n\n  target(target) {\n    return this.attr('target', target);\n  } // Link url\n\n\n  to(url) {\n    return this.attr('href', url, xlink);\n  }\n\n}\nextend(A, containerGeometry);\nregisterMethods({\n  Container: {\n    // Create a hyperlink element\n    link: wrapWithAttrCheck(function (url) {\n      return this.put(new A()).to(url);\n    })\n  },\n  Element: {\n    unlink() {\n      const link = this.linker();\n      if (!link) return this;\n      const parent = link.parent();\n\n      if (!parent) {\n        return this.remove();\n      }\n\n      const index = parent.index(link);\n      parent.add(this, index);\n      link.remove();\n      return this;\n    },\n\n    linkTo(url) {\n      // reuse old link if possible\n      let link = this.linker();\n\n      if (!link) {\n        link = new A();\n        this.wrap(link);\n      }\n\n      if (typeof url === 'function') {\n        url.call(link, link);\n      } else {\n        link.to(url);\n      }\n\n      return this;\n    },\n\n    linker() {\n      const link = this.parent();\n\n      if (link && link.node.nodeName.toLowerCase() === 'a') {\n        return link;\n      }\n\n      return null;\n    }\n\n  }\n});\nregister(A, 'A');\n\nclass Mask extends Container {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('mask', node), attrs);\n  } // Unmask all masked elements and remove itself\n\n\n  remove() {\n    // unmask all targets\n    this.targets().forEach(function (el) {\n      el.unmask();\n    }); // remove mask from parent\n\n    return super.remove();\n  }\n\n  targets() {\n    return baseFind('svg [mask*=' + this.id() + ']');\n  }\n\n}\nregisterMethods({\n  Container: {\n    mask: wrapWithAttrCheck(function () {\n      return this.defs().put(new Mask());\n    })\n  },\n  Element: {\n    // Distribute mask to svg element\n    masker() {\n      return this.reference('mask');\n    },\n\n    maskWith(element) {\n      // use given mask or create a new one\n      const masker = element instanceof Mask ? element : this.parent().mask().add(element); // apply mask\n\n      return this.attr('mask', 'url(#' + masker.id() + ')');\n    },\n\n    // Unmask element\n    unmask() {\n      return this.attr('mask', null);\n    }\n\n  }\n});\nregister(Mask, 'Mask');\n\nclass Stop extends Element {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('stop', node), attrs);\n  } // add color stops\n\n\n  update(o) {\n    if (typeof o === 'number' || o instanceof SVGNumber) {\n      o = {\n        offset: arguments[0],\n        color: arguments[1],\n        opacity: arguments[2]\n      };\n    } // set attributes\n\n\n    if (o.opacity != null) this.attr('stop-opacity', o.opacity);\n    if (o.color != null) this.attr('stop-color', o.color);\n    if (o.offset != null) this.attr('offset', new SVGNumber(o.offset));\n    return this;\n  }\n\n}\nregisterMethods({\n  Gradient: {\n    // Add a color stop\n    stop: function (offset, color, opacity) {\n      return this.put(new Stop()).update(offset, color, opacity);\n    }\n  }\n});\nregister(Stop, 'Stop');\n\nfunction cssRule(selector, rule) {\n  if (!selector) return '';\n  if (!rule) return selector;\n  let ret = selector + '{';\n\n  for (const i in rule) {\n    ret += unCamelCase(i) + ':' + rule[i] + ';';\n  }\n\n  ret += '}';\n  return ret;\n}\n\nclass Style extends Element {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('style', node), attrs);\n  }\n\n  addText(w = '') {\n    this.node.textContent += w;\n    return this;\n  }\n\n  font(name, src, params = {}) {\n    return this.rule('@font-face', {\n      fontFamily: name,\n      src: src,\n      ...params\n    });\n  }\n\n  rule(selector, obj) {\n    return this.addText(cssRule(selector, obj));\n  }\n\n}\nregisterMethods('Dom', {\n  style(selector, obj) {\n    return this.put(new Style()).rule(selector, obj);\n  },\n\n  fontface(name, src, params) {\n    return this.put(new Style()).font(name, src, params);\n  }\n\n});\nregister(Style, 'Style');\n\nclass TextPath extends Text {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('textPath', node), attrs);\n  } // return the array of the path track element\n\n\n  array() {\n    const track = this.track();\n    return track ? track.array() : null;\n  } // Plot path if any\n\n\n  plot(d) {\n    const track = this.track();\n    let pathArray = null;\n\n    if (track) {\n      pathArray = track.plot(d);\n    }\n\n    return d == null ? pathArray : this;\n  } // Get the path element\n\n\n  track() {\n    return this.reference('href');\n  }\n\n}\nregisterMethods({\n  Container: {\n    textPath: wrapWithAttrCheck(function (text, path) {\n      // Convert text to instance if needed\n      if (!(text instanceof Text)) {\n        text = this.text(text);\n      }\n\n      return text.path(path);\n    })\n  },\n  Text: {\n    // Create path for text to run on\n    path: wrapWithAttrCheck(function (track, importNodes = true) {\n      const textPath = new TextPath(); // if track is a path, reuse it\n\n      if (!(track instanceof Path)) {\n        // create path element\n        track = this.defs().path(track);\n      } // link textPath to path and add content\n\n\n      textPath.attr('href', '#' + track, xlink); // Transplant all nodes from text to textPath\n\n      let node;\n\n      if (importNodes) {\n        while (node = this.node.firstChild) {\n          textPath.node.appendChild(node);\n        }\n      } // add textPath element as child node and return textPath\n\n\n      return this.put(textPath);\n    }),\n\n    // Get the textPath children\n    textPath() {\n      return this.findOne('textPath');\n    }\n\n  },\n  Path: {\n    // creates a textPath from this path\n    text: wrapWithAttrCheck(function (text) {\n      // Convert text to instance if needed\n      if (!(text instanceof Text)) {\n        text = new Text().addTo(this.parent()).text(text);\n      } // Create textPath from text and path and return\n\n\n      return text.path(this);\n    }),\n\n    targets() {\n      return baseFind('svg textPath').filter(node => {\n        return (node.attr('href') || '').includes(this.id());\n      }); // Does not work in IE11. Use when IE support is dropped\n      // return baseFind('svg textPath[*|href*=' + this.id() + ']')\n    }\n\n  }\n});\nTextPath.prototype.MorphArray = PathArray;\nregister(TextPath, 'TextPath');\n\nclass Use extends Shape {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('use', node), attrs);\n  } // Use element as a reference\n\n\n  use(element, file) {\n    // Set lined element\n    return this.attr('href', (file || '') + '#' + element, xlink);\n  }\n\n}\nregisterMethods({\n  Container: {\n    // Create a use element\n    use: wrapWithAttrCheck(function (element, file) {\n      return this.put(new Use()).use(element, file);\n    })\n  }\n});\nregister(Use, 'Use');\n\n/* Optional Modules */\nconst SVG = makeInstance;\nextend([Svg, Symbol, Image, Pattern, Marker], getMethodsFor('viewbox'));\nextend([Line, Polyline, Polygon, Path], getMethodsFor('marker'));\nextend(Text, getMethodsFor('Text'));\nextend(Path, getMethodsFor('Path'));\nextend(Defs, getMethodsFor('Defs'));\nextend([Text, Tspan], getMethodsFor('Tspan'));\nextend([Rect, Ellipse, Gradient, Runner], getMethodsFor('radius'));\nextend(EventTarget, getMethodsFor('EventTarget'));\nextend(Dom, getMethodsFor('Dom'));\nextend(Element, getMethodsFor('Element'));\nextend(Shape, getMethodsFor('Shape'));\nextend([Container, Fragment], getMethodsFor('Container'));\nextend(Gradient, getMethodsFor('Gradient'));\nextend(Runner, getMethodsFor('Runner'));\nList.extend(getMethodNames());\nregisterMorphableType([SVGNumber, Color, Box, Matrix, SVGArray, PointArray, PathArray, Point]);\nmakeMorphable();\n\n\n//# sourceMappingURL=svg.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L3N2Zy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsUUFBUTtBQUN0QjtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQzs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQSwyRUFBMkU7O0FBRTNFO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sa0JBQWtCOztBQUV4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLHlCQUF5QixpQkFBaUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKLHNEQUFzRDs7QUFFdEQ7QUFDQSw0QkFBNEI7QUFDNUIsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUYsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLDRFQUE0RTs7QUFFNUUseUJBQXlCLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxNQUFNOztBQUV6RCx3Q0FBd0M7O0FBRXhDLDRDQUE0Qzs7QUFFNUMsaUNBQWlDOztBQUVqQywwQkFBMEI7O0FBRTFCLDBCQUEwQixFQUFFLGFBQWEsRUFBRSxLQUFLOztBQUVoRCx3QkFBd0I7O0FBRXhCLDRCQUE0Qjs7QUFFNUIsNERBQTREOztBQUU1RCx5REFBeUQ7O0FBRXpELDRCQUE0Qjs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSix1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixJQUFJO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxRQUFROztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0RBQXNEOztBQUV0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0IsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0Esb0tBQW9LOztBQUVwSztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sR0FBRztBQUNWLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUixNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sY0FBYzs7QUFFcEI7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sY0FBYzs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSx3REFBd0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFOztBQUV6RTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxRQUFROztBQUVoQjtBQUNBO0FBQ0EsMERBQTBEOztBQUUxRDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDekI7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEIsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQSw2RUFBNkU7O0FBRTdFO0FBQ0E7QUFDQSxvRUFBb0U7O0FBRXBFO0FBQ0E7QUFDQSwyRUFBMkU7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxRQUFROztBQUVkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBLGlFQUFpRTs7QUFFakU7QUFDQSx1RUFBdUU7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0pBQW9KO0FBQ3BKLElBQUk7OztBQUdKO0FBQ0EsdURBQXVEOztBQUV2RCx5WkFBeVo7O0FBRXpaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0Q0FBNEM7O0FBRWxELDZNQUE2TTs7QUFFN007QUFDQSwrREFBK0Q7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxrREFBa0QsaUJBQWlCLHFCQUFxQixhQUFhO0FBQ3JHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxpQkFBaUI7QUFDakU7O0FBRUE7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0NBQWtDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QyxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0EscUNBQXFDOztBQUVyQyxnREFBZ0Q7O0FBRWhEO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQ7O0FBRXJEO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVCxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLLFFBQVE7O0FBRWI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsUUFBUTtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0EsdUJBQXVCOztBQUV2Qiw4Q0FBOEM7O0FBRTlDO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EscURBQXFEOztBQUVyRDtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQSx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTs7QUFFQSx3Q0FBd0M7OztBQUd4QztBQUNBLDJCQUEyQjtBQUMzQixZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFROzs7QUFHUjtBQUNBLE1BQU07QUFDTjs7O0FBR0Esb0RBQW9EOztBQUVwRDtBQUNBLGdFQUFnRTs7QUFFaEUsOEJBQThCOztBQUU5Qix5Q0FBeUMsTUFBTTtBQUMvQztBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCLG1CQUFtQjs7QUFFbkI7O0FBRUE7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNFQUFzRTtBQUN0RTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDLElBQUk7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJOzs7QUFHSjtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQSw2Q0FBNkM7O0FBRTdDLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3Qiw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0Esc0JBQXNCOztBQUV0QixzQ0FBc0MsUUFBUTtBQUM5QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixJQUFJO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLHNDQUFzQzs7QUFFdEM7QUFDQSw4RUFBOEU7O0FBRTlFLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBLHVDQUF1QyxzQ0FBc0M7QUFDN0U7QUFDQTtBQUNBLFFBQVE7QUFDUix1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUNBQWlDLFFBQVE7QUFDekM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0Esb0RBQW9EOztBQUVwRCw4QkFBOEIsUUFBUTtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7OztBQUdBLDBEQUEwRDs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixxQ0FBcUMsU0FBUzs7QUFFM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUYsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBLEdBQUc7O0FBRUg7QUFDQSx3QkFBd0I7O0FBRXhCLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBLHVCQUF1Qjs7QUFFdkIsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsSUFBSTtBQUMzQztBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBLHVEQUF1RDtBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjs7QUFFQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUEsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0Qzs7QUFFQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QixRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsYUFBYTs7QUFFYiwyQkFBMkI7O0FBRTNCLDZEQUE2RDs7QUFFN0QsaUZBQWlGOztBQUVqRjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEIsMEJBQTBCOztBQUUxQjtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7OztBQUdBO0FBQ0EseUVBQXlFOztBQUV6RTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQSxpQ0FBaUM7OztBQUdqQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLGtEQUFrRDs7QUFFbEQsOENBQThDLFNBQVM7QUFDdkQ7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQSx5RUFBeUU7O0FBRXpFLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxHQUFHOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMsR0FBRzs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBLGtFQUFrRTs7QUFFbEUsc0VBQXNFOztBQUV0RTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1IsZ0VBQWdFOztBQUVoRSw2Q0FBNkM7O0FBRTdDLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBLGtHQUFrRzs7QUFFbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FOztBQUVuRSxnQ0FBZ0M7OztBQUdoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixnQ0FBZ0M7QUFDaEM7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUixxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsNEJBQTRCOztBQUU1QixvREFBb0Q7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSyxHQUFHOztBQUVSOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUjs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQywwQkFBMEI7O0FBRTFCLHlCQUF5QjtBQUN6QixJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTs7QUFFQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHNDQUFzQzs7QUFFdEMsd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUIsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsaUdBQWlHOztBQUVqRztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07OztBQUdOLGlDQUFpQztBQUNqQzs7QUFFQSwrREFBK0Q7O0FBRS9ELDJEQUEyRDs7QUFFM0Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSw0RkFBNEY7O0FBRTVGO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1IsaURBQWlEOztBQUVqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU8sR0FBRztBQUNWO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW8wQjtBQUNwMEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9zdmcuZXNtLmpzPzVkOWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4qIEBzdmdkb3Rqcy9zdmcuanMgLSBBIGxpZ2h0d2VpZ2h0IGxpYnJhcnkgZm9yIG1hbmlwdWxhdGluZyBhbmQgYW5pbWF0aW5nIFNWRy5cbiogQHZlcnNpb24gMy4yLjBcbiogaHR0cHM6Ly9zdmdqcy5kZXYvXG4qXG4qIEBjb3B5cmlnaHQgV291dCBGaWVyZW5zIDx3b3V0QG1pY2std291dC5jb20+XG4qIEBsaWNlbnNlIE1JVFxuKlxuKiBCVUlMVDogTW9uIEp1biAxMiAyMDIzIDEwOjM0OjUxIEdNVCswMjAwIChDZW50cmFsIEV1cm9wZWFuIFN1bW1lciBUaW1lKVxuKi87XG5jb25zdCBtZXRob2RzJDEgPSB7fTtcbmNvbnN0IG5hbWVzID0gW107XG5mdW5jdGlvbiByZWdpc3Rlck1ldGhvZHMobmFtZSwgbSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgIGZvciAoY29uc3QgX25hbWUgb2YgbmFtZSkge1xuICAgICAgcmVnaXN0ZXJNZXRob2RzKF9uYW1lLCBtKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yIChjb25zdCBfbmFtZSBpbiBuYW1lKSB7XG4gICAgICByZWdpc3Rlck1ldGhvZHMoX25hbWUsIG5hbWVbX25hbWVdKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBhZGRNZXRob2ROYW1lcyhPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtKSk7XG4gIG1ldGhvZHMkMVtuYW1lXSA9IE9iamVjdC5hc3NpZ24obWV0aG9kcyQxW25hbWVdIHx8IHt9LCBtKTtcbn1cbmZ1bmN0aW9uIGdldE1ldGhvZHNGb3IobmFtZSkge1xuICByZXR1cm4gbWV0aG9kcyQxW25hbWVdIHx8IHt9O1xufVxuZnVuY3Rpb24gZ2V0TWV0aG9kTmFtZXMoKSB7XG4gIHJldHVybiBbLi4ubmV3IFNldChuYW1lcyldO1xufVxuZnVuY3Rpb24gYWRkTWV0aG9kTmFtZXMoX25hbWVzKSB7XG4gIG5hbWVzLnB1c2goLi4uX25hbWVzKTtcbn1cblxuLy8gTWFwIGZ1bmN0aW9uXG5mdW5jdGlvbiBtYXAoYXJyYXksIGJsb2NrKSB7XG4gIGxldCBpO1xuICBjb25zdCBpbCA9IGFycmF5Lmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IGlsOyBpKyspIHtcbiAgICByZXN1bHQucHVzaChibG9jayhhcnJheVtpXSkpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0gLy8gRmlsdGVyIGZ1bmN0aW9uXG5cbmZ1bmN0aW9uIGZpbHRlcihhcnJheSwgYmxvY2spIHtcbiAgbGV0IGk7XG4gIGNvbnN0IGlsID0gYXJyYXkubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgaWw7IGkrKykge1xuICAgIGlmIChibG9jayhhcnJheVtpXSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSAvLyBEZWdyZWVzIHRvIHJhZGlhbnNcblxuZnVuY3Rpb24gcmFkaWFucyhkKSB7XG4gIHJldHVybiBkICUgMzYwICogTWF0aC5QSSAvIDE4MDtcbn0gLy8gUmFkaWFucyB0byBkZWdyZWVzXG5cbmZ1bmN0aW9uIGRlZ3JlZXMocikge1xuICByZXR1cm4gciAqIDE4MCAvIE1hdGguUEkgJSAzNjA7XG59IC8vIENvbnZlcnQgZGFzaC1zZXBhcmF0ZWQtc3RyaW5nIHRvIGNhbWVsQ2FzZVxuXG5mdW5jdGlvbiBjYW1lbENhc2Uocykge1xuICByZXR1cm4gcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0oLikvZywgZnVuY3Rpb24gKG0sIGcpIHtcbiAgICByZXR1cm4gZy50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn0gLy8gQ29udmVydCBjYW1lbCBjYXNlZCBzdHJpbmcgdG8gZGFzaCBzZXBhcmF0ZWRcblxuZnVuY3Rpb24gdW5DYW1lbENhc2Uocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC8oW0EtWl0pL2csIGZ1bmN0aW9uIChtLCBnKSB7XG4gICAgcmV0dXJuICctJyArIGcudG9Mb3dlckNhc2UoKTtcbiAgfSk7XG59IC8vIENhcGl0YWxpemUgZmlyc3QgbGV0dGVyIG9mIGEgc3RyaW5nXG5cbmZ1bmN0aW9uIGNhcGl0YWxpemUocykge1xuICByZXR1cm4gcy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSk7XG59IC8vIENhbGN1bGF0ZSBwcm9wb3J0aW9uYWwgd2lkdGggYW5kIGhlaWdodCB2YWx1ZXMgd2hlbiBuZWNlc3NhcnlcblxuZnVuY3Rpb24gcHJvcG9ydGlvbmFsU2l6ZShlbGVtZW50LCB3aWR0aCwgaGVpZ2h0LCBib3gpIHtcbiAgaWYgKHdpZHRoID09IG51bGwgfHwgaGVpZ2h0ID09IG51bGwpIHtcbiAgICBib3ggPSBib3ggfHwgZWxlbWVudC5iYm94KCk7XG5cbiAgICBpZiAod2lkdGggPT0gbnVsbCkge1xuICAgICAgd2lkdGggPSBib3gud2lkdGggLyBib3guaGVpZ2h0ICogaGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAoaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgIGhlaWdodCA9IGJveC5oZWlnaHQgLyBib3gud2lkdGggKiB3aWR0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFkZHMgc3VwcG9ydCBmb3Igc3RyaW5nIG9yaWdpbnMuXG4gKiBJdCBzZWFyY2hlcyBmb3IgYW4gb3JpZ2luIGluIG8ub3JpZ2luIG8ub3ggYW5kIG8ub3JpZ2luWC5cbiAqIFRoaXMgd2F5LCBvcmlnaW46IHt4OiAnY2VudGVyJywgeTogNTB9IGNhbiBiZSBwYXNzZWQgYXMgd2VsbCBhcyBveDogJ2NlbnRlcicsIG95OiA1MFxuKiovXG5cbmZ1bmN0aW9uIGdldE9yaWdpbihvLCBlbGVtZW50KSB7XG4gIGNvbnN0IG9yaWdpbiA9IG8ub3JpZ2luOyAvLyBGaXJzdCBjaGVjayBpZiBvcmlnaW4gaXMgaW4gb3ggb3Igb3JpZ2luWFxuXG4gIGxldCBveCA9IG8ub3ggIT0gbnVsbCA/IG8ub3ggOiBvLm9yaWdpblggIT0gbnVsbCA/IG8ub3JpZ2luWCA6ICdjZW50ZXInO1xuICBsZXQgb3kgPSBvLm95ICE9IG51bGwgPyBvLm95IDogby5vcmlnaW5ZICE9IG51bGwgPyBvLm9yaWdpblkgOiAnY2VudGVyJzsgLy8gVGhlbiBjaGVjayBpZiBvcmlnaW4gd2FzIHVzZWQgYW5kIG92ZXJ3cml0ZSBpbiB0aGF0IGNhc2VcblxuICBpZiAob3JpZ2luICE9IG51bGwpIHtcbiAgICBbb3gsIG95XSA9IEFycmF5LmlzQXJyYXkob3JpZ2luKSA/IG9yaWdpbiA6IHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnID8gW29yaWdpbi54LCBvcmlnaW4ueV0gOiBbb3JpZ2luLCBvcmlnaW5dO1xuICB9IC8vIE1ha2Ugc3VyZSB0byBvbmx5IGNhbGwgYmJveCB3aGVuIGFjdHVhbGx5IG5lZWRlZFxuXG5cbiAgY29uc3QgY29uZFggPSB0eXBlb2Ygb3ggPT09ICdzdHJpbmcnO1xuICBjb25zdCBjb25kWSA9IHR5cGVvZiBveSA9PT0gJ3N0cmluZyc7XG5cbiAgaWYgKGNvbmRYIHx8IGNvbmRZKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGVpZ2h0LFxuICAgICAgd2lkdGgsXG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSBlbGVtZW50LmJib3goKTsgLy8gQW5kIG9ubHkgb3ZlcndyaXRlIGlmIHN0cmluZyB3YXMgcGFzc2VkIGZvciB0aGlzIHNwZWNpZmljIGF4aXNcblxuICAgIGlmIChjb25kWCkge1xuICAgICAgb3ggPSBveC5pbmNsdWRlcygnbGVmdCcpID8geCA6IG94LmluY2x1ZGVzKCdyaWdodCcpID8geCArIHdpZHRoIDogeCArIHdpZHRoIC8gMjtcbiAgICB9XG5cbiAgICBpZiAoY29uZFkpIHtcbiAgICAgIG95ID0gb3kuaW5jbHVkZXMoJ3RvcCcpID8geSA6IG95LmluY2x1ZGVzKCdib3R0b20nKSA/IHkgKyBoZWlnaHQgOiB5ICsgaGVpZ2h0IC8gMjtcbiAgICB9XG4gIH0gLy8gUmV0dXJuIHRoZSBvcmlnaW4gYXMgaXQgaXMgaWYgaXQgd2Fzbid0IGEgc3RyaW5nXG5cblxuICByZXR1cm4gW294LCBveV07XG59XG5cbnZhciB1dGlscyA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBtYXA6IG1hcCxcbiAgZmlsdGVyOiBmaWx0ZXIsXG4gIHJhZGlhbnM6IHJhZGlhbnMsXG4gIGRlZ3JlZXM6IGRlZ3JlZXMsXG4gIGNhbWVsQ2FzZTogY2FtZWxDYXNlLFxuICB1bkNhbWVsQ2FzZTogdW5DYW1lbENhc2UsXG4gIGNhcGl0YWxpemU6IGNhcGl0YWxpemUsXG4gIHByb3BvcnRpb25hbFNpemU6IHByb3BvcnRpb25hbFNpemUsXG4gIGdldE9yaWdpbjogZ2V0T3JpZ2luXG59O1xuXG4vLyBEZWZhdWx0IG5hbWVzcGFjZXNcbmNvbnN0IHN2ZyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5jb25zdCBodG1sID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xuY29uc3QgeG1sbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nO1xuY29uc3QgeGxpbmsgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5jb25zdCBzdmdqcyA9ICdodHRwOi8vc3ZnanMuZGV2L3N2Z2pzJztcblxudmFyIG5hbWVzcGFjZXMgPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgc3ZnOiBzdmcsXG4gIGh0bWw6IGh0bWwsXG4gIHhtbG5zOiB4bWxucyxcbiAgeGxpbms6IHhsaW5rLFxuICBzdmdqczogc3ZnanNcbn07XG5cbmNvbnN0IGdsb2JhbHMgPSB7XG4gIHdpbmRvdzogdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93LFxuICBkb2N1bWVudDogdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBkb2N1bWVudFxufTtcbmZ1bmN0aW9uIHJlZ2lzdGVyV2luZG93KHdpbiA9IG51bGwsIGRvYyA9IG51bGwpIHtcbiAgZ2xvYmFscy53aW5kb3cgPSB3aW47XG4gIGdsb2JhbHMuZG9jdW1lbnQgPSBkb2M7XG59XG5jb25zdCBzYXZlID0ge307XG5mdW5jdGlvbiBzYXZlV2luZG93KCkge1xuICBzYXZlLndpbmRvdyA9IGdsb2JhbHMud2luZG93O1xuICBzYXZlLmRvY3VtZW50ID0gZ2xvYmFscy5kb2N1bWVudDtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVXaW5kb3coKSB7XG4gIGdsb2JhbHMud2luZG93ID0gc2F2ZS53aW5kb3c7XG4gIGdsb2JhbHMuZG9jdW1lbnQgPSBzYXZlLmRvY3VtZW50O1xufVxuZnVuY3Rpb24gd2l0aFdpbmRvdyh3aW4sIGZuKSB7XG4gIHNhdmVXaW5kb3coKTtcbiAgcmVnaXN0ZXJXaW5kb3cod2luLCB3aW4uZG9jdW1lbnQpO1xuICBmbih3aW4sIHdpbi5kb2N1bWVudCk7XG4gIHJlc3RvcmVXaW5kb3coKTtcbn1cbmZ1bmN0aW9uIGdldFdpbmRvdygpIHtcbiAgcmV0dXJuIGdsb2JhbHMud2luZG93O1xufVxuXG5jbGFzcyBCYXNlIHsvLyBjb25zdHJ1Y3RvciAobm9kZS8qLCB7ZXh0ZW5zaW9ucyA9IFtdfSAqLykge1xuICAvLyAgIC8vIHRoaXMudGFncyA9IFtdXG4gIC8vICAgLy9cbiAgLy8gICAvLyBmb3IgKGxldCBleHRlbnNpb24gb2YgZXh0ZW5zaW9ucykge1xuICAvLyAgIC8vICAgZXh0ZW5zaW9uLnNldHVwLmNhbGwodGhpcywgbm9kZSlcbiAgLy8gICAvLyAgIHRoaXMudGFncy5wdXNoKGV4dGVuc2lvbi5uYW1lKVxuICAvLyAgIC8vIH1cbiAgLy8gfVxufVxuXG5jb25zdCBlbGVtZW50cyA9IHt9O1xuY29uc3Qgcm9vdCA9ICdfX19TWU1CT0xfX19ST09UX19fJzsgLy8gTWV0aG9kIGZvciBlbGVtZW50IGNyZWF0aW9uXG5cbmZ1bmN0aW9uIGNyZWF0ZShuYW1lLCBucyA9IHN2Zykge1xuICAvLyBjcmVhdGUgZWxlbWVudFxuICByZXR1cm4gZ2xvYmFscy5kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsIG5hbWUpO1xufVxuZnVuY3Rpb24gbWFrZUluc3RhbmNlKGVsZW1lbnQsIGlzSFRNTCA9IGZhbHNlKSB7XG4gIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQmFzZSkgcmV0dXJuIGVsZW1lbnQ7XG5cbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBhZG9wdGVyKGVsZW1lbnQpO1xuICB9XG5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXcgZWxlbWVudHNbcm9vdF0oKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgJiYgZWxlbWVudC5jaGFyQXQoMCkgIT09ICc8Jykge1xuICAgIHJldHVybiBhZG9wdGVyKGdsb2JhbHMuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbGVtZW50KSk7XG4gIH0gLy8gTWFrZSBzdXJlLCB0aGF0IEhUTUwgZWxlbWVudHMgYXJlIGNyZWF0ZWQgd2l0aCB0aGUgY29ycmVjdCBuYW1lc3BhY2VcblxuXG4gIGNvbnN0IHdyYXBwZXIgPSBpc0hUTUwgPyBnbG9iYWxzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogY3JlYXRlKCdzdmcnKTtcbiAgd3JhcHBlci5pbm5lckhUTUwgPSBlbGVtZW50OyAvLyBXZSBjYW4gdXNlIGZpcnN0Q2hpbGQgaGVyZSBiZWNhdXNlIHdlIGtub3csXG4gIC8vIHRoYXQgdGhlIGZpcnN0IGNoYXIgaXMgPCBhbmQgdGh1cyBhbiBlbGVtZW50XG5cbiAgZWxlbWVudCA9IGFkb3B0ZXIod3JhcHBlci5maXJzdENoaWxkKTsgLy8gbWFrZSBzdXJlLCB0aGF0IGVsZW1lbnQgZG9lc24ndCBoYXZlIGl0cyB3cmFwcGVyIGF0dGFjaGVkXG5cbiAgd3JhcHBlci5yZW1vdmVDaGlsZCh3cmFwcGVyLmZpcnN0Q2hpbGQpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIG5vZGVPck5ldyhuYW1lLCBub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUub3duZXJEb2N1bWVudCAmJiBub2RlIGluc3RhbmNlb2Ygbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3Lk5vZGUgPyBub2RlIDogY3JlYXRlKG5hbWUpO1xufSAvLyBBZG9wdCBleGlzdGluZyBzdmcgZWxlbWVudHNcblxuZnVuY3Rpb24gYWRvcHQobm9kZSkge1xuICAvLyBjaGVjayBmb3IgcHJlc2VuY2Ugb2Ygbm9kZVxuICBpZiAoIW5vZGUpIHJldHVybiBudWxsOyAvLyBtYWtlIHN1cmUgYSBub2RlIGlzbid0IGFscmVhZHkgYWRvcHRlZFxuXG4gIGlmIChub2RlLmluc3RhbmNlIGluc3RhbmNlb2YgQmFzZSkgcmV0dXJuIG5vZGUuaW5zdGFuY2U7XG5cbiAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICcjZG9jdW1lbnQtZnJhZ21lbnQnKSB7XG4gICAgcmV0dXJuIG5ldyBlbGVtZW50cy5GcmFnbWVudChub2RlKTtcbiAgfSAvLyBpbml0aWFsaXplIHZhcmlhYmxlc1xuXG5cbiAgbGV0IGNsYXNzTmFtZSA9IGNhcGl0YWxpemUobm9kZS5ub2RlTmFtZSB8fCAnRG9tJyk7IC8vIE1ha2Ugc3VyZSB0aGF0IGdyYWRpZW50cyBhcmUgYWRvcHRlZCBjb3JyZWN0bHlcblxuICBpZiAoY2xhc3NOYW1lID09PSAnTGluZWFyR3JhZGllbnQnIHx8IGNsYXNzTmFtZSA9PT0gJ1JhZGlhbEdyYWRpZW50Jykge1xuICAgIGNsYXNzTmFtZSA9ICdHcmFkaWVudCc7IC8vIEZhbGxiYWNrIHRvIERvbSBpZiBlbGVtZW50IGlzIG5vdCBrbm93blxuICB9IGVsc2UgaWYgKCFlbGVtZW50c1tjbGFzc05hbWVdKSB7XG4gICAgY2xhc3NOYW1lID0gJ0RvbSc7XG4gIH1cblxuICByZXR1cm4gbmV3IGVsZW1lbnRzW2NsYXNzTmFtZV0obm9kZSk7XG59XG5sZXQgYWRvcHRlciA9IGFkb3B0O1xuZnVuY3Rpb24gbW9ja0Fkb3B0KG1vY2sgPSBhZG9wdCkge1xuICBhZG9wdGVyID0gbW9jaztcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyKGVsZW1lbnQsIG5hbWUgPSBlbGVtZW50Lm5hbWUsIGFzUm9vdCA9IGZhbHNlKSB7XG4gIGVsZW1lbnRzW25hbWVdID0gZWxlbWVudDtcbiAgaWYgKGFzUm9vdCkgZWxlbWVudHNbcm9vdF0gPSBlbGVtZW50O1xuICBhZGRNZXRob2ROYW1lcyhPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlbGVtZW50LnByb3RvdHlwZSkpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIGdldENsYXNzKG5hbWUpIHtcbiAgcmV0dXJuIGVsZW1lbnRzW25hbWVdO1xufSAvLyBFbGVtZW50IGlkIHNlcXVlbmNlXG5cbmxldCBkaWQgPSAxMDAwOyAvLyBHZXQgbmV4dCBuYW1lZCBlbGVtZW50IGlkXG5cbmZ1bmN0aW9uIGVpZChuYW1lKSB7XG4gIHJldHVybiAnU3ZnanMnICsgY2FwaXRhbGl6ZShuYW1lKSArIGRpZCsrO1xufSAvLyBEZWVwIG5ldyBpZCBhc3NpZ25tZW50XG5cbmZ1bmN0aW9uIGFzc2lnbk5ld0lkKG5vZGUpIHtcbiAgLy8gZG8gdGhlIHNhbWUgZm9yIFNWRyBjaGlsZCBub2RlcyBhcyB3ZWxsXG4gIGZvciAobGV0IGkgPSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgYXNzaWduTmV3SWQobm9kZS5jaGlsZHJlbltpXSk7XG4gIH1cblxuICBpZiAobm9kZS5pZCkge1xuICAgIG5vZGUuaWQgPSBlaWQobm9kZS5ub2RlTmFtZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0gLy8gTWV0aG9kIGZvciBleHRlbmRpbmcgb2JqZWN0c1xuXG5mdW5jdGlvbiBleHRlbmQobW9kdWxlcywgbWV0aG9kcykge1xuICBsZXQga2V5LCBpO1xuICBtb2R1bGVzID0gQXJyYXkuaXNBcnJheShtb2R1bGVzKSA/IG1vZHVsZXMgOiBbbW9kdWxlc107XG5cbiAgZm9yIChpID0gbW9kdWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIG1vZHVsZXNbaV0ucHJvdG90eXBlW2tleV0gPSBtZXRob2RzW2tleV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB3cmFwV2l0aEF0dHJDaGVjayhmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBvID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKG8gJiYgby5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmICEobyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3Muc2xpY2UoMCwgLTEpKS5hdHRyKG8pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBzaWJsaW5ncygpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50KCkuY2hpbGRyZW4oKTtcbn0gLy8gR2V0IHRoZSBjdXJyZW50IHBvc2l0aW9uIHNpYmxpbmdzXG5cbmZ1bmN0aW9uIHBvc2l0aW9uKCkge1xuICByZXR1cm4gdGhpcy5wYXJlbnQoKS5pbmRleCh0aGlzKTtcbn0gLy8gR2V0IHRoZSBuZXh0IGVsZW1lbnQgKHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlcmUgaXMgbm9uZSlcblxuZnVuY3Rpb24gbmV4dCgpIHtcbiAgcmV0dXJuIHRoaXMuc2libGluZ3MoKVt0aGlzLnBvc2l0aW9uKCkgKyAxXTtcbn0gLy8gR2V0IHRoZSBuZXh0IGVsZW1lbnQgKHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlcmUgaXMgbm9uZSlcblxuZnVuY3Rpb24gcHJldigpIHtcbiAgcmV0dXJuIHRoaXMuc2libGluZ3MoKVt0aGlzLnBvc2l0aW9uKCkgLSAxXTtcbn0gLy8gU2VuZCBnaXZlbiBlbGVtZW50IG9uZSBzdGVwIGZvcndhcmRcblxuZnVuY3Rpb24gZm9yd2FyZCgpIHtcbiAgY29uc3QgaSA9IHRoaXMucG9zaXRpb24oKTtcbiAgY29uc3QgcCA9IHRoaXMucGFyZW50KCk7IC8vIG1vdmUgbm9kZSBvbmUgc3RlcCBmb3J3YXJkXG5cbiAgcC5hZGQodGhpcy5yZW1vdmUoKSwgaSArIDEpO1xuICByZXR1cm4gdGhpcztcbn0gLy8gU2VuZCBnaXZlbiBlbGVtZW50IG9uZSBzdGVwIGJhY2t3YXJkXG5cbmZ1bmN0aW9uIGJhY2t3YXJkKCkge1xuICBjb25zdCBpID0gdGhpcy5wb3NpdGlvbigpO1xuICBjb25zdCBwID0gdGhpcy5wYXJlbnQoKTtcbiAgcC5hZGQodGhpcy5yZW1vdmUoKSwgaSA/IGkgLSAxIDogMCk7XG4gIHJldHVybiB0aGlzO1xufSAvLyBTZW5kIGdpdmVuIGVsZW1lbnQgYWxsIHRoZSB3YXkgdG8gdGhlIGZyb250XG5cbmZ1bmN0aW9uIGZyb250KCkge1xuICBjb25zdCBwID0gdGhpcy5wYXJlbnQoKTsgLy8gTW92ZSBub2RlIGZvcndhcmRcblxuICBwLmFkZCh0aGlzLnJlbW92ZSgpKTtcbiAgcmV0dXJuIHRoaXM7XG59IC8vIFNlbmQgZ2l2ZW4gZWxlbWVudCBhbGwgdGhlIHdheSB0byB0aGUgYmFja1xuXG5mdW5jdGlvbiBiYWNrKCkge1xuICBjb25zdCBwID0gdGhpcy5wYXJlbnQoKTsgLy8gTW92ZSBub2RlIGJhY2tcblxuICBwLmFkZCh0aGlzLnJlbW92ZSgpLCAwKTtcbiAgcmV0dXJuIHRoaXM7XG59IC8vIEluc2VydHMgYSBnaXZlbiBlbGVtZW50IGJlZm9yZSB0aGUgdGFyZ2V0ZWQgZWxlbWVudFxuXG5mdW5jdGlvbiBiZWZvcmUoZWxlbWVudCkge1xuICBlbGVtZW50ID0gbWFrZUluc3RhbmNlKGVsZW1lbnQpO1xuICBlbGVtZW50LnJlbW92ZSgpO1xuICBjb25zdCBpID0gdGhpcy5wb3NpdGlvbigpO1xuICB0aGlzLnBhcmVudCgpLmFkZChlbGVtZW50LCBpKTtcbiAgcmV0dXJuIHRoaXM7XG59IC8vIEluc2VydHMgYSBnaXZlbiBlbGVtZW50IGFmdGVyIHRoZSB0YXJnZXRlZCBlbGVtZW50XG5cbmZ1bmN0aW9uIGFmdGVyKGVsZW1lbnQpIHtcbiAgZWxlbWVudCA9IG1ha2VJbnN0YW5jZShlbGVtZW50KTtcbiAgZWxlbWVudC5yZW1vdmUoKTtcbiAgY29uc3QgaSA9IHRoaXMucG9zaXRpb24oKTtcbiAgdGhpcy5wYXJlbnQoKS5hZGQoZWxlbWVudCwgaSArIDEpO1xuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIGluc2VydEJlZm9yZShlbGVtZW50KSB7XG4gIGVsZW1lbnQgPSBtYWtlSW5zdGFuY2UoZWxlbWVudCk7XG4gIGVsZW1lbnQuYmVmb3JlKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIGluc2VydEFmdGVyKGVsZW1lbnQpIHtcbiAgZWxlbWVudCA9IG1ha2VJbnN0YW5jZShlbGVtZW50KTtcbiAgZWxlbWVudC5hZnRlcih0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5yZWdpc3Rlck1ldGhvZHMoJ0RvbScsIHtcbiAgc2libGluZ3MsXG4gIHBvc2l0aW9uLFxuICBuZXh0LFxuICBwcmV2LFxuICBmb3J3YXJkLFxuICBiYWNrd2FyZCxcbiAgZnJvbnQsXG4gIGJhY2ssXG4gIGJlZm9yZSxcbiAgYWZ0ZXIsXG4gIGluc2VydEJlZm9yZSxcbiAgaW5zZXJ0QWZ0ZXJcbn0pO1xuXG4vLyBQYXJzZSB1bml0IHZhbHVlXG5jb25zdCBudW1iZXJBbmRVbml0ID0gL14oWystXT8oXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoZVsrLV0/XFxkKyk/KShbYS16JV0qKSQvaTsgLy8gUGFyc2UgaGV4IHZhbHVlXG5cbmNvbnN0IGhleCA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2k7IC8vIFBhcnNlIHJnYiB2YWx1ZVxuXG5jb25zdCByZ2IgPSAvcmdiXFwoKFxcZCspLChcXGQrKSwoXFxkKylcXCkvOyAvLyBQYXJzZSByZWZlcmVuY2UgaWRcblxuY29uc3QgcmVmZXJlbmNlID0gLygjW2Etel9dW2EtejAtOVxcLV9dKikvaTsgLy8gc3BsaXRzIGEgdHJhbnNmb3JtYXRpb24gY2hhaW5cblxuY29uc3QgdHJhbnNmb3JtcyA9IC9cXClcXHMqLD9cXHMqLzsgLy8gV2hpdGVzcGFjZVxuXG5jb25zdCB3aGl0ZXNwYWNlID0gL1xccy9nOyAvLyBUZXN0IGhleCB2YWx1ZVxuXG5jb25zdCBpc0hleCA9IC9eI1thLWYwLTldezN9JHxeI1thLWYwLTldezZ9JC9pOyAvLyBUZXN0IHJnYiB2YWx1ZVxuXG5jb25zdCBpc1JnYiA9IC9ecmdiXFwoLzsgLy8gVGVzdCBmb3IgYmxhbmsgc3RyaW5nXG5cbmNvbnN0IGlzQmxhbmsgPSAvXihcXHMrKT8kLzsgLy8gVGVzdCBmb3IgbnVtZXJpYyBzdHJpbmdcblxuY29uc3QgaXNOdW1iZXIgPSAvXlsrLV0/KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPyQvaTsgLy8gVGVzdCBmb3IgaW1hZ2UgdXJsXG5cbmNvbnN0IGlzSW1hZ2UgPSAvXFwuKGpwZ3xqcGVnfHBuZ3xnaWZ8c3ZnKShcXD9bXj1dKy4qKT8vaTsgLy8gc3BsaXQgYXQgd2hpdGVzcGFjZSBhbmQgY29tbWFcblxuY29uc3QgZGVsaW1pdGVyID0gL1tcXHMsXSsvOyAvLyBUZXN0IGZvciBwYXRoIGxldHRlclxuXG5jb25zdCBpc1BhdGhMZXR0ZXIgPSAvW01MSFZDU1FUQVpdL2k7XG5cbnZhciByZWdleCA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBudW1iZXJBbmRVbml0OiBudW1iZXJBbmRVbml0LFxuICBoZXg6IGhleCxcbiAgcmdiOiByZ2IsXG4gIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxuICB0cmFuc2Zvcm1zOiB0cmFuc2Zvcm1zLFxuICB3aGl0ZXNwYWNlOiB3aGl0ZXNwYWNlLFxuICBpc0hleDogaXNIZXgsXG4gIGlzUmdiOiBpc1JnYixcbiAgaXNCbGFuazogaXNCbGFuayxcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICBpc0ltYWdlOiBpc0ltYWdlLFxuICBkZWxpbWl0ZXI6IGRlbGltaXRlcixcbiAgaXNQYXRoTGV0dGVyOiBpc1BhdGhMZXR0ZXJcbn07XG5cbmZ1bmN0aW9uIGNsYXNzZXMoKSB7XG4gIGNvbnN0IGF0dHIgPSB0aGlzLmF0dHIoJ2NsYXNzJyk7XG4gIHJldHVybiBhdHRyID09IG51bGwgPyBbXSA6IGF0dHIudHJpbSgpLnNwbGl0KGRlbGltaXRlcik7XG59IC8vIFJldHVybiB0cnVlIGlmIGNsYXNzIGV4aXN0cyBvbiB0aGUgbm9kZSwgZmFsc2Ugb3RoZXJ3aXNlXG5cbmZ1bmN0aW9uIGhhc0NsYXNzKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuY2xhc3NlcygpLmluZGV4T2YobmFtZSkgIT09IC0xO1xufSAvLyBBZGQgY2xhc3MgdG8gdGhlIG5vZGVcblxuZnVuY3Rpb24gYWRkQ2xhc3MobmFtZSkge1xuICBpZiAoIXRoaXMuaGFzQ2xhc3MobmFtZSkpIHtcbiAgICBjb25zdCBhcnJheSA9IHRoaXMuY2xhc3NlcygpO1xuICAgIGFycmF5LnB1c2gobmFtZSk7XG4gICAgdGhpcy5hdHRyKCdjbGFzcycsIGFycmF5LmpvaW4oJyAnKSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn0gLy8gUmVtb3ZlIGNsYXNzIGZyb20gdGhlIG5vZGVcblxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MobmFtZSkge1xuICBpZiAodGhpcy5oYXNDbGFzcyhuYW1lKSkge1xuICAgIHRoaXMuYXR0cignY2xhc3MnLCB0aGlzLmNsYXNzZXMoKS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjICE9PSBuYW1lO1xuICAgIH0pLmpvaW4oJyAnKSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn0gLy8gVG9nZ2xlIHRoZSBwcmVzZW5jZSBvZiBhIGNsYXNzIG9uIHRoZSBub2RlXG5cbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuaGFzQ2xhc3MobmFtZSkgPyB0aGlzLnJlbW92ZUNsYXNzKG5hbWUpIDogdGhpcy5hZGRDbGFzcyhuYW1lKTtcbn1cbnJlZ2lzdGVyTWV0aG9kcygnRG9tJywge1xuICBjbGFzc2VzLFxuICBoYXNDbGFzcyxcbiAgYWRkQ2xhc3MsXG4gIHJlbW92ZUNsYXNzLFxuICB0b2dnbGVDbGFzc1xufSk7XG5cbmZ1bmN0aW9uIGNzcyhzdHlsZSwgdmFsKSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gZ2V0IGZ1bGwgc3R5bGUgYXMgb2JqZWN0XG4gICAgdGhpcy5ub2RlLnN0eWxlLmNzc1RleHQuc3BsaXQoL1xccyo7XFxzKi8pLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiAhIWVsLmxlbmd0aDtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgY29uc3QgdCA9IGVsLnNwbGl0KC9cXHMqOlxccyovKTtcbiAgICAgIHJldFt0WzBdXSA9IHRbMV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIC8vIGdldCBzdHlsZSBwcm9wZXJ0aWVzIGFzIGFycmF5XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUpKSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygc3R5bGUpIHtcbiAgICAgICAgY29uc3QgY2FzZWQgPSBjYW1lbENhc2UobmFtZSk7XG4gICAgICAgIHJldFtuYW1lXSA9IHRoaXMubm9kZS5zdHlsZVtjYXNlZF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBnZXQgc3R5bGUgZm9yIHByb3BlcnR5XG5cblxuICAgIGlmICh0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlLnN0eWxlW2NhbWVsQ2FzZShzdHlsZSldO1xuICAgIH0gLy8gc2V0IHN0eWxlcyBpbiBvYmplY3RcblxuXG4gICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBzdHlsZSkge1xuICAgICAgICAvLyBzZXQgZW1wdHkgc3RyaW5nIGlmIG51bGwvdW5kZWZpbmVkLycnIHdhcyBnaXZlblxuICAgICAgICB0aGlzLm5vZGUuc3R5bGVbY2FtZWxDYXNlKG5hbWUpXSA9IHN0eWxlW25hbWVdID09IG51bGwgfHwgaXNCbGFuay50ZXN0KHN0eWxlW25hbWVdKSA/ICcnIDogc3R5bGVbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9IC8vIHNldCBzdHlsZSBmb3IgcHJvcGVydHlcblxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdGhpcy5ub2RlLnN0eWxlW2NhbWVsQ2FzZShzdHlsZSldID0gdmFsID09IG51bGwgfHwgaXNCbGFuay50ZXN0KHZhbCkgPyAnJyA6IHZhbDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufSAvLyBTaG93IGVsZW1lbnRcblxuZnVuY3Rpb24gc2hvdygpIHtcbiAgcmV0dXJuIHRoaXMuY3NzKCdkaXNwbGF5JywgJycpO1xufSAvLyBIaWRlIGVsZW1lbnRcblxuZnVuY3Rpb24gaGlkZSgpIHtcbiAgcmV0dXJuIHRoaXMuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbn0gLy8gSXMgZWxlbWVudCB2aXNpYmxlP1xuXG5mdW5jdGlvbiB2aXNpYmxlKCkge1xuICByZXR1cm4gdGhpcy5jc3MoJ2Rpc3BsYXknKSAhPT0gJ25vbmUnO1xufVxucmVnaXN0ZXJNZXRob2RzKCdEb20nLCB7XG4gIGNzcyxcbiAgc2hvdyxcbiAgaGlkZSxcbiAgdmlzaWJsZVxufSk7XG5cbmZ1bmN0aW9uIGRhdGEoYSwgdiwgcikge1xuICBpZiAoYSA9PSBudWxsKSB7XG4gICAgLy8gZ2V0IGFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzXG4gICAgcmV0dXJuIHRoaXMuZGF0YShtYXAoZmlsdGVyKHRoaXMubm9kZS5hdHRyaWJ1dGVzLCBlbCA9PiBlbC5ub2RlTmFtZS5pbmRleE9mKCdkYXRhLScpID09PSAwKSwgZWwgPT4gZWwubm9kZU5hbWUuc2xpY2UoNSkpKTtcbiAgfSBlbHNlIGlmIChhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBjb25zdCBkYXRhID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBhKSB7XG4gICAgICBkYXRhW2tleV0gPSB0aGlzLmRhdGEoa2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHYgaW4gYSkge1xuICAgICAgdGhpcy5kYXRhKHYsIGFbdl0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLmF0dHIoJ2RhdGEtJyArIGEpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdkYXRhLScgKyBhKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hdHRyKCdkYXRhLScgKyBhLCB2ID09PSBudWxsID8gbnVsbCA6IHIgPT09IHRydWUgfHwgdHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJyA/IHYgOiBKU09OLnN0cmluZ2lmeSh2KSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbnJlZ2lzdGVyTWV0aG9kcygnRG9tJywge1xuICBkYXRhXG59KTtcblxuZnVuY3Rpb24gcmVtZW1iZXIoaywgdikge1xuICAvLyByZW1lbWJlciBldmVyeSBpdGVtIGluIGFuIG9iamVjdCBpbmRpdmlkdWFsbHlcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaykge1xuICAgICAgdGhpcy5yZW1lbWJlcihrZXksIGtba2V5XSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAvLyByZXRyaWV2ZSBtZW1vcnlcbiAgICByZXR1cm4gdGhpcy5tZW1vcnkoKVtrXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzdG9yZSBtZW1vcnlcbiAgICB0aGlzLm1lbW9yeSgpW2tdID0gdjtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufSAvLyBFcmFzZSBhIGdpdmVuIG1lbW9yeVxuXG5mdW5jdGlvbiBmb3JnZXQoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5fbWVtb3J5ID0ge307XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgZGVsZXRlIHRoaXMubWVtb3J5KClbYXJndW1lbnRzW2ldXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn0gLy8gVGhpcyB0cmlnZ2VycyBjcmVhdGlvbiBvZiBhIG5ldyBoaWRkZW4gY2xhc3Mgd2hpY2ggaXMgbm90IHBlcmZvcm1hbnRcbi8vIEhvd2V2ZXIsIHRoaXMgZnVuY3Rpb24gaXMgbm90IHJhcmVseSB1c2VkIHNvIGl0IHdpbGwgbm90IGhhcHBlbiBmcmVxdWVudGx5XG4vLyBSZXR1cm4gbG9jYWwgbWVtb3J5IG9iamVjdFxuXG5mdW5jdGlvbiBtZW1vcnkoKSB7XG4gIHJldHVybiB0aGlzLl9tZW1vcnkgPSB0aGlzLl9tZW1vcnkgfHwge307XG59XG5yZWdpc3Rlck1ldGhvZHMoJ0RvbScsIHtcbiAgcmVtZW1iZXIsXG4gIGZvcmdldCxcbiAgbWVtb3J5XG59KTtcblxuZnVuY3Rpb24gc2l4RGlnaXRIZXgoaGV4KSB7XG4gIHJldHVybiBoZXgubGVuZ3RoID09PSA0ID8gWycjJywgaGV4LnN1YnN0cmluZygxLCAyKSwgaGV4LnN1YnN0cmluZygxLCAyKSwgaGV4LnN1YnN0cmluZygyLCAzKSwgaGV4LnN1YnN0cmluZygyLCAzKSwgaGV4LnN1YnN0cmluZygzLCA0KSwgaGV4LnN1YnN0cmluZygzLCA0KV0uam9pbignJykgOiBoZXg7XG59XG5cbmZ1bmN0aW9uIGNvbXBvbmVudEhleChjb21wb25lbnQpIHtcbiAgY29uc3QgaW50ZWdlciA9IE1hdGgucm91bmQoY29tcG9uZW50KTtcbiAgY29uc3QgYm91bmRlZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgaW50ZWdlcikpO1xuICBjb25zdCBoZXggPSBib3VuZGVkLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIGhleC5sZW5ndGggPT09IDEgPyAnMCcgKyBoZXggOiBoZXg7XG59XG5cbmZ1bmN0aW9uIGlzKG9iamVjdCwgc3BhY2UpIHtcbiAgZm9yIChsZXQgaSA9IHNwYWNlLmxlbmd0aDsgaS0tOykge1xuICAgIGlmIChvYmplY3Rbc3BhY2VbaV1dID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyYW1ldGVycyhhLCBiKSB7XG4gIGNvbnN0IHBhcmFtcyA9IGlzKGEsICdyZ2InKSA/IHtcbiAgICBfYTogYS5yLFxuICAgIF9iOiBhLmcsXG4gICAgX2M6IGEuYixcbiAgICBfZDogMCxcbiAgICBzcGFjZTogJ3JnYidcbiAgfSA6IGlzKGEsICd4eXonKSA/IHtcbiAgICBfYTogYS54LFxuICAgIF9iOiBhLnksXG4gICAgX2M6IGEueixcbiAgICBfZDogMCxcbiAgICBzcGFjZTogJ3h5eidcbiAgfSA6IGlzKGEsICdoc2wnKSA/IHtcbiAgICBfYTogYS5oLFxuICAgIF9iOiBhLnMsXG4gICAgX2M6IGEubCxcbiAgICBfZDogMCxcbiAgICBzcGFjZTogJ2hzbCdcbiAgfSA6IGlzKGEsICdsYWInKSA/IHtcbiAgICBfYTogYS5sLFxuICAgIF9iOiBhLmEsXG4gICAgX2M6IGEuYixcbiAgICBfZDogMCxcbiAgICBzcGFjZTogJ2xhYidcbiAgfSA6IGlzKGEsICdsY2gnKSA/IHtcbiAgICBfYTogYS5sLFxuICAgIF9iOiBhLmMsXG4gICAgX2M6IGEuaCxcbiAgICBfZDogMCxcbiAgICBzcGFjZTogJ2xjaCdcbiAgfSA6IGlzKGEsICdjbXlrJykgPyB7XG4gICAgX2E6IGEuYyxcbiAgICBfYjogYS5tLFxuICAgIF9jOiBhLnksXG4gICAgX2Q6IGEuayxcbiAgICBzcGFjZTogJ2NteWsnXG4gIH0gOiB7XG4gICAgX2E6IDAsXG4gICAgX2I6IDAsXG4gICAgX2M6IDAsXG4gICAgc3BhY2U6ICdyZ2InXG4gIH07XG4gIHBhcmFtcy5zcGFjZSA9IGIgfHwgcGFyYW1zLnNwYWNlO1xuICByZXR1cm4gcGFyYW1zO1xufVxuXG5mdW5jdGlvbiBjaWVTcGFjZShzcGFjZSkge1xuICBpZiAoc3BhY2UgPT09ICdsYWInIHx8IHNwYWNlID09PSAneHl6JyB8fCBzcGFjZSA9PT0gJ2xjaCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaHVlVG9SZ2IocCwgcSwgdCkge1xuICBpZiAodCA8IDApIHQgKz0gMTtcbiAgaWYgKHQgPiAxKSB0IC09IDE7XG4gIGlmICh0IDwgMSAvIDYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICBpZiAodCA8IDEgLyAyKSByZXR1cm4gcTtcbiAgaWYgKHQgPCAyIC8gMykgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xuICByZXR1cm4gcDtcbn1cblxuY2xhc3MgQ29sb3Ige1xuICBjb25zdHJ1Y3RvciguLi5pbnB1dHMpIHtcbiAgICB0aGlzLmluaXQoLi4uaW5wdXRzKTtcbiAgfSAvLyBUZXN0IGlmIGdpdmVuIHZhbHVlIGlzIGEgY29sb3JcblxuXG4gIHN0YXRpYyBpc0NvbG9yKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNvbG9yICYmIChjb2xvciBpbnN0YW5jZW9mIENvbG9yIHx8IHRoaXMuaXNSZ2IoY29sb3IpIHx8IHRoaXMudGVzdChjb2xvcikpO1xuICB9IC8vIFRlc3QgaWYgZ2l2ZW4gdmFsdWUgaXMgYW4gcmdiIG9iamVjdFxuXG5cbiAgc3RhdGljIGlzUmdiKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNvbG9yICYmIHR5cGVvZiBjb2xvci5yID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IuZyA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLmIgPT09ICdudW1iZXInO1xuICB9XG4gIC8qXG4gIEdlbmVyYXRpbmcgcmFuZG9tIGNvbG9yc1xuICAqL1xuXG5cbiAgc3RhdGljIHJhbmRvbShtb2RlID0gJ3ZpYnJhbnQnLCB0LCB1KSB7XG4gICAgLy8gR2V0IHRoZSBtYXRoIG1vZHVsZXNcbiAgICBjb25zdCB7XG4gICAgICByYW5kb20sXG4gICAgICByb3VuZCxcbiAgICAgIHNpbixcbiAgICAgIFBJOiBwaVxuICAgIH0gPSBNYXRoOyAvLyBSdW4gdGhlIGNvcnJlY3QgZ2VuZXJhdG9yXG5cbiAgICBpZiAobW9kZSA9PT0gJ3ZpYnJhbnQnKSB7XG4gICAgICBjb25zdCBsID0gKDgxIC0gNTcpICogcmFuZG9tKCkgKyA1NztcbiAgICAgIGNvbnN0IGMgPSAoODMgLSA0NSkgKiByYW5kb20oKSArIDQ1O1xuICAgICAgY29uc3QgaCA9IDM2MCAqIHJhbmRvbSgpO1xuICAgICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IobCwgYywgaCwgJ2xjaCcpO1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ3NpbmUnKSB7XG4gICAgICB0ID0gdCA9PSBudWxsID8gcmFuZG9tKCkgOiB0O1xuICAgICAgY29uc3QgciA9IHJvdW5kKDgwICogc2luKDIgKiBwaSAqIHQgLyAwLjUgKyAwLjAxKSArIDE1MCk7XG4gICAgICBjb25zdCBnID0gcm91bmQoNTAgKiBzaW4oMiAqIHBpICogdCAvIDAuNSArIDQuNikgKyAyMDApO1xuICAgICAgY29uc3QgYiA9IHJvdW5kKDEwMCAqIHNpbigyICogcGkgKiB0IC8gMC41ICsgMi4zKSArIDE1MCk7XG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihyLCBnLCBiKTtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdwYXN0ZWwnKSB7XG4gICAgICBjb25zdCBsID0gKDk0IC0gODYpICogcmFuZG9tKCkgKyA4NjtcbiAgICAgIGNvbnN0IGMgPSAoMjYgLSA5KSAqIHJhbmRvbSgpICsgOTtcbiAgICAgIGNvbnN0IGggPSAzNjAgKiByYW5kb20oKTtcbiAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGwsIGMsIGgsICdsY2gnKTtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdkYXJrJykge1xuICAgICAgY29uc3QgbCA9IDEwICsgMTAgKiByYW5kb20oKTtcbiAgICAgIGNvbnN0IGMgPSAoMTI1IC0gNzUpICogcmFuZG9tKCkgKyA4NjtcbiAgICAgIGNvbnN0IGggPSAzNjAgKiByYW5kb20oKTtcbiAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGwsIGMsIGgsICdsY2gnKTtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdyZ2InKSB7XG4gICAgICBjb25zdCByID0gMjU1ICogcmFuZG9tKCk7XG4gICAgICBjb25zdCBnID0gMjU1ICogcmFuZG9tKCk7XG4gICAgICBjb25zdCBiID0gMjU1ICogcmFuZG9tKCk7XG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihyLCBnLCBiKTtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdsYWInKSB7XG4gICAgICBjb25zdCBsID0gMTAwICogcmFuZG9tKCk7XG4gICAgICBjb25zdCBhID0gMjU2ICogcmFuZG9tKCkgLSAxMjg7XG4gICAgICBjb25zdCBiID0gMjU2ICogcmFuZG9tKCkgLSAxMjg7XG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihsLCBhLCBiLCAnbGFiJyk7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfSBlbHNlIGlmIChtb2RlID09PSAnZ3JleScpIHtcbiAgICAgIGNvbnN0IGdyZXkgPSAyNTUgKiByYW5kb20oKTtcbiAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGdyZXksIGdyZXksIGdyZXkpO1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHJhbmRvbSBjb2xvciBtb2RlJyk7XG4gICAgfVxuICB9IC8vIFRlc3QgaWYgZ2l2ZW4gdmFsdWUgaXMgYSBjb2xvciBzdHJpbmdcblxuXG4gIHN0YXRpYyB0ZXN0KGNvbG9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycgJiYgKGlzSGV4LnRlc3QoY29sb3IpIHx8IGlzUmdiLnRlc3QoY29sb3IpKTtcbiAgfVxuXG4gIGNteWsoKSB7XG4gICAgLy8gR2V0IHRoZSByZ2IgdmFsdWVzIGZvciB0aGUgY3VycmVudCBjb2xvclxuICAgIGNvbnN0IHtcbiAgICAgIF9hLFxuICAgICAgX2IsXG4gICAgICBfY1xuICAgIH0gPSB0aGlzLnJnYigpO1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IFtfYSwgX2IsIF9jXS5tYXAodiA9PiB2IC8gMjU1KTsgLy8gR2V0IHRoZSBjbXlrIHZhbHVlcyBpbiBhbiB1bmJvdW5kZWQgZm9ybWF0XG5cbiAgICBjb25zdCBrID0gTWF0aC5taW4oMSAtIHIsIDEgLSBnLCAxIC0gYik7XG5cbiAgICBpZiAoayA9PT0gMSkge1xuICAgICAgLy8gQ2F0Y2ggdGhlIGJsYWNrIGNhc2VcbiAgICAgIHJldHVybiBuZXcgQ29sb3IoMCwgMCwgMCwgMSwgJ2NteWsnKTtcbiAgICB9XG5cbiAgICBjb25zdCBjID0gKDEgLSByIC0gaykgLyAoMSAtIGspO1xuICAgIGNvbnN0IG0gPSAoMSAtIGcgLSBrKSAvICgxIC0gayk7XG4gICAgY29uc3QgeSA9ICgxIC0gYiAtIGspIC8gKDEgLSBrKTsgLy8gQ29uc3RydWN0IHRoZSBuZXcgY29sb3JcblxuICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGMsIG0sIHksIGssICdjbXlrJyk7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG5cbiAgaHNsKCkge1xuICAgIC8vIEdldCB0aGUgcmdiIHZhbHVlc1xuICAgIGNvbnN0IHtcbiAgICAgIF9hLFxuICAgICAgX2IsXG4gICAgICBfY1xuICAgIH0gPSB0aGlzLnJnYigpO1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IFtfYSwgX2IsIF9jXS5tYXAodiA9PiB2IC8gMjU1KTsgLy8gRmluZCB0aGUgbWF4aW11bSBhbmQgbWluaW11bSB2YWx1ZXMgdG8gZ2V0IHRoZSBsaWdodG5lc3NcblxuICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgIGNvbnN0IGwgPSAobWF4ICsgbWluKSAvIDI7IC8vIElmIHRoZSByLCBnLCB2IHZhbHVlcyBhcmUgaWRlbnRpY2FsIHRoZW4gd2UgYXJlIGdyZXlcblxuICAgIGNvbnN0IGlzR3JleSA9IG1heCA9PT0gbWluOyAvLyBDYWxjdWxhdGUgdGhlIGh1ZSBhbmQgc2F0dXJhdGlvblxuXG4gICAgY29uc3QgZGVsdGEgPSBtYXggLSBtaW47XG4gICAgY29uc3QgcyA9IGlzR3JleSA/IDAgOiBsID4gMC41ID8gZGVsdGEgLyAoMiAtIG1heCAtIG1pbikgOiBkZWx0YSAvIChtYXggKyBtaW4pO1xuICAgIGNvbnN0IGggPSBpc0dyZXkgPyAwIDogbWF4ID09PSByID8gKChnIC0gYikgLyBkZWx0YSArIChnIDwgYiA/IDYgOiAwKSkgLyA2IDogbWF4ID09PSBnID8gKChiIC0gcikgLyBkZWx0YSArIDIpIC8gNiA6IG1heCA9PT0gYiA/ICgociAtIGcpIC8gZGVsdGEgKyA0KSAvIDYgOiAwOyAvLyBDb25zdHJ1Y3QgYW5kIHJldHVybiB0aGUgbmV3IGNvbG9yXG5cbiAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcigzNjAgKiBoLCAxMDAgKiBzLCAxMDAgKiBsLCAnaHNsJyk7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG5cbiAgaW5pdChhID0gMCwgYiA9IDAsIGMgPSAwLCBkID0gMCwgc3BhY2UgPSAncmdiJykge1xuICAgIC8vIFRoaXMgY2F0Y2hlcyB0aGUgY2FzZSB3aGVuIGEgZmFsc3kgdmFsdWUgaXMgcGFzc2VkIGxpa2UgJydcbiAgICBhID0gIWEgPyAwIDogYTsgLy8gUmVzZXQgYWxsIHZhbHVlcyBpbiBjYXNlIHRoZSBpbml0IGZ1bmN0aW9uIGlzIHJlcnVuIHdpdGggbmV3IGNvbG9yIHNwYWNlXG5cbiAgICBpZiAodGhpcy5zcGFjZSkge1xuICAgICAgZm9yIChjb25zdCBjb21wb25lbnQgaW4gdGhpcy5zcGFjZSkge1xuICAgICAgICBkZWxldGUgdGhpc1t0aGlzLnNwYWNlW2NvbXBvbmVudF1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIEFsbG93IGZvciB0aGUgY2FzZSB0aGF0IHdlIGRvbid0IG5lZWQgZC4uLlxuICAgICAgc3BhY2UgPSB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyBkIDogc3BhY2U7XG4gICAgICBkID0gdHlwZW9mIGQgPT09ICdzdHJpbmcnID8gMCA6IGQ7IC8vIEFzc2lnbiB0aGUgdmFsdWVzIHN0cmFpZ2h0IHRvIHRoZSBjb2xvclxuXG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgICAgX2E6IGEsXG4gICAgICAgIF9iOiBiLFxuICAgICAgICBfYzogYyxcbiAgICAgICAgX2Q6IGQsXG4gICAgICAgIHNwYWNlXG4gICAgICB9KTsgLy8gSWYgdGhlIHVzZXIgZ2F2ZSB1cyBhbiBhcnJheSwgbWFrZSB0aGUgY29sb3IgZnJvbSBpdFxuICAgIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICB0aGlzLnNwYWNlID0gYiB8fCAodHlwZW9mIGFbM10gPT09ICdzdHJpbmcnID8gYVszXSA6IGFbNF0pIHx8ICdyZ2InO1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7XG4gICAgICAgIF9hOiBhWzBdLFxuICAgICAgICBfYjogYVsxXSxcbiAgICAgICAgX2M6IGFbMl0sXG4gICAgICAgIF9kOiBhWzNdIHx8IDBcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgLy8gU2V0IHRoZSBvYmplY3QgdXAgYW5kIGFzc2lnbiBpdHMgdmFsdWVzIGRpcmVjdGx5XG4gICAgICBjb25zdCB2YWx1ZXMgPSBnZXRQYXJhbWV0ZXJzKGEsIGIpO1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB2YWx1ZXMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoaXNSZ2IudGVzdChhKSkge1xuICAgICAgICBjb25zdCBub1doaXRlc3BhY2UgPSBhLnJlcGxhY2Uod2hpdGVzcGFjZSwgJycpO1xuICAgICAgICBjb25zdCBbX2EsIF9iLCBfY10gPSByZ2IuZXhlYyhub1doaXRlc3BhY2UpLnNsaWNlKDEsIDQpLm1hcCh2ID0+IHBhcnNlSW50KHYpKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7XG4gICAgICAgICAgX2EsXG4gICAgICAgICAgX2IsXG4gICAgICAgICAgX2MsXG4gICAgICAgICAgX2Q6IDAsXG4gICAgICAgICAgc3BhY2U6ICdyZ2InXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpc0hleC50ZXN0KGEpKSB7XG4gICAgICAgIGNvbnN0IGhleFBhcnNlID0gdiA9PiBwYXJzZUludCh2LCAxNik7XG5cbiAgICAgICAgY29uc3QgWywgX2EsIF9iLCBfY10gPSBoZXguZXhlYyhzaXhEaWdpdEhleChhKSkubWFwKGhleFBhcnNlKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7XG4gICAgICAgICAgX2EsXG4gICAgICAgICAgX2IsXG4gICAgICAgICAgX2MsXG4gICAgICAgICAgX2Q6IDAsXG4gICAgICAgICAgc3BhY2U6ICdyZ2InXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHRocm93IEVycm9yKCdVbnN1cHBvcnRlZCBzdHJpbmcgZm9ybWF0LCBjYW5cXCd0IGNvbnN0cnVjdCBDb2xvcicpO1xuICAgIH0gLy8gTm93IGFkZCB0aGUgY29tcG9uZW50cyBhcyBhIGNvbnZlbmllbmNlXG5cblxuICAgIGNvbnN0IHtcbiAgICAgIF9hLFxuICAgICAgX2IsXG4gICAgICBfYyxcbiAgICAgIF9kXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgY29tcG9uZW50cyA9IHRoaXMuc3BhY2UgPT09ICdyZ2InID8ge1xuICAgICAgcjogX2EsXG4gICAgICBnOiBfYixcbiAgICAgIGI6IF9jXG4gICAgfSA6IHRoaXMuc3BhY2UgPT09ICd4eXonID8ge1xuICAgICAgeDogX2EsXG4gICAgICB5OiBfYixcbiAgICAgIHo6IF9jXG4gICAgfSA6IHRoaXMuc3BhY2UgPT09ICdoc2wnID8ge1xuICAgICAgaDogX2EsXG4gICAgICBzOiBfYixcbiAgICAgIGw6IF9jXG4gICAgfSA6IHRoaXMuc3BhY2UgPT09ICdsYWInID8ge1xuICAgICAgbDogX2EsXG4gICAgICBhOiBfYixcbiAgICAgIGI6IF9jXG4gICAgfSA6IHRoaXMuc3BhY2UgPT09ICdsY2gnID8ge1xuICAgICAgbDogX2EsXG4gICAgICBjOiBfYixcbiAgICAgIGg6IF9jXG4gICAgfSA6IHRoaXMuc3BhY2UgPT09ICdjbXlrJyA/IHtcbiAgICAgIGM6IF9hLFxuICAgICAgbTogX2IsXG4gICAgICB5OiBfYyxcbiAgICAgIGs6IF9kXG4gICAgfSA6IHt9O1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgY29tcG9uZW50cyk7XG4gIH1cblxuICBsYWIoKSB7XG4gICAgLy8gR2V0IHRoZSB4eXogY29sb3JcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHpcbiAgICB9ID0gdGhpcy54eXooKTsgLy8gR2V0IHRoZSBsYWIgY29tcG9uZW50c1xuXG4gICAgY29uc3QgbCA9IDExNiAqIHkgLSAxNjtcbiAgICBjb25zdCBhID0gNTAwICogKHggLSB5KTtcbiAgICBjb25zdCBiID0gMjAwICogKHkgLSB6KTsgLy8gQ29uc3RydWN0IGFuZCByZXR1cm4gYSBuZXcgY29sb3JcblxuICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGwsIGEsIGIsICdsYWInKTtcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxuICBsY2goKSB7XG4gICAgLy8gR2V0IHRoZSBsYWIgY29sb3IgZGlyZWN0bHlcbiAgICBjb25zdCB7XG4gICAgICBsLFxuICAgICAgYSxcbiAgICAgIGJcbiAgICB9ID0gdGhpcy5sYWIoKTsgLy8gR2V0IHRoZSBjaHJvbWF0aWNpdHkgYW5kIHRoZSBodWUgdXNpbmcgcG9sYXIgY29vcmRpbmF0ZXNcblxuICAgIGNvbnN0IGMgPSBNYXRoLnNxcnQoYSAqKiAyICsgYiAqKiAyKTtcbiAgICBsZXQgaCA9IDE4MCAqIE1hdGguYXRhbjIoYiwgYSkgLyBNYXRoLlBJO1xuXG4gICAgaWYgKGggPCAwKSB7XG4gICAgICBoICo9IC0xO1xuICAgICAgaCA9IDM2MCAtIGg7XG4gICAgfSAvLyBNYWtlIGEgbmV3IGNvbG9yIGFuZCByZXR1cm4gaXRcblxuXG4gICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IobCwgYywgaCwgJ2xjaCcpO1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuICAvKlxuICBDb252ZXJzaW9uIE1ldGhvZHNcbiAgKi9cblxuXG4gIHJnYigpIHtcbiAgICBpZiAodGhpcy5zcGFjZSA9PT0gJ3JnYicpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAoY2llU3BhY2UodGhpcy5zcGFjZSkpIHtcbiAgICAgIC8vIENvbnZlcnQgdG8gdGhlIHh5eiBjb2xvciBzcGFjZVxuICAgICAgbGV0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgelxuICAgICAgfSA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLnNwYWNlID09PSAnbGFiJyB8fCB0aGlzLnNwYWNlID09PSAnbGNoJykge1xuICAgICAgICAvLyBHZXQgdGhlIHZhbHVlcyBpbiB0aGUgbGFiIHNwYWNlXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgbCxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGJcbiAgICAgICAgfSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuc3BhY2UgPT09ICdsY2gnKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIGhcbiAgICAgICAgICB9ID0gdGhpcztcbiAgICAgICAgICBjb25zdCBkVG9SID0gTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgICBhID0gYyAqIE1hdGguY29zKGRUb1IgKiBoKTtcbiAgICAgICAgICBiID0gYyAqIE1hdGguc2luKGRUb1IgKiBoKTtcbiAgICAgICAgfSAvLyBVbmRvIHRoZSBub25saW5lYXIgZnVuY3Rpb25cblxuXG4gICAgICAgIGNvbnN0IHlMID0gKGwgKyAxNikgLyAxMTY7XG4gICAgICAgIGNvbnN0IHhMID0gYSAvIDUwMCArIHlMO1xuICAgICAgICBjb25zdCB6TCA9IHlMIC0gYiAvIDIwMDsgLy8gR2V0IHRoZSB4eXogdmFsdWVzXG5cbiAgICAgICAgY29uc3QgY3QgPSAxNiAvIDExNjtcbiAgICAgICAgY29uc3QgbXggPSAwLjAwODg1NjtcbiAgICAgICAgY29uc3Qgbm0gPSA3Ljc4NztcbiAgICAgICAgeCA9IDAuOTUwNDcgKiAoeEwgKiogMyA+IG14ID8geEwgKiogMyA6ICh4TCAtIGN0KSAvIG5tKTtcbiAgICAgICAgeSA9IDEuMDAwMDAgKiAoeUwgKiogMyA+IG14ID8geUwgKiogMyA6ICh5TCAtIGN0KSAvIG5tKTtcbiAgICAgICAgeiA9IDEuMDg4ODMgKiAoekwgKiogMyA+IG14ID8gekwgKiogMyA6ICh6TCAtIGN0KSAvIG5tKTtcbiAgICAgIH0gLy8gQ29udmVydCB4eXogdG8gdW5ib3VuZGVkIHJnYiB2YWx1ZXNcblxuXG4gICAgICBjb25zdCByVSA9IHggKiAzLjI0MDYgKyB5ICogLTEuNTM3MiArIHogKiAtMC40OTg2O1xuICAgICAgY29uc3QgZ1UgPSB4ICogLTAuOTY4OSArIHkgKiAxLjg3NTggKyB6ICogMC4wNDE1O1xuICAgICAgY29uc3QgYlUgPSB4ICogMC4wNTU3ICsgeSAqIC0wLjIwNDAgKyB6ICogMS4wNTcwOyAvLyBDb252ZXJ0IHRoZSB2YWx1ZXMgdG8gdHJ1ZSByZ2IgdmFsdWVzXG5cbiAgICAgIGNvbnN0IHBvdyA9IE1hdGgucG93O1xuICAgICAgY29uc3QgYmQgPSAwLjAwMzEzMDg7XG4gICAgICBjb25zdCByID0gclUgPiBiZCA/IDEuMDU1ICogcG93KHJVLCAxIC8gMi40KSAtIDAuMDU1IDogMTIuOTIgKiByVTtcbiAgICAgIGNvbnN0IGcgPSBnVSA+IGJkID8gMS4wNTUgKiBwb3coZ1UsIDEgLyAyLjQpIC0gMC4wNTUgOiAxMi45MiAqIGdVO1xuICAgICAgY29uc3QgYiA9IGJVID4gYmQgPyAxLjA1NSAqIHBvdyhiVSwgMSAvIDIuNCkgLSAwLjA1NSA6IDEyLjkyICogYlU7IC8vIE1ha2UgYW5kIHJldHVybiB0aGUgY29sb3JcblxuICAgICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IoMjU1ICogciwgMjU1ICogZywgMjU1ICogYik7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNwYWNlID09PSAnaHNsJykge1xuICAgICAgLy8gaHR0cHM6Ly9iZ3JpbnMuZ2l0aHViLmlvL1RpbnlDb2xvci9kb2NzL3Rpbnljb2xvci5odG1sXG4gICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgaHNsIHZhbHVlc1xuICAgICAgbGV0IHtcbiAgICAgICAgaCxcbiAgICAgICAgcyxcbiAgICAgICAgbFxuICAgICAgfSA9IHRoaXM7XG4gICAgICBoIC89IDM2MDtcbiAgICAgIHMgLz0gMTAwO1xuICAgICAgbCAvPSAxMDA7IC8vIElmIHdlIGFyZSBncmV5LCB0aGVuIGp1c3QgbWFrZSB0aGUgY29sb3IgZGlyZWN0bHlcblxuICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgbCAqPSAyNTU7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGwsIGwsIGwpO1xuICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICB9IC8vIFRPRE8gSSBoYXZlIG5vIGlkZWEgd2hhdCB0aGlzIGRvZXMgOkQgSWYgeW91IGZpZ3VyZSBpdCBvdXQsIHRlbGwgbWUhXG5cblxuICAgICAgY29uc3QgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICBjb25zdCBwID0gMiAqIGwgLSBxOyAvLyBHZXQgdGhlIHJnYiB2YWx1ZXNcblxuICAgICAgY29uc3QgciA9IDI1NSAqIGh1ZVRvUmdiKHAsIHEsIGggKyAxIC8gMyk7XG4gICAgICBjb25zdCBnID0gMjU1ICogaHVlVG9SZ2IocCwgcSwgaCk7XG4gICAgICBjb25zdCBiID0gMjU1ICogaHVlVG9SZ2IocCwgcSwgaCAtIDEgLyAzKTsgLy8gTWFrZSBhIG5ldyBjb2xvclxuXG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihyLCBnLCBiKTtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3BhY2UgPT09ICdjbXlrJykge1xuICAgICAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZmVsaXBlc2FiaW5vLzUwNjYzMzZcbiAgICAgIC8vIEdldCB0aGUgbm9ybWFsaXNlZCBjbXlrIHZhbHVlc1xuICAgICAgY29uc3Qge1xuICAgICAgICBjLFxuICAgICAgICBtLFxuICAgICAgICB5LFxuICAgICAgICBrXG4gICAgICB9ID0gdGhpczsgLy8gR2V0IHRoZSByZ2IgdmFsdWVzXG5cbiAgICAgIGNvbnN0IHIgPSAyNTUgKiAoMSAtIE1hdGgubWluKDEsIGMgKiAoMSAtIGspICsgaykpO1xuICAgICAgY29uc3QgZyA9IDI1NSAqICgxIC0gTWF0aC5taW4oMSwgbSAqICgxIC0gaykgKyBrKSk7XG4gICAgICBjb25zdCBiID0gMjU1ICogKDEgLSBNYXRoLm1pbigxLCB5ICogKDEgLSBrKSArIGspKTsgLy8gRm9ybSB0aGUgY29sb3IgYW5kIHJldHVybiBpdFxuXG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihyLCBnLCBiKTtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdG9BcnJheSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBfYSxcbiAgICAgIF9iLFxuICAgICAgX2MsXG4gICAgICBfZCxcbiAgICAgIHNwYWNlXG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIFtfYSwgX2IsIF9jLCBfZCwgc3BhY2VdO1xuICB9XG5cbiAgdG9IZXgoKSB7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy5fY2xhbXBlZCgpLm1hcChjb21wb25lbnRIZXgpO1xuXG4gICAgcmV0dXJuIGAjJHtyfSR7Z30ke2J9YDtcbiAgfVxuXG4gIHRvUmdiKCkge1xuICAgIGNvbnN0IFtyViwgZ1YsIGJWXSA9IHRoaXMuX2NsYW1wZWQoKTtcblxuICAgIGNvbnN0IHN0cmluZyA9IGByZ2IoJHtyVn0sJHtnVn0sJHtiVn0pYDtcbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9IZXgoKTtcbiAgfVxuXG4gIHh5eigpIHtcbiAgICAvLyBOb3JtYWxpc2UgdGhlIHJlZCwgZ3JlZW4gYW5kIGJsdWUgdmFsdWVzXG4gICAgY29uc3Qge1xuICAgICAgX2E6IHIyNTUsXG4gICAgICBfYjogZzI1NSxcbiAgICAgIF9jOiBiMjU1XG4gICAgfSA9IHRoaXMucmdiKCk7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gW3IyNTUsIGcyNTUsIGIyNTVdLm1hcCh2ID0+IHYgLyAyNTUpOyAvLyBDb252ZXJ0IHRvIHRoZSBsYWIgcmdiIHNwYWNlXG5cbiAgICBjb25zdCByTCA9IHIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKHIgKyAwLjA1NSkgLyAxLjA1NSwgMi40KSA6IHIgLyAxMi45MjtcbiAgICBjb25zdCBnTCA9IGcgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKGcgKyAwLjA1NSkgLyAxLjA1NSwgMi40KSA6IGcgLyAxMi45MjtcbiAgICBjb25zdCBiTCA9IGIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKGIgKyAwLjA1NSkgLyAxLjA1NSwgMi40KSA6IGIgLyAxMi45MjsgLy8gQ29udmVydCB0byB0aGUgeHl6IGNvbG9yIHNwYWNlIHdpdGhvdXQgYm91bmRpbmcgdGhlIHZhbHVlc1xuXG4gICAgY29uc3QgeFUgPSAockwgKiAwLjQxMjQgKyBnTCAqIDAuMzU3NiArIGJMICogMC4xODA1KSAvIDAuOTUwNDc7XG4gICAgY29uc3QgeVUgPSAockwgKiAwLjIxMjYgKyBnTCAqIDAuNzE1MiArIGJMICogMC4wNzIyKSAvIDEuMDAwMDA7XG4gICAgY29uc3QgelUgPSAockwgKiAwLjAxOTMgKyBnTCAqIDAuMTE5MiArIGJMICogMC45NTA1KSAvIDEuMDg4ODM7IC8vIEdldCB0aGUgcHJvcGVyIHh5eiB2YWx1ZXMgYnkgYXBwbHlpbmcgdGhlIGJvdW5kaW5nXG5cbiAgICBjb25zdCB4ID0geFUgPiAwLjAwODg1NiA/IE1hdGgucG93KHhVLCAxIC8gMykgOiA3Ljc4NyAqIHhVICsgMTYgLyAxMTY7XG4gICAgY29uc3QgeSA9IHlVID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5VSwgMSAvIDMpIDogNy43ODcgKiB5VSArIDE2IC8gMTE2O1xuICAgIGNvbnN0IHogPSB6VSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coelUsIDEgLyAzKSA6IDcuNzg3ICogelUgKyAxNiAvIDExNjsgLy8gTWFrZSBhbmQgcmV0dXJuIHRoZSBjb2xvclxuXG4gICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IoeCwgeSwgeiwgJ3h5eicpO1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuICAvKlxuICBJbnB1dCBhbmQgT3V0cHV0IG1ldGhvZHNcbiAgKi9cblxuXG4gIF9jbGFtcGVkKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIF9hLFxuICAgICAgX2IsXG4gICAgICBfY1xuICAgIH0gPSB0aGlzLnJnYigpO1xuICAgIGNvbnN0IHtcbiAgICAgIG1heCxcbiAgICAgIG1pbixcbiAgICAgIHJvdW5kXG4gICAgfSA9IE1hdGg7XG5cbiAgICBjb25zdCBmb3JtYXQgPSB2ID0+IG1heCgwLCBtaW4ocm91bmQodiksIDI1NSkpO1xuXG4gICAgcmV0dXJuIFtfYSwgX2IsIF9jXS5tYXAoZm9ybWF0KTtcbiAgfVxuICAvKlxuICBDb25zdHJ1Y3RpbmcgY29sb3JzXG4gICovXG5cblxufVxuXG5jbGFzcyBQb2ludCB7XG4gIC8vIEluaXRpYWxpemVcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHRoaXMuaW5pdCguLi5hcmdzKTtcbiAgfSAvLyBDbG9uZSBwb2ludFxuXG5cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzKTtcbiAgfVxuXG4gIGluaXQoeCwgeSkge1xuICAgIGNvbnN0IGJhc2UgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07IC8vIGVuc3VyZSBzb3VyY2UgYXMgb2JqZWN0XG5cbiAgICBjb25zdCBzb3VyY2UgPSBBcnJheS5pc0FycmF5KHgpID8ge1xuICAgICAgeDogeFswXSxcbiAgICAgIHk6IHhbMV1cbiAgICB9IDogdHlwZW9mIHggPT09ICdvYmplY3QnID8ge1xuICAgICAgeDogeC54LFxuICAgICAgeTogeC55XG4gICAgfSA6IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfTsgLy8gbWVyZ2Ugc291cmNlXG5cbiAgICB0aGlzLnggPSBzb3VyY2UueCA9PSBudWxsID8gYmFzZS54IDogc291cmNlLng7XG4gICAgdGhpcy55ID0gc291cmNlLnkgPT0gbnVsbCA/IGJhc2UueSA6IHNvdXJjZS55O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gW3RoaXMueCwgdGhpcy55XTtcbiAgfVxuXG4gIHRyYW5zZm9ybShtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS50cmFuc2Zvcm1PKG0pO1xuICB9IC8vIFRyYW5zZm9ybSBwb2ludCB3aXRoIG1hdHJpeFxuXG5cbiAgdHJhbnNmb3JtTyhtKSB7XG4gICAgaWYgKCFNYXRyaXguaXNNYXRyaXhMaWtlKG0pKSB7XG4gICAgICBtID0gbmV3IE1hdHJpeChtKTtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSB0aGlzOyAvLyBQZXJmb3JtIHRoZSBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICAgIHRoaXMueCA9IG0uYSAqIHggKyBtLmMgKiB5ICsgbS5lO1xuICAgIHRoaXMueSA9IG0uYiAqIHggKyBtLmQgKiB5ICsgbS5mO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn1cbmZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgcmV0dXJuIG5ldyBQb2ludCh4LCB5KS50cmFuc2Zvcm1PKHRoaXMuc2NyZWVuQ1RNKCkuaW52ZXJzZU8oKSk7XG59XG5cbmZ1bmN0aW9uIGNsb3NlRW5vdWdoKGEsIGIsIHRocmVzaG9sZCkge1xuICByZXR1cm4gTWF0aC5hYnMoYiAtIGEpIDwgKHRocmVzaG9sZCB8fCAxZS02KTtcbn1cblxuY2xhc3MgTWF0cml4IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHRoaXMuaW5pdCguLi5hcmdzKTtcbiAgfVxuXG4gIHN0YXRpYyBmb3JtYXRUcmFuc2Zvcm1zKG8pIHtcbiAgICAvLyBHZXQgYWxsIG9mIHRoZSBwYXJhbWV0ZXJzIHJlcXVpcmVkIHRvIGZvcm0gdGhlIG1hdHJpeFxuICAgIGNvbnN0IGZsaXBCb3RoID0gby5mbGlwID09PSAnYm90aCcgfHwgby5mbGlwID09PSB0cnVlO1xuICAgIGNvbnN0IGZsaXBYID0gby5mbGlwICYmIChmbGlwQm90aCB8fCBvLmZsaXAgPT09ICd4JykgPyAtMSA6IDE7XG4gICAgY29uc3QgZmxpcFkgPSBvLmZsaXAgJiYgKGZsaXBCb3RoIHx8IG8uZmxpcCA9PT0gJ3knKSA/IC0xIDogMTtcbiAgICBjb25zdCBza2V3WCA9IG8uc2tldyAmJiBvLnNrZXcubGVuZ3RoID8gby5za2V3WzBdIDogaXNGaW5pdGUoby5za2V3KSA/IG8uc2tldyA6IGlzRmluaXRlKG8uc2tld1gpID8gby5za2V3WCA6IDA7XG4gICAgY29uc3Qgc2tld1kgPSBvLnNrZXcgJiYgby5za2V3Lmxlbmd0aCA/IG8uc2tld1sxXSA6IGlzRmluaXRlKG8uc2tldykgPyBvLnNrZXcgOiBpc0Zpbml0ZShvLnNrZXdZKSA/IG8uc2tld1kgOiAwO1xuICAgIGNvbnN0IHNjYWxlWCA9IG8uc2NhbGUgJiYgby5zY2FsZS5sZW5ndGggPyBvLnNjYWxlWzBdICogZmxpcFggOiBpc0Zpbml0ZShvLnNjYWxlKSA/IG8uc2NhbGUgKiBmbGlwWCA6IGlzRmluaXRlKG8uc2NhbGVYKSA/IG8uc2NhbGVYICogZmxpcFggOiBmbGlwWDtcbiAgICBjb25zdCBzY2FsZVkgPSBvLnNjYWxlICYmIG8uc2NhbGUubGVuZ3RoID8gby5zY2FsZVsxXSAqIGZsaXBZIDogaXNGaW5pdGUoby5zY2FsZSkgPyBvLnNjYWxlICogZmxpcFkgOiBpc0Zpbml0ZShvLnNjYWxlWSkgPyBvLnNjYWxlWSAqIGZsaXBZIDogZmxpcFk7XG4gICAgY29uc3Qgc2hlYXIgPSBvLnNoZWFyIHx8IDA7XG4gICAgY29uc3QgdGhldGEgPSBvLnJvdGF0ZSB8fCBvLnRoZXRhIHx8IDA7XG4gICAgY29uc3Qgb3JpZ2luID0gbmV3IFBvaW50KG8ub3JpZ2luIHx8IG8uYXJvdW5kIHx8IG8ub3ggfHwgby5vcmlnaW5YLCBvLm95IHx8IG8ub3JpZ2luWSk7XG4gICAgY29uc3Qgb3ggPSBvcmlnaW4ueDtcbiAgICBjb25zdCBveSA9IG9yaWdpbi55OyAvLyBXZSBuZWVkIFBvaW50IHRvIGJlIGludmFsaWQgaWYgbm90aGluZyB3YXMgcGFzc2VkIGJlY2F1c2Ugd2UgY2Fubm90IGRlZmF1bHQgdG8gMCBoZXJlLiBUaGF0IGlzIHdoeSBOYU5cblxuICAgIGNvbnN0IHBvc2l0aW9uID0gbmV3IFBvaW50KG8ucG9zaXRpb24gfHwgby5weCB8fCBvLnBvc2l0aW9uWCB8fCBOYU4sIG8ucHkgfHwgby5wb3NpdGlvblkgfHwgTmFOKTtcbiAgICBjb25zdCBweCA9IHBvc2l0aW9uLng7XG4gICAgY29uc3QgcHkgPSBwb3NpdGlvbi55O1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IG5ldyBQb2ludChvLnRyYW5zbGF0ZSB8fCBvLnR4IHx8IG8udHJhbnNsYXRlWCwgby50eSB8fCBvLnRyYW5zbGF0ZVkpO1xuICAgIGNvbnN0IHR4ID0gdHJhbnNsYXRlLng7XG4gICAgY29uc3QgdHkgPSB0cmFuc2xhdGUueTtcbiAgICBjb25zdCByZWxhdGl2ZSA9IG5ldyBQb2ludChvLnJlbGF0aXZlIHx8IG8ucnggfHwgby5yZWxhdGl2ZVgsIG8ucnkgfHwgby5yZWxhdGl2ZVkpO1xuICAgIGNvbnN0IHJ4ID0gcmVsYXRpdmUueDtcbiAgICBjb25zdCByeSA9IHJlbGF0aXZlLnk7IC8vIFBvcHVsYXRlIGFsbCBvZiB0aGUgdmFsdWVzXG5cbiAgICByZXR1cm4ge1xuICAgICAgc2NhbGVYLFxuICAgICAgc2NhbGVZLFxuICAgICAgc2tld1gsXG4gICAgICBza2V3WSxcbiAgICAgIHNoZWFyLFxuICAgICAgdGhldGEsXG4gICAgICByeCxcbiAgICAgIHJ5LFxuICAgICAgdHgsXG4gICAgICB0eSxcbiAgICAgIG94LFxuICAgICAgb3ksXG4gICAgICBweCxcbiAgICAgIHB5XG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tQXJyYXkoYSkge1xuICAgIHJldHVybiB7XG4gICAgICBhOiBhWzBdLFxuICAgICAgYjogYVsxXSxcbiAgICAgIGM6IGFbMl0sXG4gICAgICBkOiBhWzNdLFxuICAgICAgZTogYVs0XSxcbiAgICAgIGY6IGFbNV1cbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGlzTWF0cml4TGlrZShvKSB7XG4gICAgcmV0dXJuIG8uYSAhPSBudWxsIHx8IG8uYiAhPSBudWxsIHx8IG8uYyAhPSBudWxsIHx8IG8uZCAhPSBudWxsIHx8IG8uZSAhPSBudWxsIHx8IG8uZiAhPSBudWxsO1xuICB9IC8vIGxlZnQgbWF0cml4LCByaWdodCBtYXRyaXgsIHRhcmdldCBtYXRyaXggd2hpY2ggaXMgb3ZlcndyaXR0ZW5cblxuXG4gIHN0YXRpYyBtYXRyaXhNdWx0aXBseShsLCByLCBvKSB7XG4gICAgLy8gV29yayBvdXQgdGhlIHByb2R1Y3QgZGlyZWN0bHlcbiAgICBjb25zdCBhID0gbC5hICogci5hICsgbC5jICogci5iO1xuICAgIGNvbnN0IGIgPSBsLmIgKiByLmEgKyBsLmQgKiByLmI7XG4gICAgY29uc3QgYyA9IGwuYSAqIHIuYyArIGwuYyAqIHIuZDtcbiAgICBjb25zdCBkID0gbC5iICogci5jICsgbC5kICogci5kO1xuICAgIGNvbnN0IGUgPSBsLmUgKyBsLmEgKiByLmUgKyBsLmMgKiByLmY7XG4gICAgY29uc3QgZiA9IGwuZiArIGwuYiAqIHIuZSArIGwuZCAqIHIuZjsgLy8gbWFrZSBzdXJlIHRvIHVzZSBsb2NhbCB2YXJpYWJsZXMgYmVjYXVzZSBsL3IgYW5kIG8gY291bGQgYmUgdGhlIHNhbWVcblxuICAgIG8uYSA9IGE7XG4gICAgby5iID0gYjtcbiAgICBvLmMgPSBjO1xuICAgIG8uZCA9IGQ7XG4gICAgby5lID0gZTtcbiAgICBvLmYgPSBmO1xuICAgIHJldHVybiBvO1xuICB9XG5cbiAgYXJvdW5kKGN4LCBjeSwgbWF0cml4KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5hcm91bmRPKGN4LCBjeSwgbWF0cml4KTtcbiAgfSAvLyBUcmFuc2Zvcm0gYXJvdW5kIGEgY2VudGVyIHBvaW50XG5cblxuICBhcm91bmRPKGN4LCBjeSwgbWF0cml4KSB7XG4gICAgY29uc3QgZHggPSBjeCB8fCAwO1xuICAgIGNvbnN0IGR5ID0gY3kgfHwgMDtcbiAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVPKC1keCwgLWR5KS5sbXVsdGlwbHlPKG1hdHJpeCkudHJhbnNsYXRlTyhkeCwgZHkpO1xuICB9IC8vIENsb25lcyB0aGlzIG1hdHJpeFxuXG5cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXRyaXgodGhpcyk7XG4gIH0gLy8gRGVjb21wb3NlcyB0aGlzIG1hdHJpeCBpbnRvIGl0cyBhZmZpbmUgcGFyYW1ldGVyc1xuXG5cbiAgZGVjb21wb3NlKGN4ID0gMCwgY3kgPSAwKSB7XG4gICAgLy8gR2V0IHRoZSBwYXJhbWV0ZXJzIGZyb20gdGhlIG1hdHJpeFxuICAgIGNvbnN0IGEgPSB0aGlzLmE7XG4gICAgY29uc3QgYiA9IHRoaXMuYjtcbiAgICBjb25zdCBjID0gdGhpcy5jO1xuICAgIGNvbnN0IGQgPSB0aGlzLmQ7XG4gICAgY29uc3QgZSA9IHRoaXMuZTtcbiAgICBjb25zdCBmID0gdGhpcy5mOyAvLyBGaWd1cmUgb3V0IGlmIHRoZSB3aW5kaW5nIGRpcmVjdGlvbiBpcyBjbG9ja3dpc2Ugb3IgY291bnRlcmNsb2Nrd2lzZVxuXG4gICAgY29uc3QgZGV0ZXJtaW5hbnQgPSBhICogZCAtIGIgKiBjO1xuICAgIGNvbnN0IGNjdyA9IGRldGVybWluYW50ID4gMCA/IDEgOiAtMTsgLy8gU2luY2Ugd2Ugb25seSBzaGVhciBpbiB4LCB3ZSBjYW4gdXNlIHRoZSB4IGJhc2lzIHRvIGdldCB0aGUgeCBzY2FsZVxuICAgIC8vIGFuZCB0aGUgcm90YXRpb24gb2YgdGhlIHJlc3VsdGluZyBtYXRyaXhcblxuICAgIGNvbnN0IHN4ID0gY2N3ICogTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgIGNvbnN0IHRoZXRhUmFkID0gTWF0aC5hdGFuMihjY3cgKiBiLCBjY3cgKiBhKTtcbiAgICBjb25zdCB0aGV0YSA9IDE4MCAvIE1hdGguUEkgKiB0aGV0YVJhZDtcbiAgICBjb25zdCBjdCA9IE1hdGguY29zKHRoZXRhUmFkKTtcbiAgICBjb25zdCBzdCA9IE1hdGguc2luKHRoZXRhUmFkKTsgLy8gV2UgY2FuIHRoZW4gc29sdmUgdGhlIHkgYmFzaXMgdmVjdG9yIHNpbXVsdGFuZW91c2x5IHRvIGdldCB0aGUgb3RoZXJcbiAgICAvLyB0d28gYWZmaW5lIHBhcmFtZXRlcnMgZGlyZWN0bHkgZnJvbSB0aGVzZSBwYXJhbWV0ZXJzXG5cbiAgICBjb25zdCBsYW0gPSAoYSAqIGMgKyBiICogZCkgLyBkZXRlcm1pbmFudDtcbiAgICBjb25zdCBzeSA9IGMgKiBzeCAvIChsYW0gKiBhIC0gYikgfHwgZCAqIHN4IC8gKGxhbSAqIGIgKyBhKTsgLy8gVXNlIHRoZSB0cmFuc2xhdGlvbnNcblxuICAgIGNvbnN0IHR4ID0gZSAtIGN4ICsgY3ggKiBjdCAqIHN4ICsgY3kgKiAobGFtICogY3QgKiBzeCAtIHN0ICogc3kpO1xuICAgIGNvbnN0IHR5ID0gZiAtIGN5ICsgY3ggKiBzdCAqIHN4ICsgY3kgKiAobGFtICogc3QgKiBzeCArIGN0ICogc3kpOyAvLyBDb25zdHJ1Y3QgdGhlIGRlY29tcG9zaXRpb24gYW5kIHJldHVybiBpdFxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFJldHVybiB0aGUgYWZmaW5lIHBhcmFtZXRlcnNcbiAgICAgIHNjYWxlWDogc3gsXG4gICAgICBzY2FsZVk6IHN5LFxuICAgICAgc2hlYXI6IGxhbSxcbiAgICAgIHJvdGF0ZTogdGhldGEsXG4gICAgICB0cmFuc2xhdGVYOiB0eCxcbiAgICAgIHRyYW5zbGF0ZVk6IHR5LFxuICAgICAgb3JpZ2luWDogY3gsXG4gICAgICBvcmlnaW5ZOiBjeSxcbiAgICAgIC8vIFJldHVybiB0aGUgbWF0cml4IHBhcmFtZXRlcnNcbiAgICAgIGE6IHRoaXMuYSxcbiAgICAgIGI6IHRoaXMuYixcbiAgICAgIGM6IHRoaXMuYyxcbiAgICAgIGQ6IHRoaXMuZCxcbiAgICAgIGU6IHRoaXMuZSxcbiAgICAgIGY6IHRoaXMuZlxuICAgIH07XG4gIH0gLy8gQ2hlY2sgaWYgdHdvIG1hdHJpY2VzIGFyZSBlcXVhbFxuXG5cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKG90aGVyID09PSB0aGlzKSByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBjb21wID0gbmV3IE1hdHJpeChvdGhlcik7XG4gICAgcmV0dXJuIGNsb3NlRW5vdWdoKHRoaXMuYSwgY29tcC5hKSAmJiBjbG9zZUVub3VnaCh0aGlzLmIsIGNvbXAuYikgJiYgY2xvc2VFbm91Z2godGhpcy5jLCBjb21wLmMpICYmIGNsb3NlRW5vdWdoKHRoaXMuZCwgY29tcC5kKSAmJiBjbG9zZUVub3VnaCh0aGlzLmUsIGNvbXAuZSkgJiYgY2xvc2VFbm91Z2godGhpcy5mLCBjb21wLmYpO1xuICB9IC8vIEZsaXAgbWF0cml4IG9uIHggb3IgeSwgYXQgYSBnaXZlbiBvZmZzZXRcblxuXG4gIGZsaXAoYXhpcywgYXJvdW5kKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5mbGlwTyhheGlzLCBhcm91bmQpO1xuICB9XG5cbiAgZmxpcE8oYXhpcywgYXJvdW5kKSB7XG4gICAgcmV0dXJuIGF4aXMgPT09ICd4JyA/IHRoaXMuc2NhbGVPKC0xLCAxLCBhcm91bmQsIDApIDogYXhpcyA9PT0gJ3knID8gdGhpcy5zY2FsZU8oMSwgLTEsIDAsIGFyb3VuZCkgOiB0aGlzLnNjYWxlTygtMSwgLTEsIGF4aXMsIGFyb3VuZCB8fCBheGlzKTsgLy8gRGVmaW5lIGFuIHgsIHkgZmxpcCBwb2ludFxuICB9IC8vIEluaXRpYWxpemVcblxuXG4gIGluaXQoc291cmNlKSB7XG4gICAgY29uc3QgYmFzZSA9IE1hdHJpeC5mcm9tQXJyYXkoWzEsIDAsIDAsIDEsIDAsIDBdKTsgLy8gZW5zdXJlIHNvdXJjZSBhcyBvYmplY3RcblxuICAgIHNvdXJjZSA9IHNvdXJjZSBpbnN0YW5jZW9mIEVsZW1lbnQgPyBzb3VyY2UubWF0cml4aWZ5KCkgOiB0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyA/IE1hdHJpeC5mcm9tQXJyYXkoc291cmNlLnNwbGl0KGRlbGltaXRlcikubWFwKHBhcnNlRmxvYXQpKSA6IEFycmF5LmlzQXJyYXkoc291cmNlKSA/IE1hdHJpeC5mcm9tQXJyYXkoc291cmNlKSA6IHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnICYmIE1hdHJpeC5pc01hdHJpeExpa2Uoc291cmNlKSA/IHNvdXJjZSA6IHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnID8gbmV3IE1hdHJpeCgpLnRyYW5zZm9ybShzb3VyY2UpIDogYXJndW1lbnRzLmxlbmd0aCA9PT0gNiA/IE1hdHJpeC5mcm9tQXJyYXkoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKSA6IGJhc2U7IC8vIE1lcmdlIHRoZSBzb3VyY2UgbWF0cml4IHdpdGggdGhlIGJhc2UgbWF0cml4XG5cbiAgICB0aGlzLmEgPSBzb3VyY2UuYSAhPSBudWxsID8gc291cmNlLmEgOiBiYXNlLmE7XG4gICAgdGhpcy5iID0gc291cmNlLmIgIT0gbnVsbCA/IHNvdXJjZS5iIDogYmFzZS5iO1xuICAgIHRoaXMuYyA9IHNvdXJjZS5jICE9IG51bGwgPyBzb3VyY2UuYyA6IGJhc2UuYztcbiAgICB0aGlzLmQgPSBzb3VyY2UuZCAhPSBudWxsID8gc291cmNlLmQgOiBiYXNlLmQ7XG4gICAgdGhpcy5lID0gc291cmNlLmUgIT0gbnVsbCA/IHNvdXJjZS5lIDogYmFzZS5lO1xuICAgIHRoaXMuZiA9IHNvdXJjZS5mICE9IG51bGwgPyBzb3VyY2UuZiA6IGJhc2UuZjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGludmVyc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbnZlcnNlTygpO1xuICB9IC8vIEludmVyc2VzIG1hdHJpeFxuXG5cbiAgaW52ZXJzZU8oKSB7XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IHBhcmFtZXRlcnMgb3V0IG9mIHRoZSBtYXRyaXhcbiAgICBjb25zdCBhID0gdGhpcy5hO1xuICAgIGNvbnN0IGIgPSB0aGlzLmI7XG4gICAgY29uc3QgYyA9IHRoaXMuYztcbiAgICBjb25zdCBkID0gdGhpcy5kO1xuICAgIGNvbnN0IGUgPSB0aGlzLmU7XG4gICAgY29uc3QgZiA9IHRoaXMuZjsgLy8gSW52ZXJ0IHRoZSAyeDIgbWF0cml4IGluIHRoZSB0b3AgbGVmdFxuXG4gICAgY29uc3QgZGV0ID0gYSAqIGQgLSBiICogYztcbiAgICBpZiAoIWRldCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52ZXJ0ICcgKyB0aGlzKTsgLy8gQ2FsY3VsYXRlIHRoZSB0b3AgMngyIG1hdHJpeFxuXG4gICAgY29uc3QgbmEgPSBkIC8gZGV0O1xuICAgIGNvbnN0IG5iID0gLWIgLyBkZXQ7XG4gICAgY29uc3QgbmMgPSAtYyAvIGRldDtcbiAgICBjb25zdCBuZCA9IGEgLyBkZXQ7IC8vIEFwcGx5IHRoZSBpbnZlcnRlZCBtYXRyaXggdG8gdGhlIHRvcCByaWdodFxuXG4gICAgY29uc3QgbmUgPSAtKG5hICogZSArIG5jICogZik7XG4gICAgY29uc3QgbmYgPSAtKG5iICogZSArIG5kICogZik7IC8vIENvbnN0cnVjdCB0aGUgaW52ZXJ0ZWQgbWF0cml4XG5cbiAgICB0aGlzLmEgPSBuYTtcbiAgICB0aGlzLmIgPSBuYjtcbiAgICB0aGlzLmMgPSBuYztcbiAgICB0aGlzLmQgPSBuZDtcbiAgICB0aGlzLmUgPSBuZTtcbiAgICB0aGlzLmYgPSBuZjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxtdWx0aXBseShtYXRyaXgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxtdWx0aXBseU8obWF0cml4KTtcbiAgfVxuXG4gIGxtdWx0aXBseU8obWF0cml4KSB7XG4gICAgY29uc3QgciA9IHRoaXM7XG4gICAgY29uc3QgbCA9IG1hdHJpeCBpbnN0YW5jZW9mIE1hdHJpeCA/IG1hdHJpeCA6IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gTWF0cml4Lm1hdHJpeE11bHRpcGx5KGwsIHIsIHRoaXMpO1xuICB9IC8vIExlZnQgbXVsdGlwbGllcyBieSB0aGUgZ2l2ZW4gbWF0cml4XG5cblxuICBtdWx0aXBseShtYXRyaXgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLm11bHRpcGx5TyhtYXRyaXgpO1xuICB9XG5cbiAgbXVsdGlwbHlPKG1hdHJpeCkge1xuICAgIC8vIEdldCB0aGUgbWF0cmljZXNcbiAgICBjb25zdCBsID0gdGhpcztcbiAgICBjb25zdCByID0gbWF0cml4IGluc3RhbmNlb2YgTWF0cml4ID8gbWF0cml4IDogbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBNYXRyaXgubWF0cml4TXVsdGlwbHkobCwgciwgdGhpcyk7XG4gIH0gLy8gUm90YXRlIG1hdHJpeFxuXG5cbiAgcm90YXRlKHIsIGN4LCBjeSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkucm90YXRlTyhyLCBjeCwgY3kpO1xuICB9XG5cbiAgcm90YXRlTyhyLCBjeCA9IDAsIGN5ID0gMCkge1xuICAgIC8vIENvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zXG4gICAgciA9IHJhZGlhbnMocik7XG4gICAgY29uc3QgY29zID0gTWF0aC5jb3Mocik7XG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4ocik7XG4gICAgY29uc3Qge1xuICAgICAgYSxcbiAgICAgIGIsXG4gICAgICBjLFxuICAgICAgZCxcbiAgICAgIGUsXG4gICAgICBmXG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy5hID0gYSAqIGNvcyAtIGIgKiBzaW47XG4gICAgdGhpcy5iID0gYiAqIGNvcyArIGEgKiBzaW47XG4gICAgdGhpcy5jID0gYyAqIGNvcyAtIGQgKiBzaW47XG4gICAgdGhpcy5kID0gZCAqIGNvcyArIGMgKiBzaW47XG4gICAgdGhpcy5lID0gZSAqIGNvcyAtIGYgKiBzaW4gKyBjeSAqIHNpbiAtIGN4ICogY29zICsgY3g7XG4gICAgdGhpcy5mID0gZiAqIGNvcyArIGUgKiBzaW4gLSBjeCAqIHNpbiAtIGN5ICogY29zICsgY3k7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gU2NhbGUgbWF0cml4XG5cblxuICBzY2FsZSh4LCB5LCBjeCwgY3kpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnNjYWxlTyguLi5hcmd1bWVudHMpO1xuICB9XG5cbiAgc2NhbGVPKHgsIHkgPSB4LCBjeCA9IDAsIGN5ID0gMCkge1xuICAgIC8vIFN1cHBvcnQgdW5pZm9ybSBzY2FsaW5nXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGN5ID0gY3g7XG4gICAgICBjeCA9IHk7XG4gICAgICB5ID0geDtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBhLFxuICAgICAgYixcbiAgICAgIGMsXG4gICAgICBkLFxuICAgICAgZSxcbiAgICAgIGZcbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLmEgPSBhICogeDtcbiAgICB0aGlzLmIgPSBiICogeTtcbiAgICB0aGlzLmMgPSBjICogeDtcbiAgICB0aGlzLmQgPSBkICogeTtcbiAgICB0aGlzLmUgPSBlICogeCAtIGN4ICogeCArIGN4O1xuICAgIHRoaXMuZiA9IGYgKiB5IC0gY3kgKiB5ICsgY3k7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gU2hlYXIgbWF0cml4XG5cblxuICBzaGVhcihhLCBjeCwgY3kpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnNoZWFyTyhhLCBjeCwgY3kpO1xuICB9XG5cbiAgc2hlYXJPKGx4LCBjeCA9IDAsIGN5ID0gMCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGEsXG4gICAgICBiLFxuICAgICAgYyxcbiAgICAgIGQsXG4gICAgICBlLFxuICAgICAgZlxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMuYSA9IGEgKyBiICogbHg7XG4gICAgdGhpcy5jID0gYyArIGQgKiBseDtcbiAgICB0aGlzLmUgPSBlICsgZiAqIGx4IC0gY3kgKiBseDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBTa2V3IE1hdHJpeFxuXG5cbiAgc2tldyh4LCB5LCBjeCwgY3kpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnNrZXdPKC4uLmFyZ3VtZW50cyk7XG4gIH1cblxuICBza2V3Tyh4LCB5ID0geCwgY3ggPSAwLCBjeSA9IDApIHtcbiAgICAvLyBzdXBwb3J0IHVuaWZvcm1hbCBza2V3XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGN5ID0gY3g7XG4gICAgICBjeCA9IHk7XG4gICAgICB5ID0geDtcbiAgICB9IC8vIENvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zXG5cblxuICAgIHggPSByYWRpYW5zKHgpO1xuICAgIHkgPSByYWRpYW5zKHkpO1xuICAgIGNvbnN0IGx4ID0gTWF0aC50YW4oeCk7XG4gICAgY29uc3QgbHkgPSBNYXRoLnRhbih5KTtcbiAgICBjb25zdCB7XG4gICAgICBhLFxuICAgICAgYixcbiAgICAgIGMsXG4gICAgICBkLFxuICAgICAgZSxcbiAgICAgIGZcbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLmEgPSBhICsgYiAqIGx4O1xuICAgIHRoaXMuYiA9IGIgKyBhICogbHk7XG4gICAgdGhpcy5jID0gYyArIGQgKiBseDtcbiAgICB0aGlzLmQgPSBkICsgYyAqIGx5O1xuICAgIHRoaXMuZSA9IGUgKyBmICogbHggLSBjeSAqIGx4O1xuICAgIHRoaXMuZiA9IGYgKyBlICogbHkgLSBjeCAqIGx5O1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIFNrZXdYXG5cblxuICBza2V3WCh4LCBjeCwgY3kpIHtcbiAgICByZXR1cm4gdGhpcy5za2V3KHgsIDAsIGN4LCBjeSk7XG4gIH0gLy8gU2tld1lcblxuXG4gIHNrZXdZKHksIGN4LCBjeSkge1xuICAgIHJldHVybiB0aGlzLnNrZXcoMCwgeSwgY3gsIGN5KTtcbiAgfVxuXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB0aGlzLmQsIHRoaXMuZSwgdGhpcy5mXTtcbiAgfSAvLyBDb252ZXJ0IG1hdHJpeCB0byBzdHJpbmdcblxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnbWF0cml4KCcgKyB0aGlzLmEgKyAnLCcgKyB0aGlzLmIgKyAnLCcgKyB0aGlzLmMgKyAnLCcgKyB0aGlzLmQgKyAnLCcgKyB0aGlzLmUgKyAnLCcgKyB0aGlzLmYgKyAnKSc7XG4gIH0gLy8gVHJhbnNmb3JtIGEgbWF0cml4IGludG8gYW5vdGhlciBtYXRyaXggYnkgbWFuaXB1bGF0aW5nIHRoZSBzcGFjZVxuXG5cbiAgdHJhbnNmb3JtKG8pIHtcbiAgICAvLyBDaGVjayBpZiBvIGlzIGEgbWF0cml4IGFuZCB0aGVuIGxlZnQgbXVsdGlwbHkgaXQgZGlyZWN0bHlcbiAgICBpZiAoTWF0cml4LmlzTWF0cml4TGlrZShvKSkge1xuICAgICAgY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeChvKTtcbiAgICAgIHJldHVybiBtYXRyaXgubXVsdGlwbHlPKHRoaXMpO1xuICAgIH0gLy8gR2V0IHRoZSBwcm9wb3NlZCB0cmFuc2Zvcm1hdGlvbnMgYW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uc1xuXG5cbiAgICBjb25zdCB0ID0gTWF0cml4LmZvcm1hdFRyYW5zZm9ybXMobyk7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgeDogb3gsXG4gICAgICB5OiBveVxuICAgIH0gPSBuZXcgUG9pbnQodC5veCwgdC5veSkudHJhbnNmb3JtKGN1cnJlbnQpOyAvLyBDb25zdHJ1Y3QgdGhlIHJlc3VsdGluZyBtYXRyaXhcblxuICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gbmV3IE1hdHJpeCgpLnRyYW5zbGF0ZU8odC5yeCwgdC5yeSkubG11bHRpcGx5TyhjdXJyZW50KS50cmFuc2xhdGVPKC1veCwgLW95KS5zY2FsZU8odC5zY2FsZVgsIHQuc2NhbGVZKS5za2V3Tyh0LnNrZXdYLCB0LnNrZXdZKS5zaGVhck8odC5zaGVhcikucm90YXRlTyh0LnRoZXRhKS50cmFuc2xhdGVPKG94LCBveSk7IC8vIElmIHdlIHdhbnQgdGhlIG9yaWdpbiBhdCBhIHBhcnRpY3VsYXIgcGxhY2UsIHdlIGZvcmNlIGl0IHRoZXJlXG5cbiAgICBpZiAoaXNGaW5pdGUodC5weCkgfHwgaXNGaW5pdGUodC5weSkpIHtcbiAgICAgIGNvbnN0IG9yaWdpbiA9IG5ldyBQb2ludChveCwgb3kpLnRyYW5zZm9ybSh0cmFuc2Zvcm1lcik7IC8vIFRPRE86IFJlcGxhY2UgdC5weCB3aXRoIGlzRmluaXRlKHQucHgpXG4gICAgICAvLyBEb2Vzbid0IHdvcmsgYmVjYXVzZSB0LnB4IGlzIGFsc28gMCBpZiBpdCB3YXNuJ3QgcGFzc2VkXG5cbiAgICAgIGNvbnN0IGR4ID0gaXNGaW5pdGUodC5weCkgPyB0LnB4IC0gb3JpZ2luLnggOiAwO1xuICAgICAgY29uc3QgZHkgPSBpc0Zpbml0ZSh0LnB5KSA/IHQucHkgLSBvcmlnaW4ueSA6IDA7XG4gICAgICB0cmFuc2Zvcm1lci50cmFuc2xhdGVPKGR4LCBkeSk7XG4gICAgfSAvLyBUcmFuc2xhdGUgbm93IGFmdGVyIHBvc2l0aW9uaW5nXG5cblxuICAgIHRyYW5zZm9ybWVyLnRyYW5zbGF0ZU8odC50eCwgdC50eSk7XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVyO1xuICB9IC8vIFRyYW5zbGF0ZSBtYXRyaXhcblxuXG4gIHRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS50cmFuc2xhdGVPKHgsIHkpO1xuICB9XG5cbiAgdHJhbnNsYXRlTyh4LCB5KSB7XG4gICAgdGhpcy5lICs9IHggfHwgMDtcbiAgICB0aGlzLmYgKz0geSB8fCAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFsdWVPZigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYTogdGhpcy5hLFxuICAgICAgYjogdGhpcy5iLFxuICAgICAgYzogdGhpcy5jLFxuICAgICAgZDogdGhpcy5kLFxuICAgICAgZTogdGhpcy5lLFxuICAgICAgZjogdGhpcy5mXG4gICAgfTtcbiAgfVxuXG59XG5mdW5jdGlvbiBjdG0oKSB7XG4gIHJldHVybiBuZXcgTWF0cml4KHRoaXMubm9kZS5nZXRDVE0oKSk7XG59XG5mdW5jdGlvbiBzY3JlZW5DVE0oKSB7XG4gIC8qIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzNDQ1MzdcbiAgICAgVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSBGRiBkb2VzIG5vdCByZXR1cm4gdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgICBmb3IgdGhlIGlubmVyIGNvb3JkaW5hdGUgc3lzdGVtIHdoZW4gZ2V0U2NyZWVuQ1RNKCkgaXMgY2FsbGVkIG9uIG5lc3RlZCBzdmdzLlxuICAgICBIb3dldmVyIGFsbCBvdGhlciBCcm93c2VycyBkbyB0aGF0ICovXG4gIGlmICh0eXBlb2YgdGhpcy5pc1Jvb3QgPT09ICdmdW5jdGlvbicgJiYgIXRoaXMuaXNSb290KCkpIHtcbiAgICBjb25zdCByZWN0ID0gdGhpcy5yZWN0KDEsIDEpO1xuICAgIGNvbnN0IG0gPSByZWN0Lm5vZGUuZ2V0U2NyZWVuQ1RNKCk7XG4gICAgcmVjdC5yZW1vdmUoKTtcbiAgICByZXR1cm4gbmV3IE1hdHJpeChtKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgTWF0cml4KHRoaXMubm9kZS5nZXRTY3JlZW5DVE0oKSk7XG59XG5yZWdpc3RlcihNYXRyaXgsICdNYXRyaXgnKTtcblxuZnVuY3Rpb24gcGFyc2VyKCkge1xuICAvLyBSZXVzZSBjYWNoZWQgZWxlbWVudCBpZiBwb3NzaWJsZVxuICBpZiAoIXBhcnNlci5ub2Rlcykge1xuICAgIGNvbnN0IHN2ZyA9IG1ha2VJbnN0YW5jZSgpLnNpemUoMiwgMCk7XG4gICAgc3ZnLm5vZGUuc3R5bGUuY3NzVGV4dCA9IFsnb3BhY2l0eTogMCcsICdwb3NpdGlvbjogYWJzb2x1dGUnLCAnbGVmdDogLTEwMCUnLCAndG9wOiAtMTAwJScsICdvdmVyZmxvdzogaGlkZGVuJ10uam9pbignOycpO1xuICAgIHN2Zy5hdHRyKCdmb2N1c2FibGUnLCAnZmFsc2UnKTtcbiAgICBzdmcuYXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIGNvbnN0IHBhdGggPSBzdmcucGF0aCgpLm5vZGU7XG4gICAgcGFyc2VyLm5vZGVzID0ge1xuICAgICAgc3ZnLFxuICAgICAgcGF0aFxuICAgIH07XG4gIH1cblxuICBpZiAoIXBhcnNlci5ub2Rlcy5zdmcubm9kZS5wYXJlbnROb2RlKSB7XG4gICAgY29uc3QgYiA9IGdsb2JhbHMuZG9jdW1lbnQuYm9keSB8fCBnbG9iYWxzLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICBwYXJzZXIubm9kZXMuc3ZnLmFkZFRvKGIpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlci5ub2Rlcztcbn1cblxuZnVuY3Rpb24gaXNOdWxsZWRCb3goYm94KSB7XG4gIHJldHVybiAhYm94LndpZHRoICYmICFib3guaGVpZ2h0ICYmICFib3gueCAmJiAhYm94Lnk7XG59XG5mdW5jdGlvbiBkb21Db250YWlucyhub2RlKSB7XG4gIHJldHVybiBub2RlID09PSBnbG9iYWxzLmRvY3VtZW50IHx8IChnbG9iYWxzLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyB8fCBmdW5jdGlvbiAobm9kZSkge1xuICAgIC8vIFRoaXMgaXMgSUUgLSBpdCBkb2VzIG5vdCBzdXBwb3J0IGNvbnRhaW5zKCkgZm9yIHRvcC1sZXZlbCBTVkdzXG4gICAgd2hpbGUgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZSA9PT0gZ2xvYmFscy5kb2N1bWVudDtcbiAgfSkuY2FsbChnbG9iYWxzLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XG59XG5jbGFzcyBCb3gge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgdGhpcy5pbml0KC4uLmFyZ3MpO1xuICB9XG5cbiAgYWRkT2Zmc2V0KCkge1xuICAgIC8vIG9mZnNldCBieSB3aW5kb3cgc2Nyb2xsIHBvc2l0aW9uLCBiZWNhdXNlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBjaGFuZ2VzIHdoZW4gd2luZG93IGlzIHNjcm9sbGVkXG4gICAgdGhpcy54ICs9IGdsb2JhbHMud2luZG93LnBhZ2VYT2Zmc2V0O1xuICAgIHRoaXMueSArPSBnbG9iYWxzLndpbmRvdy5wYWdlWU9mZnNldDtcbiAgICByZXR1cm4gbmV3IEJveCh0aGlzKTtcbiAgfVxuXG4gIGluaXQoc291cmNlKSB7XG4gICAgY29uc3QgYmFzZSA9IFswLCAwLCAwLCAwXTtcbiAgICBzb3VyY2UgPSB0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyA/IHNvdXJjZS5zcGxpdChkZWxpbWl0ZXIpLm1hcChwYXJzZUZsb2F0KSA6IEFycmF5LmlzQXJyYXkoc291cmNlKSA/IHNvdXJjZSA6IHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnID8gW3NvdXJjZS5sZWZ0ICE9IG51bGwgPyBzb3VyY2UubGVmdCA6IHNvdXJjZS54LCBzb3VyY2UudG9wICE9IG51bGwgPyBzb3VyY2UudG9wIDogc291cmNlLnksIHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodF0gOiBhcmd1bWVudHMubGVuZ3RoID09PSA0ID8gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpIDogYmFzZTtcbiAgICB0aGlzLnggPSBzb3VyY2VbMF0gfHwgMDtcbiAgICB0aGlzLnkgPSBzb3VyY2VbMV0gfHwgMDtcbiAgICB0aGlzLndpZHRoID0gdGhpcy53ID0gc291cmNlWzJdIHx8IDA7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmggPSBzb3VyY2VbM10gfHwgMDsgLy8gQWRkIG1vcmUgYm91bmRpbmcgYm94IHByb3BlcnRpZXNcblxuICAgIHRoaXMueDIgPSB0aGlzLnggKyB0aGlzLnc7XG4gICAgdGhpcy55MiA9IHRoaXMueSArIHRoaXMuaDtcbiAgICB0aGlzLmN4ID0gdGhpcy54ICsgdGhpcy53IC8gMjtcbiAgICB0aGlzLmN5ID0gdGhpcy55ICsgdGhpcy5oIC8gMjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlzTnVsbGVkKCkge1xuICAgIHJldHVybiBpc051bGxlZEJveCh0aGlzKTtcbiAgfSAvLyBNZXJnZSByZWN0IGJveCB3aXRoIGFub3RoZXIsIHJldHVybiBhIG5ldyBpbnN0YW5jZVxuXG5cbiAgbWVyZ2UoYm94KSB7XG4gICAgY29uc3QgeCA9IE1hdGgubWluKHRoaXMueCwgYm94LngpO1xuICAgIGNvbnN0IHkgPSBNYXRoLm1pbih0aGlzLnksIGJveC55KTtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgubWF4KHRoaXMueCArIHRoaXMud2lkdGgsIGJveC54ICsgYm94LndpZHRoKSAtIHg7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy55ICsgdGhpcy5oZWlnaHQsIGJveC55ICsgYm94LmhlaWdodCkgLSB5O1xuICAgIHJldHVybiBuZXcgQm94KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICB9XG5cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gW3RoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF07XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy54ICsgJyAnICsgdGhpcy55ICsgJyAnICsgdGhpcy53aWR0aCArICcgJyArIHRoaXMuaGVpZ2h0O1xuICB9XG5cbiAgdHJhbnNmb3JtKG0pIHtcbiAgICBpZiAoIShtIGluc3RhbmNlb2YgTWF0cml4KSkge1xuICAgICAgbSA9IG5ldyBNYXRyaXgobSk7XG4gICAgfVxuXG4gICAgbGV0IHhNaW4gPSBJbmZpbml0eTtcbiAgICBsZXQgeE1heCA9IC1JbmZpbml0eTtcbiAgICBsZXQgeU1pbiA9IEluZmluaXR5O1xuICAgIGxldCB5TWF4ID0gLUluZmluaXR5O1xuICAgIGNvbnN0IHB0cyA9IFtuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpLCBuZXcgUG9pbnQodGhpcy54MiwgdGhpcy55KSwgbmV3IFBvaW50KHRoaXMueCwgdGhpcy55MiksIG5ldyBQb2ludCh0aGlzLngyLCB0aGlzLnkyKV07XG4gICAgcHRzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgIHAgPSBwLnRyYW5zZm9ybShtKTtcbiAgICAgIHhNaW4gPSBNYXRoLm1pbih4TWluLCBwLngpO1xuICAgICAgeE1heCA9IE1hdGgubWF4KHhNYXgsIHAueCk7XG4gICAgICB5TWluID0gTWF0aC5taW4oeU1pbiwgcC55KTtcbiAgICAgIHlNYXggPSBNYXRoLm1heCh5TWF4LCBwLnkpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgQm94KHhNaW4sIHlNaW4sIHhNYXggLSB4TWluLCB5TWF4IC0geU1pbik7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBnZXRCb3goZWwsIGdldEJCb3hGbiwgcmV0cnkpIHtcbiAgbGV0IGJveDtcblxuICB0cnkge1xuICAgIC8vIFRyeSB0byBnZXQgdGhlIGJveCB3aXRoIHRoZSBwcm92aWRlZCBmdW5jdGlvblxuICAgIGJveCA9IGdldEJCb3hGbihlbC5ub2RlKTsgLy8gSWYgdGhlIGJveCBpcyB3b3J0aGxlc3MgYW5kIG5vdCBldmVuIGluIHRoZSBkb20sIHJldHJ5XG4gICAgLy8gYnkgdGhyb3dpbmcgYW4gZXJyb3IgaGVyZS4uLlxuXG4gICAgaWYgKGlzTnVsbGVkQm94KGJveCkgJiYgIWRvbUNvbnRhaW5zKGVsLm5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgbm90IGluIHRoZSBkb20nKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyAuLi4gYW5kIGNhbGxpbmcgdGhlIHJldHJ5IGhhbmRsZXIgaGVyZVxuICAgIGJveCA9IHJldHJ5KGVsKTtcbiAgfVxuXG4gIHJldHVybiBib3g7XG59XG5cbmZ1bmN0aW9uIGJib3goKSB7XG4gIC8vIEZ1bmN0aW9uIHRvIGdldCBiYm94IGlzIGdldEJCb3goKVxuICBjb25zdCBnZXRCQm94ID0gbm9kZSA9PiBub2RlLmdldEJCb3goKTsgLy8gVGFrZSBhbGwgbWVhc3VyZXMgc28gdGhhdCBhIHN0dXBpZCBicm93c2VyIHJlbmRlcnMgdGhlIGVsZW1lbnRcbiAgLy8gc28gd2UgY2FuIGdldCB0aGUgYmJveCBmcm9tIGl0IHdoZW4gd2UgdHJ5IGFnYWluXG5cblxuICBjb25zdCByZXRyeSA9IGVsID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2xvbmUgPSBlbC5jbG9uZSgpLmFkZFRvKHBhcnNlcigpLnN2Zykuc2hvdygpO1xuICAgICAgY29uc3QgYm94ID0gY2xvbmUubm9kZS5nZXRCQm94KCk7XG4gICAgICBjbG9uZS5yZW1vdmUoKTtcbiAgICAgIHJldHVybiBib3g7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gV2UgZ2l2ZSB1cC4uLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBHZXR0aW5nIGJib3ggb2YgZWxlbWVudCBcIiR7ZWwubm9kZS5ub2RlTmFtZX1cIiBpcyBub3QgcG9zc2libGU6ICR7ZS50b1N0cmluZygpfWApO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBib3ggPSBnZXRCb3godGhpcywgZ2V0QkJveCwgcmV0cnkpO1xuICBjb25zdCBiYm94ID0gbmV3IEJveChib3gpO1xuICByZXR1cm4gYmJveDtcbn1cbmZ1bmN0aW9uIHJib3goZWwpIHtcbiAgY29uc3QgZ2V0UkJveCA9IG5vZGUgPT4gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICBjb25zdCByZXRyeSA9IGVsID0+IHtcbiAgICAvLyBUaGVyZSBpcyBubyBwb2ludCBpbiB0cnlpbmcgdHJpY2tzIGhlcmUgYmVjYXVzZSBpZiB3ZSBpbnNlcnQgdGhlIGVsZW1lbnQgaW50byB0aGUgZG9tIG91cnNlbHZlc1xuICAgIC8vIGl0IG9idmlvdXNseSB3aWxsIGJlIGF0IHRoZSB3cm9uZyBwb3NpdGlvblxuICAgIHRocm93IG5ldyBFcnJvcihgR2V0dGluZyByYm94IG9mIGVsZW1lbnQgXCIke2VsLm5vZGUubm9kZU5hbWV9XCIgaXMgbm90IHBvc3NpYmxlYCk7XG4gIH07XG5cbiAgY29uc3QgYm94ID0gZ2V0Qm94KHRoaXMsIGdldFJCb3gsIHJldHJ5KTtcbiAgY29uc3QgcmJveCA9IG5ldyBCb3goYm94KTsgLy8gSWYgYW4gZWxlbWVudCB3YXMgcGFzc2VkLCB3ZSB3YW50IHRoZSBiYm94IGluIHRoZSBjb29yZGluYXRlIHN5c3RlbSBvZiB0aGF0IGVsZW1lbnRcblxuICBpZiAoZWwpIHtcbiAgICByZXR1cm4gcmJveC50cmFuc2Zvcm0oZWwuc2NyZWVuQ1RNKCkuaW52ZXJzZU8oKSk7XG4gIH0gLy8gRWxzZSB3ZSB3YW50IGl0IGluIGFic29sdXRlIHNjcmVlbiBjb29yZGluYXRlc1xuICAvLyBUaGVyZWZvcmUgd2UgbmVlZCB0byBhZGQgdGhlIHNjcm9sbE9mZnNldFxuXG5cbiAgcmV0dXJuIHJib3guYWRkT2Zmc2V0KCk7XG59IC8vIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBwb2ludCBpcyBpbnNpZGUgdGhlIGJvdW5kaW5nIGJveFxuXG5mdW5jdGlvbiBpbnNpZGUoeCwgeSkge1xuICBjb25zdCBib3ggPSB0aGlzLmJib3goKTtcbiAgcmV0dXJuIHggPiBib3gueCAmJiB5ID4gYm94LnkgJiYgeCA8IGJveC54ICsgYm94LndpZHRoICYmIHkgPCBib3gueSArIGJveC5oZWlnaHQ7XG59XG5yZWdpc3Rlck1ldGhvZHMoe1xuICB2aWV3Ym94OiB7XG4gICAgdmlld2JveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAvLyBhY3QgYXMgZ2V0dGVyXG4gICAgICBpZiAoeCA9PSBudWxsKSByZXR1cm4gbmV3IEJveCh0aGlzLmF0dHIoJ3ZpZXdCb3gnKSk7IC8vIGFjdCBhcyBzZXR0ZXJcblxuICAgICAgcmV0dXJuIHRoaXMuYXR0cigndmlld0JveCcsIG5ldyBCb3goeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuICAgIH0sXG5cbiAgICB6b29tKGxldmVsLCBwb2ludCkge1xuICAgICAgLy8gSXRzIGJlc3QgdG8gcmVseSBvbiB0aGUgYXR0cmlidXRlcyBoZXJlIGFuZCBoZXJlIGlzIHdoeTpcbiAgICAgIC8vIGNsaWVudFhZWjogRG9lc24ndCB3b3JrIG9uIG5vbi1yb290IHN2Z3MgYmVjYXVzZSB0aGV5IGRvbnQgaGF2ZSBhIENTU0JveCAoc2lsbHkhKVxuICAgICAgLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBEb2Vzbid0IHdvcmsgYmVjYXVzZSBDaHJvbWUganVzdCBpZ25vcmVzIHdpZHRoIGFuZCBoZWlnaHQgb2YgbmVzdGVkIHN2Z3MgY29tcGxldGVseVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICB0aGF0IG1lYW5zLCB0aGVpciBjbGllbnRSZWN0IGlzIGFsd2F5cyBhcyBiaWcgYXMgdGhlIGNvbnRlbnQuXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgIEZ1cnRoZXJtb3JlIHRoaXMgc2l6ZSBpcyBpbmNvcnJlY3QgaWYgdGhlIGVsZW1lbnQgaXMgZnVydGhlciB0cmFuc2Zvcm1lZCBieSBpdHMgcGFyZW50c1xuICAgICAgLy8gY29tcHV0ZWRTdHlsZTogT25seSByZXR1cm5zIG1lYW5pbmdmdWwgdmFsdWVzIGlmIGNzcyB3YXMgdXNlZCB3aXRoIHB4LiBXZSBkb250IGdvIHRoaXMgcm91dGUgaGVyZSFcbiAgICAgIC8vIGdldEJCb3g6IHJldHVybnMgdGhlIGJvdW5kaW5nIGJveCBvZiBpdHMgY29udGVudCAtIHRoYXQgZG9lc24ndCBoZWxwIVxuICAgICAgbGV0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IHRoaXMuYXR0cihbJ3dpZHRoJywgJ2hlaWdodCddKTsgLy8gV2lkdGggYW5kIGhlaWdodCBpcyBhIHN0cmluZyB3aGVuIGEgbnVtYmVyIHdpdGggYSB1bml0IGlzIHByZXNlbnQgd2hpY2ggd2UgY2FuJ3QgdXNlXG4gICAgICAvLyBTbyB3ZSB0cnkgY2xpZW50WFlaXG5cbiAgICAgIGlmICghd2lkdGggJiYgIWhlaWdodCB8fCB0eXBlb2Ygd2lkdGggPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBoZWlnaHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHdpZHRoID0gdGhpcy5ub2RlLmNsaWVudFdpZHRoO1xuICAgICAgICBoZWlnaHQgPSB0aGlzLm5vZGUuY2xpZW50SGVpZ2h0O1xuICAgICAgfSAvLyBHaXZpbmcgdXAuLi5cblxuXG4gICAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbXBvc3NpYmxlIHRvIGdldCBhYnNvbHV0ZSB3aWR0aCBhbmQgaGVpZ2h0LiBQbGVhc2UgcHJvdmlkZSBhbiBhYnNvbHV0ZSB3aWR0aCBhbmQgaGVpZ2h0IGF0dHJpYnV0ZSBvbiB0aGUgem9vbWluZyBlbGVtZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHYgPSB0aGlzLnZpZXdib3goKTtcbiAgICAgIGNvbnN0IHpvb21YID0gd2lkdGggLyB2LndpZHRoO1xuICAgICAgY29uc3Qgem9vbVkgPSBoZWlnaHQgLyB2LmhlaWdodDtcbiAgICAgIGNvbnN0IHpvb20gPSBNYXRoLm1pbih6b29tWCwgem9vbVkpO1xuXG4gICAgICBpZiAobGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gem9vbTtcbiAgICAgIH1cblxuICAgICAgbGV0IHpvb21BbW91bnQgPSB6b29tIC8gbGV2ZWw7IC8vIFNldCB0aGUgem9vbUFtb3VudCB0byB0aGUgaGlnaGVzdCB2YWx1ZSB3aGljaCBpcyBzYWZlIHRvIHByb2Nlc3MgYW5kIHJlY292ZXIgZnJvbVxuICAgICAgLy8gVGhlICogMTAwIGlzIGEgYml0IG9mIHdpZ2dsZSByb29tIGZvciB0aGUgbWF0cml4IHRyYW5zZm9ybWF0aW9uXG5cbiAgICAgIGlmICh6b29tQW1vdW50ID09PSBJbmZpbml0eSkgem9vbUFtb3VudCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIC8gMTAwO1xuICAgICAgcG9pbnQgPSBwb2ludCB8fCBuZXcgUG9pbnQod2lkdGggLyAyIC8gem9vbVggKyB2LngsIGhlaWdodCAvIDIgLyB6b29tWSArIHYueSk7XG4gICAgICBjb25zdCBib3ggPSBuZXcgQm94KHYpLnRyYW5zZm9ybShuZXcgTWF0cml4KHtcbiAgICAgICAgc2NhbGU6IHpvb21BbW91bnQsXG4gICAgICAgIG9yaWdpbjogcG9pbnRcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiB0aGlzLnZpZXdib3goYm94KTtcbiAgICB9XG5cbiAgfVxufSk7XG5yZWdpc3RlcihCb3gsICdCb3gnKTtcblxuY2xhc3MgTGlzdCBleHRlbmRzIEFycmF5IHtcbiAgY29uc3RydWN0b3IoYXJyID0gW10sIC4uLmFyZ3MpIHtcbiAgICBzdXBlcihhcnIsIC4uLmFyZ3MpO1xuICAgIGlmICh0eXBlb2YgYXJyID09PSAnbnVtYmVyJykgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMucHVzaCguLi5hcnIpO1xuICB9XG5cbn1cbmV4dGVuZChbTGlzdF0sIHtcbiAgZWFjaChmbk9yTWV0aG9kTmFtZSwgLi4uYXJncykge1xuICAgIGlmICh0eXBlb2YgZm5Pck1ldGhvZE5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcCgoZWwsIGksIGFycikgPT4ge1xuICAgICAgICByZXR1cm4gZm5Pck1ldGhvZE5hbWUuY2FsbChlbCwgZWwsIGksIGFycik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMubWFwKGVsID0+IHtcbiAgICAgICAgcmV0dXJuIGVsW2ZuT3JNZXRob2ROYW1lXSguLi5hcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCB0aGlzKTtcbiAgfVxuXG59KTtcbmNvbnN0IHJlc2VydmVkID0gWyd0b0FycmF5JywgJ2NvbnN0cnVjdG9yJywgJ2VhY2gnXTtcblxuTGlzdC5leHRlbmQgPSBmdW5jdGlvbiAobWV0aG9kcykge1xuICBtZXRob2RzID0gbWV0aG9kcy5yZWR1Y2UoKG9iaiwgbmFtZSkgPT4ge1xuICAgIC8vIERvbid0IG92ZXJ3cml0ZSBvd24gbWV0aG9kc1xuICAgIGlmIChyZXNlcnZlZC5pbmNsdWRlcyhuYW1lKSkgcmV0dXJuIG9iajsgLy8gRG9uJ3QgYWRkIHByaXZhdGUgbWV0aG9kc1xuXG4gICAgaWYgKG5hbWVbMF0gPT09ICdfJykgcmV0dXJuIG9iajsgLy8gUmVsYXkgZXZlcnkgY2FsbCB0byBlYWNoKClcblxuICAgIG9ialtuYW1lXSA9IGZ1bmN0aW9uICguLi5hdHRycykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChuYW1lLCAuLi5hdHRycyk7XG4gICAgfTtcblxuICAgIHJldHVybiBvYmo7XG4gIH0sIHt9KTtcbiAgZXh0ZW5kKFtMaXN0XSwgbWV0aG9kcyk7XG59O1xuXG5mdW5jdGlvbiBiYXNlRmluZChxdWVyeSwgcGFyZW50KSB7XG4gIHJldHVybiBuZXcgTGlzdChtYXAoKHBhcmVudCB8fCBnbG9iYWxzLmRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gYWRvcHQobm9kZSk7XG4gIH0pKTtcbn0gLy8gU2NvcGVkIGZpbmQgbWV0aG9kXG5cbmZ1bmN0aW9uIGZpbmQocXVlcnkpIHtcbiAgcmV0dXJuIGJhc2VGaW5kKHF1ZXJ5LCB0aGlzLm5vZGUpO1xufVxuZnVuY3Rpb24gZmluZE9uZShxdWVyeSkge1xuICByZXR1cm4gYWRvcHQodGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3IocXVlcnkpKTtcbn1cblxubGV0IGxpc3RlbmVySWQgPSAwO1xuY29uc3Qgd2luZG93RXZlbnRzID0ge307XG5mdW5jdGlvbiBnZXRFdmVudHMoaW5zdGFuY2UpIHtcbiAgbGV0IG4gPSBpbnN0YW5jZS5nZXRFdmVudEhvbGRlcigpOyAvLyBXZSBkb250IHdhbnQgdG8gc2F2ZSBldmVudHMgaW4gZ2xvYmFsIHNwYWNlXG5cbiAgaWYgKG4gPT09IGdsb2JhbHMud2luZG93KSBuID0gd2luZG93RXZlbnRzO1xuICBpZiAoIW4uZXZlbnRzKSBuLmV2ZW50cyA9IHt9O1xuICByZXR1cm4gbi5ldmVudHM7XG59XG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChpbnN0YW5jZSkge1xuICByZXR1cm4gaW5zdGFuY2UuZ2V0RXZlbnRUYXJnZXQoKTtcbn1cbmZ1bmN0aW9uIGNsZWFyRXZlbnRzKGluc3RhbmNlKSB7XG4gIGxldCBuID0gaW5zdGFuY2UuZ2V0RXZlbnRIb2xkZXIoKTtcbiAgaWYgKG4gPT09IGdsb2JhbHMud2luZG93KSBuID0gd2luZG93RXZlbnRzO1xuICBpZiAobi5ldmVudHMpIG4uZXZlbnRzID0ge307XG59IC8vIEFkZCBldmVudCBiaW5kZXIgaW4gdGhlIFNWRyBuYW1lc3BhY2VcblxuZnVuY3Rpb24gb24obm9kZSwgZXZlbnRzLCBsaXN0ZW5lciwgYmluZGluZywgb3B0aW9ucykge1xuICBjb25zdCBsID0gbGlzdGVuZXIuYmluZChiaW5kaW5nIHx8IG5vZGUpO1xuICBjb25zdCBpbnN0YW5jZSA9IG1ha2VJbnN0YW5jZShub2RlKTtcbiAgY29uc3QgYmFnID0gZ2V0RXZlbnRzKGluc3RhbmNlKTtcbiAgY29uc3QgbiA9IGdldEV2ZW50VGFyZ2V0KGluc3RhbmNlKTsgLy8gZXZlbnRzIGNhbiBiZSBhbiBhcnJheSBvZiBldmVudHMgb3IgYSBzdHJpbmcgb2YgZXZlbnRzXG5cbiAgZXZlbnRzID0gQXJyYXkuaXNBcnJheShldmVudHMpID8gZXZlbnRzIDogZXZlbnRzLnNwbGl0KGRlbGltaXRlcik7IC8vIGFkZCBpZCB0byBsaXN0ZW5lclxuXG4gIGlmICghbGlzdGVuZXIuX3N2Z2pzTGlzdGVuZXJJZCkge1xuICAgIGxpc3RlbmVyLl9zdmdqc0xpc3RlbmVySWQgPSArK2xpc3RlbmVySWQ7XG4gIH1cblxuICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBjb25zdCBldiA9IGV2ZW50LnNwbGl0KCcuJylbMF07XG4gICAgY29uc3QgbnMgPSBldmVudC5zcGxpdCgnLicpWzFdIHx8ICcqJzsgLy8gZW5zdXJlIHZhbGlkIG9iamVjdFxuXG4gICAgYmFnW2V2XSA9IGJhZ1tldl0gfHwge307XG4gICAgYmFnW2V2XVtuc10gPSBiYWdbZXZdW25zXSB8fCB7fTsgLy8gcmVmZXJlbmNlIGxpc3RlbmVyXG5cbiAgICBiYWdbZXZdW25zXVtsaXN0ZW5lci5fc3ZnanNMaXN0ZW5lcklkXSA9IGw7IC8vIGFkZCBsaXN0ZW5lclxuXG4gICAgbi5hZGRFdmVudExpc3RlbmVyKGV2LCBsLCBvcHRpb25zIHx8IGZhbHNlKTtcbiAgfSk7XG59IC8vIEFkZCBldmVudCB1bmJpbmRlciBpbiB0aGUgU1ZHIG5hbWVzcGFjZVxuXG5mdW5jdGlvbiBvZmYobm9kZSwgZXZlbnRzLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICBjb25zdCBpbnN0YW5jZSA9IG1ha2VJbnN0YW5jZShub2RlKTtcbiAgY29uc3QgYmFnID0gZ2V0RXZlbnRzKGluc3RhbmNlKTtcbiAgY29uc3QgbiA9IGdldEV2ZW50VGFyZ2V0KGluc3RhbmNlKTsgLy8gbGlzdGVuZXIgY2FuIGJlIGEgZnVuY3Rpb24gb3IgYSBudW1iZXJcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5fc3ZnanNMaXN0ZW5lcklkO1xuICAgIGlmICghbGlzdGVuZXIpIHJldHVybjtcbiAgfSAvLyBldmVudHMgY2FuIGJlIGFuIGFycmF5IG9mIGV2ZW50cyBvciBhIHN0cmluZyBvciB1bmRlZmluZWRcblxuXG4gIGV2ZW50cyA9IEFycmF5LmlzQXJyYXkoZXZlbnRzKSA/IGV2ZW50cyA6IChldmVudHMgfHwgJycpLnNwbGl0KGRlbGltaXRlcik7XG4gIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgIGNvbnN0IGV2ID0gZXZlbnQgJiYgZXZlbnQuc3BsaXQoJy4nKVswXTtcbiAgICBjb25zdCBucyA9IGV2ZW50ICYmIGV2ZW50LnNwbGl0KCcuJylbMV07XG4gICAgbGV0IG5hbWVzcGFjZSwgbDtcblxuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgLy8gcmVtb3ZlIGxpc3RlbmVyIHJlZmVyZW5jZVxuICAgICAgaWYgKGJhZ1tldl0gJiYgYmFnW2V2XVtucyB8fCAnKiddKSB7XG4gICAgICAgIC8vIHJlbW92ZUxpc3RlbmVyXG4gICAgICAgIG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldiwgYmFnW2V2XVtucyB8fCAnKiddW2xpc3RlbmVyXSwgb3B0aW9ucyB8fCBmYWxzZSk7XG4gICAgICAgIGRlbGV0ZSBiYWdbZXZdW25zIHx8ICcqJ11bbGlzdGVuZXJdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXYgJiYgbnMpIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciBhIG5hbWVzcGFjZWQgZXZlbnRcbiAgICAgIGlmIChiYWdbZXZdICYmIGJhZ1tldl1bbnNdKSB7XG4gICAgICAgIGZvciAobCBpbiBiYWdbZXZdW25zXSkge1xuICAgICAgICAgIG9mZihuLCBbZXYsIG5zXS5qb2luKCcuJyksIGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIGJhZ1tldl1bbnNdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobnMpIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmljIG5hbWVzcGFjZVxuICAgICAgZm9yIChldmVudCBpbiBiYWcpIHtcbiAgICAgICAgZm9yIChuYW1lc3BhY2UgaW4gYmFnW2V2ZW50XSkge1xuICAgICAgICAgIGlmIChucyA9PT0gbmFtZXNwYWNlKSB7XG4gICAgICAgICAgICBvZmYobiwgW2V2ZW50LCBuc10uam9pbignLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV2KSB7XG4gICAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgdGhlIGV2ZW50XG4gICAgICBpZiAoYmFnW2V2XSkge1xuICAgICAgICBmb3IgKG5hbWVzcGFjZSBpbiBiYWdbZXZdKSB7XG4gICAgICAgICAgb2ZmKG4sIFtldiwgbmFtZXNwYWNlXS5qb2luKCcuJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIGJhZ1tldl07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIGEgZ2l2ZW4gbm9kZVxuICAgICAgZm9yIChldmVudCBpbiBiYWcpIHtcbiAgICAgICAgb2ZmKG4sIGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgY2xlYXJFdmVudHMoaW5zdGFuY2UpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBkaXNwYXRjaChub2RlLCBldmVudCwgZGF0YSwgb3B0aW9ucykge1xuICBjb25zdCBuID0gZ2V0RXZlbnRUYXJnZXQobm9kZSk7IC8vIERpc3BhdGNoIGV2ZW50XG5cbiAgaWYgKGV2ZW50IGluc3RhbmNlb2YgZ2xvYmFscy53aW5kb3cuRXZlbnQpIHtcbiAgICBuLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50ID0gbmV3IGdsb2JhbHMud2luZG93LkN1c3RvbUV2ZW50KGV2ZW50LCB7XG4gICAgICBkZXRhaWw6IGRhdGEsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICAgIG4uZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cblxuICByZXR1cm4gZXZlbnQ7XG59XG5cbmNsYXNzIEV2ZW50VGFyZ2V0IGV4dGVuZHMgQmFzZSB7XG4gIGFkZEV2ZW50TGlzdGVuZXIoKSB7fVxuXG4gIGRpc3BhdGNoKGV2ZW50LCBkYXRhLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKHRoaXMsIGV2ZW50LCBkYXRhLCBvcHRpb25zKTtcbiAgfVxuXG4gIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCBiYWcgPSB0aGlzLmdldEV2ZW50SG9sZGVyKCkuZXZlbnRzO1xuICAgIGlmICghYmFnKSByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBldmVudHMgPSBiYWdbZXZlbnQudHlwZV07XG5cbiAgICBmb3IgKGNvbnN0IGkgaW4gZXZlbnRzKSB7XG4gICAgICBmb3IgKGNvbnN0IGogaW4gZXZlbnRzW2ldKSB7XG4gICAgICAgIGV2ZW50c1tpXVtqXShldmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkO1xuICB9IC8vIEZpcmUgZ2l2ZW4gZXZlbnRcblxuXG4gIGZpcmUoZXZlbnQsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmRpc3BhdGNoKGV2ZW50LCBkYXRhLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldEV2ZW50SG9sZGVyKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0RXZlbnRUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gVW5iaW5kIGV2ZW50IGZyb20gbGlzdGVuZXJcblxuXG4gIG9mZihldmVudCwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICBvZmYodGhpcywgZXZlbnQsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBCaW5kIGdpdmVuIGV2ZW50IHRvIGxpc3RlbmVyXG5cblxuICBvbihldmVudCwgbGlzdGVuZXIsIGJpbmRpbmcsIG9wdGlvbnMpIHtcbiAgICBvbih0aGlzLCBldmVudCwgbGlzdGVuZXIsIGJpbmRpbmcsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpIHt9XG5cbn1cbnJlZ2lzdGVyKEV2ZW50VGFyZ2V0LCAnRXZlbnRUYXJnZXQnKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9IC8vIERlZmF1bHQgYW5pbWF0aW9uIHZhbHVlc1xuXG5jb25zdCB0aW1lbGluZSA9IHtcbiAgZHVyYXRpb246IDQwMCxcbiAgZWFzZTogJz4nLFxuICBkZWxheTogMFxufTsgLy8gRGVmYXVsdCBhdHRyaWJ1dGUgdmFsdWVzXG5cbmNvbnN0IGF0dHJzID0ge1xuICAvLyBmaWxsIGFuZCBzdHJva2VcbiAgJ2ZpbGwtb3BhY2l0eSc6IDEsXG4gICdzdHJva2Utb3BhY2l0eSc6IDEsXG4gICdzdHJva2Utd2lkdGgnOiAwLFxuICAnc3Ryb2tlLWxpbmVqb2luJzogJ21pdGVyJyxcbiAgJ3N0cm9rZS1saW5lY2FwJzogJ2J1dHQnLFxuICBmaWxsOiAnIzAwMDAwMCcsXG4gIHN0cm9rZTogJyMwMDAwMDAnLFxuICBvcGFjaXR5OiAxLFxuICAvLyBwb3NpdGlvblxuICB4OiAwLFxuICB5OiAwLFxuICBjeDogMCxcbiAgY3k6IDAsXG4gIC8vIHNpemVcbiAgd2lkdGg6IDAsXG4gIGhlaWdodDogMCxcbiAgLy8gcmFkaXVzXG4gIHI6IDAsXG4gIHJ4OiAwLFxuICByeTogMCxcbiAgLy8gZ3JhZGllbnRcbiAgb2Zmc2V0OiAwLFxuICAnc3RvcC1vcGFjaXR5JzogMSxcbiAgJ3N0b3AtY29sb3InOiAnIzAwMDAwMCcsXG4gIC8vIHRleHRcbiAgJ3RleHQtYW5jaG9yJzogJ3N0YXJ0J1xufTtcblxudmFyIGRlZmF1bHRzID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIG5vb3A6IG5vb3AsXG4gIHRpbWVsaW5lOiB0aW1lbGluZSxcbiAgYXR0cnM6IGF0dHJzXG59O1xuXG5jbGFzcyBTVkdBcnJheSBleHRlbmRzIEFycmF5IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMuaW5pdCguLi5hcmdzKTtcbiAgfVxuXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcbiAgfVxuXG4gIGluaXQoYXJyKSB7XG4gICAgLy8gVGhpcyBjYXRjaGVzIHRoZSBjYXNlLCB0aGF0IG5hdGl2ZSBtYXAgdHJpZXMgdG8gY3JlYXRlIGFuIGFycmF5IHdpdGggbmV3IEFycmF5KDEpXG4gICAgaWYgKHR5cGVvZiBhcnIgPT09ICdudW1iZXInKSByZXR1cm4gdGhpcztcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5wdXNoKC4uLnRoaXMucGFyc2UoYXJyKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gUGFyc2Ugd2hpdGVzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nXG5cblxuICBwYXJzZShhcnJheSA9IFtdKSB7XG4gICAgLy8gSWYgYWxyZWFkeSBpcyBhbiBhcnJheSwgbm8gbmVlZCB0byBwYXJzZSBpdFxuICAgIGlmIChhcnJheSBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gYXJyYXk7XG4gICAgcmV0dXJuIGFycmF5LnRyaW0oKS5zcGxpdChkZWxpbWl0ZXIpLm1hcChwYXJzZUZsb2F0KTtcbiAgfVxuXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIHRoaXMpO1xuICB9XG5cbiAgdG9TZXQoKSB7XG4gICAgcmV0dXJuIG5ldyBTZXQodGhpcyk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5qb2luKCcgJyk7XG4gIH0gLy8gRmxhdHRlbnMgdGhlIGFycmF5IGlmIG5lZWRlZFxuXG5cbiAgdmFsdWVPZigpIHtcbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICByZXQucHVzaCguLi50aGlzKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbn1cblxuY2xhc3MgU1ZHTnVtYmVyIHtcbiAgLy8gSW5pdGlhbGl6ZVxuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgdGhpcy5pbml0KC4uLmFyZ3MpO1xuICB9XG5cbiAgY29udmVydCh1bml0KSB7XG4gICAgcmV0dXJuIG5ldyBTVkdOdW1iZXIodGhpcy52YWx1ZSwgdW5pdCk7XG4gIH0gLy8gRGl2aWRlIG51bWJlclxuXG5cbiAgZGl2aWRlKG51bWJlcikge1xuICAgIG51bWJlciA9IG5ldyBTVkdOdW1iZXIobnVtYmVyKTtcbiAgICByZXR1cm4gbmV3IFNWR051bWJlcih0aGlzIC8gbnVtYmVyLCB0aGlzLnVuaXQgfHwgbnVtYmVyLnVuaXQpO1xuICB9XG5cbiAgaW5pdCh2YWx1ZSwgdW5pdCkge1xuICAgIHVuaXQgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlWzFdIDogdW5pdDtcbiAgICB2YWx1ZSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiB2YWx1ZTsgLy8gaW5pdGlhbGl6ZSBkZWZhdWx0c1xuXG4gICAgdGhpcy52YWx1ZSA9IDA7XG4gICAgdGhpcy51bml0ID0gdW5pdCB8fCAnJzsgLy8gcGFyc2UgdmFsdWVcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBlbnN1cmUgYSB2YWxpZCBudW1lcmljIHZhbHVlXG4gICAgICB0aGlzLnZhbHVlID0gaXNOYU4odmFsdWUpID8gMCA6ICFpc0Zpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA8IDAgPyAtMy40ZSszOCA6ICszLjRlKzM4IDogdmFsdWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB1bml0ID0gdmFsdWUubWF0Y2gobnVtYmVyQW5kVW5pdCk7XG5cbiAgICAgIGlmICh1bml0KSB7XG4gICAgICAgIC8vIG1ha2UgdmFsdWUgbnVtZXJpY1xuICAgICAgICB0aGlzLnZhbHVlID0gcGFyc2VGbG9hdCh1bml0WzFdKTsgLy8gbm9ybWFsaXplXG5cbiAgICAgICAgaWYgKHVuaXRbNV0gPT09ICclJykge1xuICAgICAgICAgIHRoaXMudmFsdWUgLz0gMTAwO1xuICAgICAgICB9IGVsc2UgaWYgKHVuaXRbNV0gPT09ICdzJykge1xuICAgICAgICAgIHRoaXMudmFsdWUgKj0gMTAwMDtcbiAgICAgICAgfSAvLyBzdG9yZSB1bml0XG5cblxuICAgICAgICB0aGlzLnVuaXQgPSB1bml0WzVdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTVkdOdW1iZXIpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlLnZhbHVlT2YoKTtcbiAgICAgICAgdGhpcy51bml0ID0gdmFsdWUudW5pdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBTdWJ0cmFjdCBudW1iZXJcblxuXG4gIG1pbnVzKG51bWJlcikge1xuICAgIG51bWJlciA9IG5ldyBTVkdOdW1iZXIobnVtYmVyKTtcbiAgICByZXR1cm4gbmV3IFNWR051bWJlcih0aGlzIC0gbnVtYmVyLCB0aGlzLnVuaXQgfHwgbnVtYmVyLnVuaXQpO1xuICB9IC8vIEFkZCBudW1iZXJcblxuXG4gIHBsdXMobnVtYmVyKSB7XG4gICAgbnVtYmVyID0gbmV3IFNWR051bWJlcihudW1iZXIpO1xuICAgIHJldHVybiBuZXcgU1ZHTnVtYmVyKHRoaXMgKyBudW1iZXIsIHRoaXMudW5pdCB8fCBudW1iZXIudW5pdCk7XG4gIH0gLy8gTXVsdGlwbHkgbnVtYmVyXG5cblxuICB0aW1lcyhudW1iZXIpIHtcbiAgICBudW1iZXIgPSBuZXcgU1ZHTnVtYmVyKG51bWJlcik7XG4gICAgcmV0dXJuIG5ldyBTVkdOdW1iZXIodGhpcyAqIG51bWJlciwgdGhpcy51bml0IHx8IG51bWJlci51bml0KTtcbiAgfVxuXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIFt0aGlzLnZhbHVlLCB0aGlzLnVuaXRdO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gKHRoaXMudW5pdCA9PT0gJyUnID8gfn4odGhpcy52YWx1ZSAqIDFlOCkgLyAxZTYgOiB0aGlzLnVuaXQgPT09ICdzJyA/IHRoaXMudmFsdWUgLyAxZTMgOiB0aGlzLnZhbHVlKSArIHRoaXMudW5pdDtcbiAgfVxuXG4gIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cblxufVxuXG5jb25zdCBob29rcyA9IFtdO1xuZnVuY3Rpb24gcmVnaXN0ZXJBdHRySG9vayhmbikge1xuICBob29rcy5wdXNoKGZuKTtcbn0gLy8gU2V0IHN2ZyBlbGVtZW50IGF0dHJpYnV0ZVxuXG5mdW5jdGlvbiBhdHRyKGF0dHIsIHZhbCwgbnMpIHtcbiAgLy8gYWN0IGFzIGZ1bGwgZ2V0dGVyXG4gIGlmIChhdHRyID09IG51bGwpIHtcbiAgICAvLyBnZXQgYW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXNcbiAgICBhdHRyID0ge307XG4gICAgdmFsID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXM7XG5cbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdmFsKSB7XG4gICAgICBhdHRyW25vZGUubm9kZU5hbWVdID0gaXNOdW1iZXIudGVzdChub2RlLm5vZGVWYWx1ZSkgPyBwYXJzZUZsb2F0KG5vZGUubm9kZVZhbHVlKSA6IG5vZGUubm9kZVZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBhdHRyO1xuICB9IGVsc2UgaWYgKGF0dHIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIC8vIGxvb3AgdGhyb3VnaCBhcnJheSBhbmQgZ2V0IGFsbCB2YWx1ZXNcbiAgICByZXR1cm4gYXR0ci5yZWR1Y2UoKGxhc3QsIGN1cnIpID0+IHtcbiAgICAgIGxhc3RbY3Vycl0gPSB0aGlzLmF0dHIoY3Vycik7XG4gICAgICByZXR1cm4gbGFzdDtcbiAgICB9LCB7fSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGF0dHIgPT09ICdvYmplY3QnICYmIGF0dHIuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgIC8vIGFwcGx5IGV2ZXJ5IGF0dHJpYnV0ZSBpbmRpdmlkdWFsbHkgaWYgYW4gb2JqZWN0IGlzIHBhc3NlZFxuICAgIGZvciAodmFsIGluIGF0dHIpIHRoaXMuYXR0cih2YWwsIGF0dHJbdmFsXSk7XG4gIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgLy8gcmVtb3ZlIHZhbHVlXG4gICAgdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgfSBlbHNlIGlmICh2YWwgPT0gbnVsbCkge1xuICAgIC8vIGFjdCBhcyBhIGdldHRlciBpZiB0aGUgZmlyc3QgYW5kIG9ubHkgYXJndW1lbnQgaXMgbm90IGFuIG9iamVjdFxuICAgIHZhbCA9IHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgcmV0dXJuIHZhbCA9PSBudWxsID8gYXR0cnNbYXR0cl0gOiBpc051bWJlci50ZXN0KHZhbCkgPyBwYXJzZUZsb2F0KHZhbCkgOiB2YWw7XG4gIH0gZWxzZSB7XG4gICAgLy8gTG9vcCB0aHJvdWdoIGhvb2tzIGFuZCBleGVjdXRlIHRoZW0gdG8gY29udmVydCB2YWx1ZVxuICAgIHZhbCA9IGhvb2tzLnJlZHVjZSgoX3ZhbCwgaG9vaykgPT4ge1xuICAgICAgcmV0dXJuIGhvb2soYXR0ciwgX3ZhbCwgdGhpcyk7XG4gICAgfSwgdmFsKTsgLy8gZW5zdXJlIGNvcnJlY3QgbnVtZXJpYyB2YWx1ZXMgKGFsc28gYWNjZXB0cyBOYU4gYW5kIEluZmluaXR5KVxuXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICB2YWwgPSBuZXcgU1ZHTnVtYmVyKHZhbCk7XG4gICAgfSBlbHNlIGlmIChDb2xvci5pc0NvbG9yKHZhbCkpIHtcbiAgICAgIC8vIGVuc3VyZSBmdWxsIGhleCBjb2xvclxuICAgICAgdmFsID0gbmV3IENvbG9yKHZhbCk7XG4gICAgfSBlbHNlIGlmICh2YWwuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAvLyBDaGVjayBmb3IgcGxhaW4gYXJyYXlzIGFuZCBwYXJzZSBhcnJheSB2YWx1ZXNcbiAgICAgIHZhbCA9IG5ldyBTVkdBcnJheSh2YWwpO1xuICAgIH0gLy8gaWYgdGhlIHBhc3NlZCBhdHRyaWJ1dGUgaXMgbGVhZGluZy4uLlxuXG5cbiAgICBpZiAoYXR0ciA9PT0gJ2xlYWRpbmcnKSB7XG4gICAgICAvLyAuLi4gY2FsbCB0aGUgbGVhZGluZyBtZXRob2QgaW5zdGVhZFxuICAgICAgaWYgKHRoaXMubGVhZGluZykge1xuICAgICAgICB0aGlzLmxlYWRpbmcodmFsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2V0IGdpdmVuIGF0dHJpYnV0ZSBvbiBub2RlXG4gICAgICB0eXBlb2YgbnMgPT09ICdzdHJpbmcnID8gdGhpcy5ub2RlLnNldEF0dHJpYnV0ZU5TKG5zLCBhdHRyLCB2YWwudG9TdHJpbmcoKSkgOiB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIHZhbC50b1N0cmluZygpKTtcbiAgICB9IC8vIHJlYnVpbGQgaWYgcmVxdWlyZWRcblxuXG4gICAgaWYgKHRoaXMucmVidWlsZCAmJiAoYXR0ciA9PT0gJ2ZvbnQtc2l6ZScgfHwgYXR0ciA9PT0gJ3gnKSkge1xuICAgICAgdGhpcy5yZWJ1aWxkKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmNsYXNzIERvbSBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy50eXBlID0gbm9kZS5ub2RlTmFtZTtcblxuICAgIGlmIChhdHRycyAmJiBub2RlICE9PSBhdHRycykge1xuICAgICAgdGhpcy5hdHRyKGF0dHJzKTtcbiAgICB9XG4gIH0gLy8gQWRkIGdpdmVuIGVsZW1lbnQgYXQgYSBwb3NpdGlvblxuXG5cbiAgYWRkKGVsZW1lbnQsIGkpIHtcbiAgICBlbGVtZW50ID0gbWFrZUluc3RhbmNlKGVsZW1lbnQpOyAvLyBJZiBub24tcm9vdCBzdmcgbm9kZXMgYXJlIGFkZGVkIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZWlyIG5hbWVzcGFjZXNcblxuICAgIGlmIChlbGVtZW50LnJlbW92ZU5hbWVzcGFjZSAmJiB0aGlzLm5vZGUgaW5zdGFuY2VvZiBnbG9iYWxzLndpbmRvdy5TVkdFbGVtZW50KSB7XG4gICAgICBlbGVtZW50LnJlbW92ZU5hbWVzcGFjZSgpO1xuICAgIH1cblxuICAgIGlmIChpID09IG51bGwpIHtcbiAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChlbGVtZW50Lm5vZGUpO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC5ub2RlICE9PSB0aGlzLm5vZGUuY2hpbGROb2Rlc1tpXSkge1xuICAgICAgdGhpcy5ub2RlLmluc2VydEJlZm9yZShlbGVtZW50Lm5vZGUsIHRoaXMubm9kZS5jaGlsZE5vZGVzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBBZGQgZWxlbWVudCB0byBnaXZlbiBjb250YWluZXIgYW5kIHJldHVybiBzZWxmXG5cblxuICBhZGRUbyhwYXJlbnQsIGkpIHtcbiAgICByZXR1cm4gbWFrZUluc3RhbmNlKHBhcmVudCkucHV0KHRoaXMsIGkpO1xuICB9IC8vIFJldHVybnMgYWxsIGNoaWxkIGVsZW1lbnRzXG5cblxuICBjaGlsZHJlbigpIHtcbiAgICByZXR1cm4gbmV3IExpc3QobWFwKHRoaXMubm9kZS5jaGlsZHJlbiwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBhZG9wdChub2RlKTtcbiAgICB9KSk7XG4gIH0gLy8gUmVtb3ZlIGFsbCBlbGVtZW50cyBpbiB0aGlzIGNvbnRhaW5lclxuXG5cbiAgY2xlYXIoKSB7XG4gICAgLy8gcmVtb3ZlIGNoaWxkcmVuXG4gICAgd2hpbGUgKHRoaXMubm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUubGFzdENoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBDbG9uZSBlbGVtZW50XG5cblxuICBjbG9uZShkZWVwID0gdHJ1ZSwgYXNzaWduTmV3SWRzID0gdHJ1ZSkge1xuICAgIC8vIHdyaXRlIGRvbSBkYXRhIHRvIHRoZSBkb20gc28gdGhlIGNsb25lIGNhbiBwaWNrdXAgdGhlIGRhdGFcbiAgICB0aGlzLndyaXRlRGF0YVRvRG9tKCk7IC8vIGNsb25lIGVsZW1lbnRcblxuICAgIGxldCBub2RlQ2xvbmUgPSB0aGlzLm5vZGUuY2xvbmVOb2RlKGRlZXApO1xuXG4gICAgaWYgKGFzc2lnbk5ld0lkcykge1xuICAgICAgLy8gYXNzaWduIG5ldyBpZFxuICAgICAgbm9kZUNsb25lID0gYXNzaWduTmV3SWQobm9kZUNsb25lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3Iobm9kZUNsb25lKTtcbiAgfSAvLyBJdGVyYXRlcyBvdmVyIGFsbCBjaGlsZHJlbiBhbmQgaW52b2tlcyBhIGdpdmVuIGJsb2NrXG5cblxuICBlYWNoKGJsb2NrLCBkZWVwKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuKCk7XG4gICAgbGV0IGksIGlsO1xuXG4gICAgZm9yIChpID0gMCwgaWwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBibG9jay5hcHBseShjaGlsZHJlbltpXSwgW2ksIGNoaWxkcmVuXSk7XG5cbiAgICAgIGlmIChkZWVwKSB7XG4gICAgICAgIGNoaWxkcmVuW2ldLmVhY2goYmxvY2ssIGRlZXApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZWxlbWVudChub2RlTmFtZSwgYXR0cnMpIHtcbiAgICByZXR1cm4gdGhpcy5wdXQobmV3IERvbShjcmVhdGUobm9kZU5hbWUpLCBhdHRycykpO1xuICB9IC8vIEdldCBmaXJzdCBjaGlsZFxuXG5cbiAgZmlyc3QoKSB7XG4gICAgcmV0dXJuIGFkb3B0KHRoaXMubm9kZS5maXJzdENoaWxkKTtcbiAgfSAvLyBHZXQgYSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxuXG5cbiAgZ2V0KGkpIHtcbiAgICByZXR1cm4gYWRvcHQodGhpcy5ub2RlLmNoaWxkTm9kZXNbaV0pO1xuICB9XG5cbiAgZ2V0RXZlbnRIb2xkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZTtcbiAgfVxuXG4gIGdldEV2ZW50VGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGU7XG4gIH0gLy8gQ2hlY2tzIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGEgY2hpbGRcblxuXG4gIGhhcyhlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXgoZWxlbWVudCkgPj0gMDtcbiAgfVxuXG4gIGh0bWwoaHRtbE9yRm4sIG91dGVySFRNTCkge1xuICAgIHJldHVybiB0aGlzLnhtbChodG1sT3JGbiwgb3V0ZXJIVE1MLCBodG1sKTtcbiAgfSAvLyBHZXQgLyBzZXQgaWRcblxuXG4gIGlkKGlkKSB7XG4gICAgLy8gZ2VuZXJhdGUgbmV3IGlkIGlmIG5vIGlkIHNldFxuICAgIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnICYmICF0aGlzLm5vZGUuaWQpIHtcbiAgICAgIHRoaXMubm9kZS5pZCA9IGVpZCh0aGlzLnR5cGUpO1xuICAgIH0gLy8gZG9uJ3Qgc2V0IGRpcmVjdGx5IHdpdGggdGhpcy5ub2RlLmlkIHRvIG1ha2UgYG51bGxgIHdvcmsgY29ycmVjdGx5XG5cblxuICAgIHJldHVybiB0aGlzLmF0dHIoJ2lkJywgaWQpO1xuICB9IC8vIEdldHMgaW5kZXggb2YgZ2l2ZW4gZWxlbWVudFxuXG5cbiAgaW5kZXgoZWxlbWVudCkge1xuICAgIHJldHVybiBbXS5zbGljZS5jYWxsKHRoaXMubm9kZS5jaGlsZE5vZGVzKS5pbmRleE9mKGVsZW1lbnQubm9kZSk7XG4gIH0gLy8gR2V0IHRoZSBsYXN0IGNoaWxkXG5cblxuICBsYXN0KCkge1xuICAgIHJldHVybiBhZG9wdCh0aGlzLm5vZGUubGFzdENoaWxkKTtcbiAgfSAvLyBtYXRjaGVzIHRoZSBlbGVtZW50IHZzIGEgY3NzIHNlbGVjdG9yXG5cblxuICBtYXRjaGVzKHNlbGVjdG9yKSB7XG4gICAgY29uc3QgZWwgPSB0aGlzLm5vZGU7XG4gICAgY29uc3QgbWF0Y2hlciA9IGVsLm1hdGNoZXMgfHwgZWwubWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm1vek1hdGNoZXNTZWxlY3RvciB8fCBlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZWwub01hdGNoZXNTZWxlY3RvciB8fCBudWxsO1xuICAgIHJldHVybiBtYXRjaGVyICYmIG1hdGNoZXIuY2FsbChlbCwgc2VsZWN0b3IpO1xuICB9IC8vIFJldHVybnMgdGhlIHBhcmVudCBlbGVtZW50IGluc3RhbmNlXG5cblxuICBwYXJlbnQodHlwZSkge1xuICAgIGxldCBwYXJlbnQgPSB0aGlzOyAvLyBjaGVjayBmb3IgcGFyZW50XG5cbiAgICBpZiAoIXBhcmVudC5ub2RlLnBhcmVudE5vZGUpIHJldHVybiBudWxsOyAvLyBnZXQgcGFyZW50IGVsZW1lbnRcblxuICAgIHBhcmVudCA9IGFkb3B0KHBhcmVudC5ub2RlLnBhcmVudE5vZGUpO1xuICAgIGlmICghdHlwZSkgcmV0dXJuIHBhcmVudDsgLy8gbG9vcCB0aHJvdWdoIGFuY2VzdG9ycyBpZiB0eXBlIGlzIGdpdmVuXG5cbiAgICBkbyB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50Lm1hdGNoZXModHlwZSkgOiBwYXJlbnQgaW5zdGFuY2VvZiB0eXBlKSByZXR1cm4gcGFyZW50O1xuICAgIH0gd2hpbGUgKHBhcmVudCA9IGFkb3B0KHBhcmVudC5ub2RlLnBhcmVudE5vZGUpKTtcblxuICAgIHJldHVybiBwYXJlbnQ7XG4gIH0gLy8gQmFzaWNhbGx5IGRvZXMgdGhlIHNhbWUgYXMgYGFkZCgpYCBidXQgcmV0dXJucyB0aGUgYWRkZWQgZWxlbWVudCBpbnN0ZWFkXG5cblxuICBwdXQoZWxlbWVudCwgaSkge1xuICAgIGVsZW1lbnQgPSBtYWtlSW5zdGFuY2UoZWxlbWVudCk7XG4gICAgdGhpcy5hZGQoZWxlbWVudCwgaSk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0gLy8gQWRkIGVsZW1lbnQgdG8gZ2l2ZW4gY29udGFpbmVyIGFuZCByZXR1cm4gY29udGFpbmVyXG5cblxuICBwdXRJbihwYXJlbnQsIGkpIHtcbiAgICByZXR1cm4gbWFrZUluc3RhbmNlKHBhcmVudCkuYWRkKHRoaXMsIGkpO1xuICB9IC8vIFJlbW92ZSBlbGVtZW50XG5cblxuICByZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KCkpIHtcbiAgICAgIHRoaXMucGFyZW50KCkucmVtb3ZlRWxlbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBSZW1vdmUgYSBnaXZlbiBjaGlsZFxuXG5cbiAgcmVtb3ZlRWxlbWVudChlbGVtZW50KSB7XG4gICAgdGhpcy5ub2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQubm9kZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gUmVwbGFjZSB0aGlzIHdpdGggZWxlbWVudFxuXG5cbiAgcmVwbGFjZShlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IG1ha2VJbnN0YW5jZShlbGVtZW50KTtcblxuICAgIGlmICh0aGlzLm5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5ub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGVsZW1lbnQubm9kZSwgdGhpcy5ub2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJvdW5kKHByZWNpc2lvbiA9IDIsIG1hcCA9IG51bGwpIHtcbiAgICBjb25zdCBmYWN0b3IgPSAxMCAqKiBwcmVjaXNpb247XG4gICAgY29uc3QgYXR0cnMgPSB0aGlzLmF0dHIobWFwKTtcblxuICAgIGZvciAoY29uc3QgaSBpbiBhdHRycykge1xuICAgICAgaWYgKHR5cGVvZiBhdHRyc1tpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYXR0cnNbaV0gPSBNYXRoLnJvdW5kKGF0dHJzW2ldICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmF0dHIoYXR0cnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIEltcG9ydCAvIEV4cG9ydCByYXcgc3ZnXG5cblxuICBzdmcoc3ZnT3JGbiwgb3V0ZXJTVkcpIHtcbiAgICByZXR1cm4gdGhpcy54bWwoc3ZnT3JGbiwgb3V0ZXJTVkcsIHN2Zyk7XG4gIH0gLy8gUmV0dXJuIGlkIG9uIHN0cmluZyBjb252ZXJzaW9uXG5cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5pZCgpO1xuICB9XG5cbiAgd29yZHModGV4dCkge1xuICAgIC8vIFRoaXMgaXMgZmFzdGVyIHRoYW4gcmVtb3ZpbmcgYWxsIGNoaWxkcmVuIGFuZCBhZGRpbmcgYSBuZXcgb25lXG4gICAgdGhpcy5ub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHdyYXAobm9kZSkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50KCk7XG5cbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkVG8obm9kZSk7XG4gICAgfVxuXG4gICAgY29uc3QgcG9zaXRpb24gPSBwYXJlbnQuaW5kZXgodGhpcyk7XG4gICAgcmV0dXJuIHBhcmVudC5wdXQobm9kZSwgcG9zaXRpb24pLnB1dCh0aGlzKTtcbiAgfSAvLyB3cml0ZSBzdmdqcyBkYXRhIHRvIHRoZSBkb21cblxuXG4gIHdyaXRlRGF0YVRvRG9tKCkge1xuICAgIC8vIGR1bXAgdmFyaWFibGVzIHJlY3Vyc2l2ZWx5XG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMud3JpdGVEYXRhVG9Eb20oKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBJbXBvcnQgLyBFeHBvcnQgcmF3IHN2Z1xuXG5cbiAgeG1sKHhtbE9yRm4sIG91dGVyWE1MLCBucykge1xuICAgIGlmICh0eXBlb2YgeG1sT3JGbiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBucyA9IG91dGVyWE1MO1xuICAgICAgb3V0ZXJYTUwgPSB4bWxPckZuO1xuICAgICAgeG1sT3JGbiA9IG51bGw7XG4gICAgfSAvLyBhY3QgYXMgZ2V0dGVyIGlmIG5vIHN2ZyBzdHJpbmcgaXMgZ2l2ZW5cblxuXG4gICAgaWYgKHhtbE9yRm4gPT0gbnVsbCB8fCB0eXBlb2YgeG1sT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gVGhlIGRlZmF1bHQgZm9yIGV4cG9ydHMgaXMsIHRoYXQgdGhlIG91dGVyTm9kZSBpcyBpbmNsdWRlZFxuICAgICAgb3V0ZXJYTUwgPSBvdXRlclhNTCA9PSBudWxsID8gdHJ1ZSA6IG91dGVyWE1MOyAvLyB3cml0ZSBzdmdqcyBkYXRhIHRvIHRoZSBkb21cblxuICAgICAgdGhpcy53cml0ZURhdGFUb0RvbSgpO1xuICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzOyAvLyBBbiBleHBvcnQgbW9kaWZpZXIgd2FzIHBhc3NlZFxuXG4gICAgICBpZiAoeG1sT3JGbiAhPSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnQgPSBhZG9wdChjdXJyZW50Lm5vZGUuY2xvbmVOb2RlKHRydWUpKTsgLy8gSWYgdGhlIHVzZXIgd2FudHMgb3V0ZXJIVE1MIHdlIG5lZWQgdG8gcHJvY2VzcyB0aGlzIG5vZGUsIHRvb1xuXG4gICAgICAgIGlmIChvdXRlclhNTCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHhtbE9yRm4oY3VycmVudCk7XG4gICAgICAgICAgY3VycmVudCA9IHJlc3VsdCB8fCBjdXJyZW50OyAvLyBUaGUgdXNlciBkb2VzIG5vdCB3YW50IHRoaXMgbm9kZT8gV2VsbCwgdGhlbiBoZSBnZXRzIG5vdGhpbmdcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSByZXR1cm4gJyc7XG4gICAgICAgIH0gLy8gRGVlcCBsb29wIHRocm91Z2ggYWxsIGNoaWxkcmVuIGFuZCBhcHBseSBtb2RpZmllclxuXG5cbiAgICAgICAgY3VycmVudC5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB4bWxPckZuKHRoaXMpO1xuXG4gICAgICAgICAgY29uc3QgX3RoaXMgPSByZXN1bHQgfHwgdGhpczsgLy8gSWYgbW9kaWZpZXIgcmV0dXJucyBmYWxzZSwgZGlzY2FyZCBub2RlXG5cblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpOyAvLyBJZiBtb2RpZmllciByZXR1cm5zIG5ldyBub2RlLCB1c2UgaXRcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCAmJiB0aGlzICE9PSBfdGhpcykge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlKF90aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgfSAvLyBSZXR1cm4gb3V0ZXIgb3IgaW5uZXIgY29udGVudFxuXG5cbiAgICAgIHJldHVybiBvdXRlclhNTCA/IGN1cnJlbnQubm9kZS5vdXRlckhUTUwgOiBjdXJyZW50Lm5vZGUuaW5uZXJIVE1MO1xuICAgIH0gLy8gQWN0IGFzIHNldHRlciBpZiB3ZSBnb3QgYSBzdHJpbmdcbiAgICAvLyBUaGUgZGVmYXVsdCBmb3IgaW1wb3J0IGlzLCB0aGF0IHRoZSBjdXJyZW50IG5vZGUgaXMgbm90IHJlcGxhY2VkXG5cblxuICAgIG91dGVyWE1MID0gb3V0ZXJYTUwgPT0gbnVsbCA/IGZhbHNlIDogb3V0ZXJYTUw7IC8vIENyZWF0ZSB0ZW1wb3JhcnkgaG9sZGVyXG5cbiAgICBjb25zdCB3ZWxsID0gY3JlYXRlKCd3cmFwcGVyJywgbnMpO1xuICAgIGNvbnN0IGZyYWdtZW50ID0gZ2xvYmFscy5kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7IC8vIER1bXAgcmF3IHN2Z1xuXG4gICAgd2VsbC5pbm5lckhUTUwgPSB4bWxPckZuOyAvLyBUcmFuc3BsYW50IG5vZGVzIGludG8gdGhlIGZyYWdtZW50XG5cbiAgICBmb3IgKGxldCBsZW4gPSB3ZWxsLmNoaWxkcmVuLmxlbmd0aDsgbGVuLS07KSB7XG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZCh3ZWxsLmZpcnN0RWxlbWVudENoaWxkKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudCgpOyAvLyBBZGQgdGhlIHdob2xlIGZyYWdtZW50IGF0IG9uY2VcblxuICAgIHJldHVybiBvdXRlclhNTCA/IHRoaXMucmVwbGFjZShmcmFnbWVudCkgJiYgcGFyZW50IDogdGhpcy5hZGQoZnJhZ21lbnQpO1xuICB9XG5cbn1cbmV4dGVuZChEb20sIHtcbiAgYXR0cixcbiAgZmluZCxcbiAgZmluZE9uZVxufSk7XG5yZWdpc3RlcihEb20sICdEb20nKTtcblxuY2xhc3MgRWxlbWVudCBleHRlbmRzIERvbSB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzKSB7XG4gICAgc3VwZXIobm9kZSwgYXR0cnMpOyAvLyBpbml0aWFsaXplIGRhdGEgb2JqZWN0XG5cbiAgICB0aGlzLmRvbSA9IHt9OyAvLyBjcmVhdGUgY2lyY3VsYXIgcmVmZXJlbmNlXG5cbiAgICB0aGlzLm5vZGUuaW5zdGFuY2UgPSB0aGlzO1xuXG4gICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKCdzdmdqczpkYXRhJykpIHtcbiAgICAgIC8vIHB1bGwgc3ZnanMgZGF0YSBmcm9tIHRoZSBkb20gKGdldEF0dHJpYnV0ZU5TIGRvZXNuJ3Qgd29yayBpbiBodG1sNSlcbiAgICAgIHRoaXMuc2V0RGF0YShKU09OLnBhcnNlKG5vZGUuZ2V0QXR0cmlidXRlKCdzdmdqczpkYXRhJykpIHx8IHt9KTtcbiAgICB9XG4gIH0gLy8gTW92ZSBlbGVtZW50IGJ5IGl0cyBjZW50ZXJcblxuXG4gIGNlbnRlcih4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuY3goeCkuY3koeSk7XG4gIH0gLy8gTW92ZSBieSBjZW50ZXIgb3ZlciB4LWF4aXNcblxuXG4gIGN4KHgpIHtcbiAgICByZXR1cm4geCA9PSBudWxsID8gdGhpcy54KCkgKyB0aGlzLndpZHRoKCkgLyAyIDogdGhpcy54KHggLSB0aGlzLndpZHRoKCkgLyAyKTtcbiAgfSAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHktYXhpc1xuXG5cbiAgY3koeSkge1xuICAgIHJldHVybiB5ID09IG51bGwgPyB0aGlzLnkoKSArIHRoaXMuaGVpZ2h0KCkgLyAyIDogdGhpcy55KHkgLSB0aGlzLmhlaWdodCgpIC8gMik7XG4gIH0gLy8gR2V0IGRlZnNcblxuXG4gIGRlZnMoKSB7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMucm9vdCgpO1xuICAgIHJldHVybiByb290ICYmIHJvb3QuZGVmcygpO1xuICB9IC8vIFJlbGF0aXZlIG1vdmUgb3ZlciB4IGFuZCB5IGF4ZXNcblxuXG4gIGRtb3ZlKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5keCh4KS5keSh5KTtcbiAgfSAvLyBSZWxhdGl2ZSBtb3ZlIG92ZXIgeCBheGlzXG5cblxuICBkeCh4ID0gMCkge1xuICAgIHJldHVybiB0aGlzLngobmV3IFNWR051bWJlcih4KS5wbHVzKHRoaXMueCgpKSk7XG4gIH0gLy8gUmVsYXRpdmUgbW92ZSBvdmVyIHkgYXhpc1xuXG5cbiAgZHkoeSA9IDApIHtcbiAgICByZXR1cm4gdGhpcy55KG5ldyBTVkdOdW1iZXIoeSkucGx1cyh0aGlzLnkoKSkpO1xuICB9XG5cbiAgZ2V0RXZlbnRIb2xkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XG5cblxuICBoZWlnaHQoaGVpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cignaGVpZ2h0JywgaGVpZ2h0KTtcbiAgfSAvLyBNb3ZlIGVsZW1lbnQgdG8gZ2l2ZW4geCBhbmQgeSB2YWx1ZXNcblxuXG4gIG1vdmUoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLngoeCkueSh5KTtcbiAgfSAvLyByZXR1cm4gYXJyYXkgb2YgYWxsIGFuY2VzdG9ycyBvZiBnaXZlbiB0eXBlIHVwIHRvIHRoZSByb290IHN2Z1xuXG5cbiAgcGFyZW50cyh1bnRpbCA9IHRoaXMucm9vdCgpKSB7XG4gICAgY29uc3QgaXNTZWxlY3RvciA9IHR5cGVvZiB1bnRpbCA9PT0gJ3N0cmluZyc7XG5cbiAgICBpZiAoIWlzU2VsZWN0b3IpIHtcbiAgICAgIHVudGlsID0gbWFrZUluc3RhbmNlKHVudGlsKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnRzID0gbmV3IExpc3QoKTtcbiAgICBsZXQgcGFyZW50ID0gdGhpcztcblxuICAgIHdoaWxlICgocGFyZW50ID0gcGFyZW50LnBhcmVudCgpKSAmJiBwYXJlbnQubm9kZSAhPT0gZ2xvYmFscy5kb2N1bWVudCAmJiBwYXJlbnQubm9kZU5hbWUgIT09ICcjZG9jdW1lbnQtZnJhZ21lbnQnKSB7XG4gICAgICBwYXJlbnRzLnB1c2gocGFyZW50KTtcblxuICAgICAgaWYgKCFpc1NlbGVjdG9yICYmIHBhcmVudC5ub2RlID09PSB1bnRpbC5ub2RlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNTZWxlY3RvciAmJiBwYXJlbnQubWF0Y2hlcyh1bnRpbCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnQubm9kZSA9PT0gdGhpcy5yb290KCkubm9kZSkge1xuICAgICAgICAvLyBXZSB3b3JrZWQgb3VyIHdheSB0byB0aGUgcm9vdCBhbmQgZGlkbid0IG1hdGNoIGB1bnRpbGBcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudHM7XG4gIH0gLy8gR2V0IHJlZmVyZW5jZWQgZWxlbWVudCBmb3JtIGF0dHJpYnV0ZSB2YWx1ZVxuXG5cbiAgcmVmZXJlbmNlKGF0dHIpIHtcbiAgICBhdHRyID0gdGhpcy5hdHRyKGF0dHIpO1xuICAgIGlmICghYXR0cikgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgbSA9IChhdHRyICsgJycpLm1hdGNoKHJlZmVyZW5jZSk7XG4gICAgcmV0dXJuIG0gPyBtYWtlSW5zdGFuY2UobVsxXSkgOiBudWxsO1xuICB9IC8vIEdldCBwYXJlbnQgZG9jdW1lbnRcblxuXG4gIHJvb3QoKSB7XG4gICAgY29uc3QgcCA9IHRoaXMucGFyZW50KGdldENsYXNzKHJvb3QpKTtcbiAgICByZXR1cm4gcCAmJiBwLnJvb3QoKTtcbiAgfSAvLyBzZXQgZ2l2ZW4gZGF0YSB0byB0aGUgZWxlbWVudHMgZGF0YSBwcm9wZXJ0eVxuXG5cbiAgc2V0RGF0YShvKSB7XG4gICAgdGhpcy5kb20gPSBvO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIFNldCBlbGVtZW50IHNpemUgdG8gZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxuXG5cbiAgc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodCk7XG4gICAgcmV0dXJuIHRoaXMud2lkdGgobmV3IFNWR051bWJlcihwLndpZHRoKSkuaGVpZ2h0KG5ldyBTVkdOdW1iZXIocC5oZWlnaHQpKTtcbiAgfSAvLyBTZXQgd2lkdGggb2YgZWxlbWVudFxuXG5cbiAgd2lkdGgod2lkdGgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCd3aWR0aCcsIHdpZHRoKTtcbiAgfSAvLyB3cml0ZSBzdmdqcyBkYXRhIHRvIHRoZSBkb21cblxuXG4gIHdyaXRlRGF0YVRvRG9tKCkge1xuICAgIC8vIHJlbW92ZSBwcmV2aW91c2x5IHNldCBkYXRhXG4gICAgdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZSgnc3ZnanM6ZGF0YScpO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuZG9tKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoJ3N2Z2pzOmRhdGEnLCBKU09OLnN0cmluZ2lmeSh0aGlzLmRvbSkpOyAvLyBzZWUgIzQyOFxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci53cml0ZURhdGFUb0RvbSgpO1xuICB9IC8vIE1vdmUgb3ZlciB4LWF4aXNcblxuXG4gIHgoeCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ3gnLCB4KTtcbiAgfSAvLyBNb3ZlIG92ZXIgeS1heGlzXG5cblxuICB5KHkpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCd5JywgeSk7XG4gIH1cblxufVxuZXh0ZW5kKEVsZW1lbnQsIHtcbiAgYmJveCxcbiAgcmJveCxcbiAgaW5zaWRlLFxuICBwb2ludCxcbiAgY3RtLFxuICBzY3JlZW5DVE1cbn0pO1xucmVnaXN0ZXIoRWxlbWVudCwgJ0VsZW1lbnQnKTtcblxuY29uc3Qgc3VnYXIgPSB7XG4gIHN0cm9rZTogWydjb2xvcicsICd3aWR0aCcsICdvcGFjaXR5JywgJ2xpbmVjYXAnLCAnbGluZWpvaW4nLCAnbWl0ZXJsaW1pdCcsICdkYXNoYXJyYXknLCAnZGFzaG9mZnNldCddLFxuICBmaWxsOiBbJ2NvbG9yJywgJ29wYWNpdHknLCAncnVsZSddLFxuICBwcmVmaXg6IGZ1bmN0aW9uICh0LCBhKSB7XG4gICAgcmV0dXJuIGEgPT09ICdjb2xvcicgPyB0IDogdCArICctJyArIGE7XG4gIH1cbn0gLy8gQWRkIHN1Z2FyIGZvciBmaWxsIGFuZCBzdHJva2VcbjtcblsnZmlsbCcsICdzdHJva2UnXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gIGNvbnN0IGV4dGVuc2lvbiA9IHt9O1xuICBsZXQgaTtcblxuICBleHRlbnNpb25bbV0gPSBmdW5jdGlvbiAobykge1xuICAgIGlmICh0eXBlb2YgbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIobSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvID09PSAnc3RyaW5nJyB8fCBvIGluc3RhbmNlb2YgQ29sb3IgfHwgQ29sb3IuaXNSZ2IobykgfHwgbyBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuYXR0cihtLCBvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2V0IGFsbCBhdHRyaWJ1dGVzIGZyb20gc3VnYXIuZmlsbCBhbmQgc3VnYXIuc3Ryb2tlIGxpc3RcbiAgICAgIGZvciAoaSA9IHN1Z2FyW21dLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChvW3N1Z2FyW21dW2ldXSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5hdHRyKHN1Z2FyLnByZWZpeChtLCBzdWdhclttXVtpXSksIG9bc3VnYXJbbV1baV1dKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJlZ2lzdGVyTWV0aG9kcyhbJ0VsZW1lbnQnLCAnUnVubmVyJ10sIGV4dGVuc2lvbik7XG59KTtcbnJlZ2lzdGVyTWV0aG9kcyhbJ0VsZW1lbnQnLCAnUnVubmVyJ10sIHtcbiAgLy8gTGV0IHRoZSB1c2VyIHNldCB0aGUgbWF0cml4IGRpcmVjdGx5XG4gIG1hdHJpeDogZnVuY3Rpb24gKG1hdCwgYiwgYywgZCwgZSwgZikge1xuICAgIC8vIEFjdCBhcyBhIGdldHRlclxuICAgIGlmIChtYXQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBNYXRyaXgodGhpcyk7XG4gICAgfSAvLyBBY3QgYXMgYSBzZXR0ZXIsIHRoZSB1c2VyIGNhbiBwYXNzIGEgbWF0cml4IG9yIGEgc2V0IG9mIG51bWJlcnNcblxuXG4gICAgcmV0dXJuIHRoaXMuYXR0cigndHJhbnNmb3JtJywgbmV3IE1hdHJpeChtYXQsIGIsIGMsIGQsIGUsIGYpKTtcbiAgfSxcbiAgLy8gTWFwIHJvdGF0aW9uIHRvIHRyYW5zZm9ybVxuICByb3RhdGU6IGZ1bmN0aW9uIChhbmdsZSwgY3gsIGN5KSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHtcbiAgICAgIHJvdGF0ZTogYW5nbGUsXG4gICAgICBveDogY3gsXG4gICAgICBveTogY3lcbiAgICB9LCB0cnVlKTtcbiAgfSxcbiAgLy8gTWFwIHNrZXcgdG8gdHJhbnNmb3JtXG4gIHNrZXc6IGZ1bmN0aW9uICh4LCB5LCBjeCwgY3kpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAzID8gdGhpcy50cmFuc2Zvcm0oe1xuICAgICAgc2tldzogeCxcbiAgICAgIG94OiB5LFxuICAgICAgb3k6IGN4XG4gICAgfSwgdHJ1ZSkgOiB0aGlzLnRyYW5zZm9ybSh7XG4gICAgICBza2V3OiBbeCwgeV0sXG4gICAgICBveDogY3gsXG4gICAgICBveTogY3lcbiAgICB9LCB0cnVlKTtcbiAgfSxcbiAgc2hlYXI6IGZ1bmN0aW9uIChsYW0sIGN4LCBjeSkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh7XG4gICAgICBzaGVhcjogbGFtLFxuICAgICAgb3g6IGN4LFxuICAgICAgb3k6IGN5XG4gICAgfSwgdHJ1ZSk7XG4gIH0sXG4gIC8vIE1hcCBzY2FsZSB0byB0cmFuc2Zvcm1cbiAgc2NhbGU6IGZ1bmN0aW9uICh4LCB5LCBjeCwgY3kpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAzID8gdGhpcy50cmFuc2Zvcm0oe1xuICAgICAgc2NhbGU6IHgsXG4gICAgICBveDogeSxcbiAgICAgIG95OiBjeFxuICAgIH0sIHRydWUpIDogdGhpcy50cmFuc2Zvcm0oe1xuICAgICAgc2NhbGU6IFt4LCB5XSxcbiAgICAgIG94OiBjeCxcbiAgICAgIG95OiBjeVxuICAgIH0sIHRydWUpO1xuICB9LFxuICAvLyBNYXAgdHJhbnNsYXRlIHRvIHRyYW5zZm9ybVxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHtcbiAgICAgIHRyYW5zbGF0ZTogW3gsIHldXG4gICAgfSwgdHJ1ZSk7XG4gIH0sXG4gIC8vIE1hcCByZWxhdGl2ZSB0cmFuc2xhdGlvbnMgdG8gdHJhbnNmb3JtXG4gIHJlbGF0aXZlOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh7XG4gICAgICByZWxhdGl2ZTogW3gsIHldXG4gICAgfSwgdHJ1ZSk7XG4gIH0sXG4gIC8vIE1hcCBmbGlwIHRvIHRyYW5zZm9ybVxuICBmbGlwOiBmdW5jdGlvbiAoZGlyZWN0aW9uID0gJ2JvdGgnLCBvcmlnaW4gPSAnY2VudGVyJykge1xuICAgIGlmICgneHlib3RodHJ1ZScuaW5kZXhPZihkaXJlY3Rpb24pID09PSAtMSkge1xuICAgICAgb3JpZ2luID0gZGlyZWN0aW9uO1xuICAgICAgZGlyZWN0aW9uID0gJ2JvdGgnO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh7XG4gICAgICBmbGlwOiBkaXJlY3Rpb24sXG4gICAgICBvcmlnaW46IG9yaWdpblxuICAgIH0sIHRydWUpO1xuICB9LFxuICAvLyBPcGFjaXR5XG4gIG9wYWNpdHk6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ29wYWNpdHknLCB2YWx1ZSk7XG4gIH1cbn0pO1xucmVnaXN0ZXJNZXRob2RzKCdyYWRpdXMnLCB7XG4gIC8vIEFkZCB4IGFuZCB5IHJhZGl1c1xuICByYWRpdXM6IGZ1bmN0aW9uICh4LCB5ID0geCkge1xuICAgIGNvbnN0IHR5cGUgPSAodGhpcy5fZWxlbWVudCB8fCB0aGlzKS50eXBlO1xuICAgIHJldHVybiB0eXBlID09PSAncmFkaWFsR3JhZGllbnQnID8gdGhpcy5hdHRyKCdyJywgbmV3IFNWR051bWJlcih4KSkgOiB0aGlzLnJ4KHgpLnJ5KHkpO1xuICB9XG59KTtcbnJlZ2lzdGVyTWV0aG9kcygnUGF0aCcsIHtcbiAgLy8gR2V0IHBhdGggbGVuZ3RoXG4gIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0VG90YWxMZW5ndGgoKTtcbiAgfSxcbiAgLy8gR2V0IHBvaW50IGF0IGxlbmd0aFxuICBwb2ludEF0OiBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLm5vZGUuZ2V0UG9pbnRBdExlbmd0aChsZW5ndGgpKTtcbiAgfVxufSk7XG5yZWdpc3Rlck1ldGhvZHMoWydFbGVtZW50JywgJ1J1bm5lciddLCB7XG4gIC8vIFNldCBmb250XG4gIGZvbnQ6IGZ1bmN0aW9uIChhLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yICh2IGluIGEpIHRoaXMuZm9udCh2LCBhW3ZdKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEgPT09ICdsZWFkaW5nJyA/IHRoaXMubGVhZGluZyh2KSA6IGEgPT09ICdhbmNob3InID8gdGhpcy5hdHRyKCd0ZXh0LWFuY2hvcicsIHYpIDogYSA9PT0gJ3NpemUnIHx8IGEgPT09ICdmYW1pbHknIHx8IGEgPT09ICd3ZWlnaHQnIHx8IGEgPT09ICdzdHJldGNoJyB8fCBhID09PSAndmFyaWFudCcgfHwgYSA9PT0gJ3N0eWxlJyA/IHRoaXMuYXR0cignZm9udC0nICsgYSwgdikgOiB0aGlzLmF0dHIoYSwgdik7XG4gIH1cbn0pOyAvLyBBZGQgZXZlbnRzIHRvIGVsZW1lbnRzXG5cbmNvbnN0IG1ldGhvZHMgPSBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdtb3VzZW1vdmUnLCAnbW91c2VlbnRlcicsICdtb3VzZWxlYXZlJywgJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNobGVhdmUnLCAndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnXS5yZWR1Y2UoZnVuY3Rpb24gKGxhc3QsIGV2ZW50KSB7XG4gIC8vIGFkZCBldmVudCB0byBFbGVtZW50XG4gIGNvbnN0IGZuID0gZnVuY3Rpb24gKGYpIHtcbiAgICBpZiAoZiA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5vZmYoZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKGV2ZW50LCBmKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBsYXN0W2V2ZW50XSA9IGZuO1xuICByZXR1cm4gbGFzdDtcbn0sIHt9KTtcbnJlZ2lzdGVyTWV0aG9kcygnRWxlbWVudCcsIG1ldGhvZHMpO1xuXG5mdW5jdGlvbiB1bnRyYW5zZm9ybSgpIHtcbiAgcmV0dXJuIHRoaXMuYXR0cigndHJhbnNmb3JtJywgbnVsbCk7XG59IC8vIG1lcmdlIHRoZSB3aG9sZSB0cmFuc2Zvcm1hdGlvbiBjaGFpbiBpbnRvIG9uZSBtYXRyaXggYW5kIHJldHVybnMgaXRcblxuZnVuY3Rpb24gbWF0cml4aWZ5KCkge1xuICBjb25zdCBtYXRyaXggPSAodGhpcy5hdHRyKCd0cmFuc2Zvcm0nKSB8fCAnJyAvLyBzcGxpdCB0cmFuc2Zvcm1hdGlvbnNcbiAgKS5zcGxpdCh0cmFuc2Zvcm1zKS5zbGljZSgwLCAtMSkubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAvLyBnZW5lcmF0ZSBrZXkgPT4gdmFsdWUgcGFpcnNcbiAgICBjb25zdCBrdiA9IHN0ci50cmltKCkuc3BsaXQoJygnKTtcbiAgICByZXR1cm4gW2t2WzBdLCBrdlsxXS5zcGxpdChkZWxpbWl0ZXIpLm1hcChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIpO1xuICAgIH0pXTtcbiAgfSkucmV2ZXJzZSgpIC8vIG1lcmdlIGV2ZXJ5IHRyYW5zZm9ybWF0aW9uIGludG8gb25lIG1hdHJpeFxuICAucmVkdWNlKGZ1bmN0aW9uIChtYXRyaXgsIHRyYW5zZm9ybSkge1xuICAgIGlmICh0cmFuc2Zvcm1bMF0gPT09ICdtYXRyaXgnKSB7XG4gICAgICByZXR1cm4gbWF0cml4LmxtdWx0aXBseShNYXRyaXguZnJvbUFycmF5KHRyYW5zZm9ybVsxXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRyaXhbdHJhbnNmb3JtWzBdXS5hcHBseShtYXRyaXgsIHRyYW5zZm9ybVsxXSk7XG4gIH0sIG5ldyBNYXRyaXgoKSk7XG4gIHJldHVybiBtYXRyaXg7XG59IC8vIGFkZCBhbiBlbGVtZW50IHRvIGFub3RoZXIgcGFyZW50IHdpdGhvdXQgY2hhbmdpbmcgdGhlIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvbiB0aGUgc2NyZWVuXG5cbmZ1bmN0aW9uIHRvUGFyZW50KHBhcmVudCwgaSkge1xuICBpZiAodGhpcyA9PT0gcGFyZW50KSByZXR1cm4gdGhpcztcbiAgY29uc3QgY3RtID0gdGhpcy5zY3JlZW5DVE0oKTtcbiAgY29uc3QgcEN0bSA9IHBhcmVudC5zY3JlZW5DVE0oKS5pbnZlcnNlKCk7XG4gIHRoaXMuYWRkVG8ocGFyZW50LCBpKS51bnRyYW5zZm9ybSgpLnRyYW5zZm9ybShwQ3RtLm11bHRpcGx5KGN0bSkpO1xuICByZXR1cm4gdGhpcztcbn0gLy8gc2FtZSBhcyBhYm92ZSB3aXRoIHBhcmVudCBlcXVhbHMgcm9vdC1zdmdcblxuZnVuY3Rpb24gdG9Sb290KGkpIHtcbiAgcmV0dXJuIHRoaXMudG9QYXJlbnQodGhpcy5yb290KCksIGkpO1xufSAvLyBBZGQgdHJhbnNmb3JtYXRpb25zXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybShvLCByZWxhdGl2ZSkge1xuICAvLyBBY3QgYXMgYSBnZXR0ZXIgaWYgbm8gb2JqZWN0IHdhcyBwYXNzZWRcbiAgaWYgKG8gPT0gbnVsbCB8fCB0eXBlb2YgbyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBkZWNvbXBvc2VkID0gbmV3IE1hdHJpeCh0aGlzKS5kZWNvbXBvc2UoKTtcbiAgICByZXR1cm4gbyA9PSBudWxsID8gZGVjb21wb3NlZCA6IGRlY29tcG9zZWRbb107XG4gIH1cblxuICBpZiAoIU1hdHJpeC5pc01hdHJpeExpa2UobykpIHtcbiAgICAvLyBTZXQgdGhlIG9yaWdpbiBhY2NvcmRpbmcgdG8gdGhlIGRlZmluZWQgdHJhbnNmb3JtXG4gICAgbyA9IHsgLi4ubyxcbiAgICAgIG9yaWdpbjogZ2V0T3JpZ2luKG8sIHRoaXMpXG4gICAgfTtcbiAgfSAvLyBUaGUgdXNlciBjYW4gcGFzcyBhIGJvb2xlYW4sIGFuIEVsZW1lbnQgb3IgYW4gTWF0cml4IG9yIG5vdGhpbmdcblxuXG4gIGNvbnN0IGNsZWFuUmVsYXRpdmUgPSByZWxhdGl2ZSA9PT0gdHJ1ZSA/IHRoaXMgOiByZWxhdGl2ZSB8fCBmYWxzZTtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IE1hdHJpeChjbGVhblJlbGF0aXZlKS50cmFuc2Zvcm0obyk7XG4gIHJldHVybiB0aGlzLmF0dHIoJ3RyYW5zZm9ybScsIHJlc3VsdCk7XG59XG5yZWdpc3Rlck1ldGhvZHMoJ0VsZW1lbnQnLCB7XG4gIHVudHJhbnNmb3JtLFxuICBtYXRyaXhpZnksXG4gIHRvUGFyZW50LFxuICB0b1Jvb3QsXG4gIHRyYW5zZm9ybVxufSk7XG5cbmNsYXNzIENvbnRhaW5lciBleHRlbmRzIEVsZW1lbnQge1xuICBmbGF0dGVuKHBhcmVudCA9IHRoaXMsIGluZGV4KSB7XG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQ29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYXR0ZW4oKS51bmdyb3VwKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB1bmdyb3VwKHBhcmVudCA9IHRoaXMucGFyZW50KCksIGluZGV4ID0gcGFyZW50LmluZGV4KHRoaXMpKSB7XG4gICAgLy8gd2hlbiBwYXJlbnQgIT0gdGhpcywgd2Ugd2FudCBhcHBlbmQgYWxsIGVsZW1lbnRzIHRvIHRoZSBlbmRcbiAgICBpbmRleCA9IGluZGV4ID09PSAtMSA/IHBhcmVudC5jaGlsZHJlbigpLmxlbmd0aCA6IGluZGV4O1xuICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoaSwgY2hpbGRyZW4pIHtcbiAgICAgIC8vIHJldmVyc2UgZWFjaFxuICAgICAgcmV0dXJuIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIGkgLSAxXS50b1BhcmVudChwYXJlbnQsIGluZGV4KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG59XG5yZWdpc3RlcihDb250YWluZXIsICdDb250YWluZXInKTtcblxuY2xhc3MgRGVmcyBleHRlbmRzIENvbnRhaW5lciB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygnZGVmcycsIG5vZGUpLCBhdHRycyk7XG4gIH1cblxuICBmbGF0dGVuKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdW5ncm91cCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59XG5yZWdpc3RlcihEZWZzLCAnRGVmcycpO1xuXG5jbGFzcyBTaGFwZSBleHRlbmRzIEVsZW1lbnQge31cbnJlZ2lzdGVyKFNoYXBlLCAnU2hhcGUnKTtcblxuZnVuY3Rpb24gcngocngpIHtcbiAgcmV0dXJuIHRoaXMuYXR0cigncngnLCByeCk7XG59IC8vIFJhZGl1cyB5IHZhbHVlXG5cbmZ1bmN0aW9uIHJ5KHJ5KSB7XG4gIHJldHVybiB0aGlzLmF0dHIoJ3J5JywgcnkpO1xufSAvLyBNb3ZlIG92ZXIgeC1heGlzXG5cbmZ1bmN0aW9uIHgkMyh4KSB7XG4gIHJldHVybiB4ID09IG51bGwgPyB0aGlzLmN4KCkgLSB0aGlzLnJ4KCkgOiB0aGlzLmN4KHggKyB0aGlzLnJ4KCkpO1xufSAvLyBNb3ZlIG92ZXIgeS1heGlzXG5cbmZ1bmN0aW9uIHkkMyh5KSB7XG4gIHJldHVybiB5ID09IG51bGwgPyB0aGlzLmN5KCkgLSB0aGlzLnJ5KCkgOiB0aGlzLmN5KHkgKyB0aGlzLnJ5KCkpO1xufSAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHgtYXhpc1xuXG5mdW5jdGlvbiBjeCQxKHgpIHtcbiAgcmV0dXJuIHRoaXMuYXR0cignY3gnLCB4KTtcbn0gLy8gTW92ZSBieSBjZW50ZXIgb3ZlciB5LWF4aXNcblxuZnVuY3Rpb24gY3kkMSh5KSB7XG4gIHJldHVybiB0aGlzLmF0dHIoJ2N5JywgeSk7XG59IC8vIFNldCB3aWR0aCBvZiBlbGVtZW50XG5cbmZ1bmN0aW9uIHdpZHRoJDIod2lkdGgpIHtcbiAgcmV0dXJuIHdpZHRoID09IG51bGwgPyB0aGlzLnJ4KCkgKiAyIDogdGhpcy5yeChuZXcgU1ZHTnVtYmVyKHdpZHRoKS5kaXZpZGUoMikpO1xufSAvLyBTZXQgaGVpZ2h0IG9mIGVsZW1lbnRcblxuZnVuY3Rpb24gaGVpZ2h0JDIoaGVpZ2h0KSB7XG4gIHJldHVybiBoZWlnaHQgPT0gbnVsbCA/IHRoaXMucnkoKSAqIDIgOiB0aGlzLnJ5KG5ldyBTVkdOdW1iZXIoaGVpZ2h0KS5kaXZpZGUoMikpO1xufVxuXG52YXIgY2lyY2xlZCA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICByeDogcngsXG4gIHJ5OiByeSxcbiAgeDogeCQzLFxuICB5OiB5JDMsXG4gIGN4OiBjeCQxLFxuICBjeTogY3kkMSxcbiAgd2lkdGg6IHdpZHRoJDIsXG4gIGhlaWdodDogaGVpZ2h0JDJcbn07XG5cbmNsYXNzIEVsbGlwc2UgZXh0ZW5kcyBTaGFwZSB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygnZWxsaXBzZScsIG5vZGUpLCBhdHRycyk7XG4gIH1cblxuICBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICByZXR1cm4gdGhpcy5yeChuZXcgU1ZHTnVtYmVyKHAud2lkdGgpLmRpdmlkZSgyKSkucnkobmV3IFNWR051bWJlcihwLmhlaWdodCkuZGl2aWRlKDIpKTtcbiAgfVxuXG59XG5leHRlbmQoRWxsaXBzZSwgY2lyY2xlZCk7XG5yZWdpc3Rlck1ldGhvZHMoJ0NvbnRhaW5lcicsIHtcbiAgLy8gQ3JlYXRlIGFuIGVsbGlwc2VcbiAgZWxsaXBzZTogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHdpZHRoID0gMCwgaGVpZ2h0ID0gd2lkdGgpIHtcbiAgICByZXR1cm4gdGhpcy5wdXQobmV3IEVsbGlwc2UoKSkuc2l6ZSh3aWR0aCwgaGVpZ2h0KS5tb3ZlKDAsIDApO1xuICB9KVxufSk7XG5yZWdpc3RlcihFbGxpcHNlLCAnRWxsaXBzZScpO1xuXG5jbGFzcyBGcmFnbWVudCBleHRlbmRzIERvbSB7XG4gIGNvbnN0cnVjdG9yKG5vZGUgPSBnbG9iYWxzLmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSkge1xuICAgIHN1cGVyKG5vZGUpO1xuICB9IC8vIEltcG9ydCAvIEV4cG9ydCByYXcgeG1sXG5cblxuICB4bWwoeG1sT3JGbiwgb3V0ZXJYTUwsIG5zKSB7XG4gICAgaWYgKHR5cGVvZiB4bWxPckZuID09PSAnYm9vbGVhbicpIHtcbiAgICAgIG5zID0gb3V0ZXJYTUw7XG4gICAgICBvdXRlclhNTCA9IHhtbE9yRm47XG4gICAgICB4bWxPckZuID0gbnVsbDtcbiAgICB9IC8vIGJlY2F1c2UgdGhpcyBpcyBhIGZyYWdtZW50IHdlIGhhdmUgdG8gcHV0IGFsbCBlbGVtZW50cyBpbnRvIGEgd3JhcHBlciBmaXJzdFxuICAgIC8vIGJlZm9yZSB3ZSBjYW4gZ2V0IHRoZSBpbm5lclhNTCBmcm9tIGl0XG5cblxuICAgIGlmICh4bWxPckZuID09IG51bGwgfHwgdHlwZW9mIHhtbE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IHdyYXBwZXIgPSBuZXcgRG9tKGNyZWF0ZSgnd3JhcHBlcicsIG5zKSk7XG4gICAgICB3cmFwcGVyLmFkZCh0aGlzLm5vZGUuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgIHJldHVybiB3cmFwcGVyLnhtbChmYWxzZSwgbnMpO1xuICAgIH0gLy8gQWN0IGFzIHNldHRlciBpZiB3ZSBnb3QgYSBzdHJpbmdcblxuXG4gICAgcmV0dXJuIHN1cGVyLnhtbCh4bWxPckZuLCBmYWxzZSwgbnMpO1xuICB9XG5cbn1cblxucmVnaXN0ZXIoRnJhZ21lbnQsICdGcmFnbWVudCcpO1xuXG5mdW5jdGlvbiBmcm9tKHgsIHkpIHtcbiAgcmV0dXJuICh0aGlzLl9lbGVtZW50IHx8IHRoaXMpLnR5cGUgPT09ICdyYWRpYWxHcmFkaWVudCcgPyB0aGlzLmF0dHIoe1xuICAgIGZ4OiBuZXcgU1ZHTnVtYmVyKHgpLFxuICAgIGZ5OiBuZXcgU1ZHTnVtYmVyKHkpXG4gIH0pIDogdGhpcy5hdHRyKHtcbiAgICB4MTogbmV3IFNWR051bWJlcih4KSxcbiAgICB5MTogbmV3IFNWR051bWJlcih5KVxuICB9KTtcbn1cbmZ1bmN0aW9uIHRvKHgsIHkpIHtcbiAgcmV0dXJuICh0aGlzLl9lbGVtZW50IHx8IHRoaXMpLnR5cGUgPT09ICdyYWRpYWxHcmFkaWVudCcgPyB0aGlzLmF0dHIoe1xuICAgIGN4OiBuZXcgU1ZHTnVtYmVyKHgpLFxuICAgIGN5OiBuZXcgU1ZHTnVtYmVyKHkpXG4gIH0pIDogdGhpcy5hdHRyKHtcbiAgICB4MjogbmV3IFNWR051bWJlcih4KSxcbiAgICB5MjogbmV3IFNWR051bWJlcih5KVxuICB9KTtcbn1cblxudmFyIGdyYWRpZW50ZWQgPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZnJvbTogZnJvbSxcbiAgdG86IHRvXG59O1xuXG5jbGFzcyBHcmFkaWVudCBleHRlbmRzIENvbnRhaW5lciB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGF0dHJzKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KHR5cGUgKyAnR3JhZGllbnQnLCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyBudWxsIDogdHlwZSksIGF0dHJzKTtcbiAgfSAvLyBjdXN0b20gYXR0ciB0byBoYW5kbGUgdHJhbnNmb3JtXG5cblxuICBhdHRyKGEsIGIsIGMpIHtcbiAgICBpZiAoYSA9PT0gJ3RyYW5zZm9ybScpIGEgPSAnZ3JhZGllbnRUcmFuc2Zvcm0nO1xuICAgIHJldHVybiBzdXBlci5hdHRyKGEsIGIsIGMpO1xuICB9XG5cbiAgYmJveCgpIHtcbiAgICByZXR1cm4gbmV3IEJveCgpO1xuICB9XG5cbiAgdGFyZ2V0cygpIHtcbiAgICByZXR1cm4gYmFzZUZpbmQoJ3N2ZyBbZmlsbCo9JyArIHRoaXMuaWQoKSArICddJyk7XG4gIH0gLy8gQWxpYXMgc3RyaW5nIGNvbnZlcnNpb24gdG8gZmlsbFxuXG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudXJsKCk7XG4gIH0gLy8gVXBkYXRlIGdyYWRpZW50XG5cblxuICB1cGRhdGUoYmxvY2spIHtcbiAgICAvLyByZW1vdmUgYWxsIHN0b3BzXG4gICAgdGhpcy5jbGVhcigpOyAvLyBpbnZva2UgcGFzc2VkIGJsb2NrXG5cbiAgICBpZiAodHlwZW9mIGJsb2NrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBibG9jay5jYWxsKHRoaXMsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIFJldHVybiB0aGUgZmlsbCBpZFxuXG5cbiAgdXJsKCkge1xuICAgIHJldHVybiAndXJsKCMnICsgdGhpcy5pZCgpICsgJyknO1xuICB9XG5cbn1cbmV4dGVuZChHcmFkaWVudCwgZ3JhZGllbnRlZCk7XG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBDcmVhdGUgZ3JhZGllbnQgZWxlbWVudCBpbiBkZWZzXG4gICAgZ3JhZGllbnQoLi4uYXJncykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLmdyYWRpZW50KC4uLmFyZ3MpO1xuICAgIH1cblxuICB9LFxuICAvLyBkZWZpbmUgZ3JhZGllbnRcbiAgRGVmczoge1xuICAgIGdyYWRpZW50OiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAodHlwZSwgYmxvY2spIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgR3JhZGllbnQodHlwZSkpLnVwZGF0ZShibG9jayk7XG4gICAgfSlcbiAgfVxufSk7XG5yZWdpc3RlcihHcmFkaWVudCwgJ0dyYWRpZW50Jyk7XG5cbmNsYXNzIFBhdHRlcm4gZXh0ZW5kcyBDb250YWluZXIge1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdwYXR0ZXJuJywgbm9kZSksIGF0dHJzKTtcbiAgfSAvLyBjdXN0b20gYXR0ciB0byBoYW5kbGUgdHJhbnNmb3JtXG5cblxuICBhdHRyKGEsIGIsIGMpIHtcbiAgICBpZiAoYSA9PT0gJ3RyYW5zZm9ybScpIGEgPSAncGF0dGVyblRyYW5zZm9ybSc7XG4gICAgcmV0dXJuIHN1cGVyLmF0dHIoYSwgYiwgYyk7XG4gIH1cblxuICBiYm94KCkge1xuICAgIHJldHVybiBuZXcgQm94KCk7XG4gIH1cblxuICB0YXJnZXRzKCkge1xuICAgIHJldHVybiBiYXNlRmluZCgnc3ZnIFtmaWxsKj0nICsgdGhpcy5pZCgpICsgJ10nKTtcbiAgfSAvLyBBbGlhcyBzdHJpbmcgY29udmVyc2lvbiB0byBmaWxsXG5cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy51cmwoKTtcbiAgfSAvLyBVcGRhdGUgcGF0dGVybiBieSByZWJ1aWxkaW5nXG5cblxuICB1cGRhdGUoYmxvY2spIHtcbiAgICAvLyByZW1vdmUgY29udGVudFxuICAgIHRoaXMuY2xlYXIoKTsgLy8gaW52b2tlIHBhc3NlZCBibG9ja1xuXG4gICAgaWYgKHR5cGVvZiBibG9jayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYmxvY2suY2FsbCh0aGlzLCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBSZXR1cm4gdGhlIGZpbGwgaWRcblxuXG4gIHVybCgpIHtcbiAgICByZXR1cm4gJ3VybCgjJyArIHRoaXMuaWQoKSArICcpJztcbiAgfVxuXG59XG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBDcmVhdGUgcGF0dGVybiBlbGVtZW50IGluIGRlZnNcbiAgICBwYXR0ZXJuKC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5wYXR0ZXJuKC4uLmFyZ3MpO1xuICAgIH1cblxuICB9LFxuICBEZWZzOiB7XG4gICAgcGF0dGVybjogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIGJsb2NrKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFBhdHRlcm4oKSkudXBkYXRlKGJsb2NrKS5hdHRyKHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgcGF0dGVyblVuaXRzOiAndXNlclNwYWNlT25Vc2UnXG4gICAgICB9KTtcbiAgICB9KVxuICB9XG59KTtcbnJlZ2lzdGVyKFBhdHRlcm4sICdQYXR0ZXJuJyk7XG5cbmNsYXNzIEltYWdlIGV4dGVuZHMgU2hhcGUge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ2ltYWdlJywgbm9kZSksIGF0dHJzKTtcbiAgfSAvLyAocmUpbG9hZCBpbWFnZVxuXG5cbiAgbG9hZCh1cmwsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF1cmwpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IGltZyA9IG5ldyBnbG9iYWxzLndpbmRvdy5JbWFnZSgpO1xuICAgIG9uKGltZywgJ2xvYWQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgY29uc3QgcCA9IHRoaXMucGFyZW50KFBhdHRlcm4pOyAvLyBlbnN1cmUgaW1hZ2Ugc2l6ZVxuXG4gICAgICBpZiAodGhpcy53aWR0aCgpID09PSAwICYmIHRoaXMuaGVpZ2h0KCkgPT09IDApIHtcbiAgICAgICAgdGhpcy5zaXplKGltZy53aWR0aCwgaW1nLmhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwIGluc3RhbmNlb2YgUGF0dGVybikge1xuICAgICAgICAvLyBlbnN1cmUgcGF0dGVybiBzaXplIGlmIG5vdCBzZXRcbiAgICAgICAgaWYgKHAud2lkdGgoKSA9PT0gMCAmJiBwLmhlaWdodCgpID09PSAwKSB7XG4gICAgICAgICAgcC5zaXplKHRoaXMud2lkdGgoKSwgdGhpcy5oZWlnaHQoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIGUpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIG9uKGltZywgJ2xvYWQgZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBkb250IGZvcmdldCB0byB1bmJpbmQgbWVtb3J5IGxlYWtpbmcgZXZlbnRzXG4gICAgICBvZmYoaW1nKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdocmVmJywgaW1nLnNyYyA9IHVybCwgeGxpbmspO1xuICB9XG5cbn1cbnJlZ2lzdGVyQXR0ckhvb2soZnVuY3Rpb24gKGF0dHIsIHZhbCwgX3RoaXMpIHtcbiAgLy8gY29udmVydCBpbWFnZSBmaWxsIGFuZCBzdHJva2UgdG8gcGF0dGVybnNcbiAgaWYgKGF0dHIgPT09ICdmaWxsJyB8fCBhdHRyID09PSAnc3Ryb2tlJykge1xuICAgIGlmIChpc0ltYWdlLnRlc3QodmFsKSkge1xuICAgICAgdmFsID0gX3RoaXMucm9vdCgpLmRlZnMoKS5pbWFnZSh2YWwpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh2YWwgaW5zdGFuY2VvZiBJbWFnZSkge1xuICAgIHZhbCA9IF90aGlzLnJvb3QoKS5kZWZzKCkucGF0dGVybigwLCAwLCBwYXR0ZXJuID0+IHtcbiAgICAgIHBhdHRlcm4uYWRkKHZhbCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufSk7XG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBjcmVhdGUgaW1hZ2UgZWxlbWVudCwgbG9hZCBpbWFnZSBhbmQgc2V0IGl0cyBzaXplXG4gICAgaW1hZ2U6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IEltYWdlKCkpLnNpemUoMCwgMCkubG9hZChzb3VyY2UsIGNhbGxiYWNrKTtcbiAgICB9KVxuICB9XG59KTtcbnJlZ2lzdGVyKEltYWdlLCAnSW1hZ2UnKTtcblxuY2xhc3MgUG9pbnRBcnJheSBleHRlbmRzIFNWR0FycmF5IHtcbiAgLy8gR2V0IGJvdW5kaW5nIGJveCBvZiBwb2ludHNcbiAgYmJveCgpIHtcbiAgICBsZXQgbWF4WCA9IC1JbmZpbml0eTtcbiAgICBsZXQgbWF4WSA9IC1JbmZpbml0eTtcbiAgICBsZXQgbWluWCA9IEluZmluaXR5O1xuICAgIGxldCBtaW5ZID0gSW5maW5pdHk7XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgbWF4WCA9IE1hdGgubWF4KGVsWzBdLCBtYXhYKTtcbiAgICAgIG1heFkgPSBNYXRoLm1heChlbFsxXSwgbWF4WSk7XG4gICAgICBtaW5YID0gTWF0aC5taW4oZWxbMF0sIG1pblgpO1xuICAgICAgbWluWSA9IE1hdGgubWluKGVsWzFdLCBtaW5ZKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IEJveChtaW5YLCBtaW5ZLCBtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICB9IC8vIE1vdmUgcG9pbnQgc3RyaW5nXG5cblxuICBtb3ZlKHgsIHkpIHtcbiAgICBjb25zdCBib3ggPSB0aGlzLmJib3goKTsgLy8gZ2V0IHJlbGF0aXZlIG9mZnNldFxuXG4gICAgeCAtPSBib3gueDtcbiAgICB5IC09IGJveC55OyAvLyBtb3ZlIGV2ZXJ5IHBvaW50XG5cbiAgICBpZiAoIWlzTmFOKHgpICYmICFpc05hTih5KSkge1xuICAgICAgZm9yIChsZXQgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpc1tpXSA9IFt0aGlzW2ldWzBdICsgeCwgdGhpc1tpXVsxXSArIHldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIFBhcnNlIHBvaW50IHN0cmluZyBhbmQgZmxhdCBhcnJheVxuXG5cbiAgcGFyc2UoYXJyYXkgPSBbMCwgMF0pIHtcbiAgICBjb25zdCBwb2ludHMgPSBbXTsgLy8gaWYgaXQgaXMgYW4gYXJyYXksIHdlIGZsYXR0ZW4gaXQgYW5kIHRoZXJlZm9yZSBjbG9uZSBpdCB0byAxIGRlcHRoc1xuXG4gICAgaWYgKGFycmF5IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJyYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFbHNlLCBpdCBpcyBjb25zaWRlcmVkIGFzIGEgc3RyaW5nXG4gICAgICAvLyBwYXJzZSBwb2ludHNcbiAgICAgIGFycmF5ID0gYXJyYXkudHJpbSgpLnNwbGl0KGRlbGltaXRlcikubWFwKHBhcnNlRmxvYXQpO1xuICAgIH0gLy8gdmFsaWRhdGUgcG9pbnRzIC0gaHR0cHM6Ly9zdmd3Zy5vcmcvc3ZnMi1kcmFmdC9zaGFwZXMuaHRtbCNEYXRhVHlwZVBvaW50c1xuICAgIC8vIE9kZCBudW1iZXIgb2YgY29vcmRpbmF0ZXMgaXMgYW4gZXJyb3IuIEluIHN1Y2ggY2FzZXMsIGRyb3AgdGhlIGxhc3Qgb2RkIGNvb3JkaW5hdGUuXG5cblxuICAgIGlmIChhcnJheS5sZW5ndGggJSAyICE9PSAwKSBhcnJheS5wb3AoKTsgLy8gd3JhcCBwb2ludHMgaW4gdHdvLXR1cGxlc1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSA9IGkgKyAyKSB7XG4gICAgICBwb2ludHMucHVzaChbYXJyYXlbaV0sIGFycmF5W2kgKyAxXV0pO1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludHM7XG4gIH0gLy8gUmVzaXplIHBvbHkgc3RyaW5nXG5cblxuICBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBsZXQgaTtcbiAgICBjb25zdCBib3ggPSB0aGlzLmJib3goKTsgLy8gcmVjYWxjdWxhdGUgcG9zaXRpb24gb2YgYWxsIHBvaW50cyBhY2NvcmRpbmcgdG8gbmV3IHNpemVcblxuICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChib3gud2lkdGgpIHRoaXNbaV1bMF0gPSAodGhpc1tpXVswXSAtIGJveC54KSAqIHdpZHRoIC8gYm94LndpZHRoICsgYm94Lng7XG4gICAgICBpZiAoYm94LmhlaWdodCkgdGhpc1tpXVsxXSA9ICh0aGlzW2ldWzFdIC0gYm94LnkpICogaGVpZ2h0IC8gYm94LmhlaWdodCArIGJveC55O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIENvbnZlcnQgYXJyYXkgdG8gbGluZSBvYmplY3RcblxuXG4gIHRvTGluZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IHRoaXNbMF1bMF0sXG4gICAgICB5MTogdGhpc1swXVsxXSxcbiAgICAgIHgyOiB0aGlzWzFdWzBdLFxuICAgICAgeTI6IHRoaXNbMV1bMV1cbiAgICB9O1xuICB9IC8vIENvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG5cblxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCBhcnJheSA9IFtdOyAvLyBjb252ZXJ0IHRvIGEgcG9seSBwb2ludCBzdHJpbmdcblxuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHRoaXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgYXJyYXkucHVzaCh0aGlzW2ldLmpvaW4oJywnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5LmpvaW4oJyAnKTtcbiAgfVxuXG4gIHRyYW5zZm9ybShtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS50cmFuc2Zvcm1PKG0pO1xuICB9IC8vIHRyYW5zZm9ybSBwb2ludHMgd2l0aCBtYXRyaXggKHNpbWlsYXIgdG8gUG9pbnQudHJhbnNmb3JtKVxuXG5cbiAgdHJhbnNmb3JtTyhtKSB7XG4gICAgaWYgKCFNYXRyaXguaXNNYXRyaXhMaWtlKG0pKSB7XG4gICAgICBtID0gbmV3IE1hdHJpeChtKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gdGhpcy5sZW5ndGg7IGktLTspIHtcbiAgICAgIC8vIFBlcmZvcm0gdGhlIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgICAgY29uc3QgW3gsIHldID0gdGhpc1tpXTtcbiAgICAgIHRoaXNbaV1bMF0gPSBtLmEgKiB4ICsgbS5jICogeSArIG0uZTtcbiAgICAgIHRoaXNbaV1bMV0gPSBtLmIgKiB4ICsgbS5kICogeSArIG0uZjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59XG5cbmNvbnN0IE1vcnBoQXJyYXkgPSBQb2ludEFycmF5OyAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lciBvdmVyIHgtYXhpc1xuXG5mdW5jdGlvbiB4JDIoeCkge1xuICByZXR1cm4geCA9PSBudWxsID8gdGhpcy5iYm94KCkueCA6IHRoaXMubW92ZSh4LCB0aGlzLmJib3goKS55KTtcbn0gLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXIgb3ZlciB5LWF4aXNcblxuZnVuY3Rpb24geSQyKHkpIHtcbiAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMuYmJveCgpLnkgOiB0aGlzLm1vdmUodGhpcy5iYm94KCkueCwgeSk7XG59IC8vIFNldCB3aWR0aCBvZiBlbGVtZW50XG5cbmZ1bmN0aW9uIHdpZHRoJDEod2lkdGgpIHtcbiAgY29uc3QgYiA9IHRoaXMuYmJveCgpO1xuICByZXR1cm4gd2lkdGggPT0gbnVsbCA/IGIud2lkdGggOiB0aGlzLnNpemUod2lkdGgsIGIuaGVpZ2h0KTtcbn0gLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XG5cbmZ1bmN0aW9uIGhlaWdodCQxKGhlaWdodCkge1xuICBjb25zdCBiID0gdGhpcy5iYm94KCk7XG4gIHJldHVybiBoZWlnaHQgPT0gbnVsbCA/IGIuaGVpZ2h0IDogdGhpcy5zaXplKGIud2lkdGgsIGhlaWdodCk7XG59XG5cbnZhciBwb2ludGVkID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIE1vcnBoQXJyYXk6IE1vcnBoQXJyYXksXG4gIHg6IHgkMixcbiAgeTogeSQyLFxuICB3aWR0aDogd2lkdGgkMSxcbiAgaGVpZ2h0OiBoZWlnaHQkMVxufTtcblxuY2xhc3MgTGluZSBleHRlbmRzIFNoYXBlIHtcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygnbGluZScsIG5vZGUpLCBhdHRycyk7XG4gIH0gLy8gR2V0IGFycmF5XG5cblxuICBhcnJheSgpIHtcbiAgICByZXR1cm4gbmV3IFBvaW50QXJyYXkoW1t0aGlzLmF0dHIoJ3gxJyksIHRoaXMuYXR0cigneTEnKV0sIFt0aGlzLmF0dHIoJ3gyJyksIHRoaXMuYXR0cigneTInKV1dKTtcbiAgfSAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lclxuXG5cbiAgbW92ZSh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cih0aGlzLmFycmF5KCkubW92ZSh4LCB5KS50b0xpbmUoKSk7XG4gIH0gLy8gT3ZlcndyaXRlIG5hdGl2ZSBwbG90KCkgbWV0aG9kXG5cblxuICBwbG90KHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgaWYgKHgxID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmFycmF5KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgeTEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB4MSA9IHtcbiAgICAgICAgeDEsXG4gICAgICAgIHkxLFxuICAgICAgICB4MixcbiAgICAgICAgeTJcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHgxID0gbmV3IFBvaW50QXJyYXkoeDEpLnRvTGluZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmF0dHIoeDEpO1xuICB9IC8vIFNldCBlbGVtZW50IHNpemUgdG8gZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxuXG5cbiAgc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodCk7XG4gICAgcmV0dXJuIHRoaXMuYXR0cih0aGlzLmFycmF5KCkuc2l6ZShwLndpZHRoLCBwLmhlaWdodCkudG9MaW5lKCkpO1xuICB9XG5cbn1cbmV4dGVuZChMaW5lLCBwb2ludGVkKTtcbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIENvbnRhaW5lcjoge1xuICAgIC8vIENyZWF0ZSBhIGxpbmUgZWxlbWVudFxuICAgIGxpbmU6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgcGxvdCBpcyBjYWxsZWQgYXMgYSBzZXR0ZXJcbiAgICAgIC8vIHgxIGlzIG5vdCBuZWNlc3NhcmlseSBhIG51bWJlciwgaXQgY2FuIGFsc28gYmUgYW4gYXJyYXksIGEgc3RyaW5nIGFuZCBhIFBvaW50QXJyYXlcbiAgICAgIHJldHVybiBMaW5lLnByb3RvdHlwZS5wbG90LmFwcGx5KHRoaXMucHV0KG5ldyBMaW5lKCkpLCBhcmdzWzBdICE9IG51bGwgPyBhcmdzIDogWzAsIDAsIDAsIDBdKTtcbiAgICB9KVxuICB9XG59KTtcbnJlZ2lzdGVyKExpbmUsICdMaW5lJyk7XG5cbmNsYXNzIE1hcmtlciBleHRlbmRzIENvbnRhaW5lciB7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ21hcmtlcicsIG5vZGUpLCBhdHRycyk7XG4gIH0gLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XG5cblxuICBoZWlnaHQoaGVpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cignbWFya2VySGVpZ2h0JywgaGVpZ2h0KTtcbiAgfVxuXG4gIG9yaWVudChvcmllbnQpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdvcmllbnQnLCBvcmllbnQpO1xuICB9IC8vIFNldCBtYXJrZXIgcmVmWCBhbmQgcmVmWVxuXG5cbiAgcmVmKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdyZWZYJywgeCkuYXR0cigncmVmWScsIHkpO1xuICB9IC8vIFJldHVybiB0aGUgZmlsbCBpZFxuXG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICd1cmwoIycgKyB0aGlzLmlkKCkgKyAnKSc7XG4gIH0gLy8gVXBkYXRlIG1hcmtlclxuXG5cbiAgdXBkYXRlKGJsb2NrKSB7XG4gICAgLy8gcmVtb3ZlIGFsbCBjb250ZW50XG4gICAgdGhpcy5jbGVhcigpOyAvLyBpbnZva2UgcGFzc2VkIGJsb2NrXG5cbiAgICBpZiAodHlwZW9mIGJsb2NrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBibG9jay5jYWxsKHRoaXMsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIFNldCB3aWR0aCBvZiBlbGVtZW50XG5cblxuICB3aWR0aCh3aWR0aCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ21hcmtlcldpZHRoJywgd2lkdGgpO1xuICB9XG5cbn1cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIENvbnRhaW5lcjoge1xuICAgIG1hcmtlciguLi5hcmdzKSB7XG4gICAgICAvLyBDcmVhdGUgbWFya2VyIGVsZW1lbnQgaW4gZGVmc1xuICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLm1hcmtlciguLi5hcmdzKTtcbiAgICB9XG5cbiAgfSxcbiAgRGVmczoge1xuICAgIC8vIENyZWF0ZSBtYXJrZXJcbiAgICBtYXJrZXI6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCBibG9jaykge1xuICAgICAgLy8gU2V0IGRlZmF1bHQgdmlld2JveCB0byBtYXRjaCB0aGUgd2lkdGggYW5kIGhlaWdodCwgc2V0IHJlZiB0byBjeCBhbmQgY3kgYW5kIHNldCBvcmllbnQgdG8gYXV0b1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBNYXJrZXIoKSkuc2l6ZSh3aWR0aCwgaGVpZ2h0KS5yZWYod2lkdGggLyAyLCBoZWlnaHQgLyAyKS52aWV3Ym94KDAsIDAsIHdpZHRoLCBoZWlnaHQpLmF0dHIoJ29yaWVudCcsICdhdXRvJykudXBkYXRlKGJsb2NrKTtcbiAgICB9KVxuICB9LFxuICBtYXJrZXI6IHtcbiAgICAvLyBDcmVhdGUgYW5kIGF0dGFjaCBtYXJrZXJzXG4gICAgbWFya2VyKG1hcmtlciwgd2lkdGgsIGhlaWdodCwgYmxvY2spIHtcbiAgICAgIGxldCBhdHRyID0gWydtYXJrZXInXTsgLy8gQnVpbGQgYXR0cmlidXRlIG5hbWVcblxuICAgICAgaWYgKG1hcmtlciAhPT0gJ2FsbCcpIGF0dHIucHVzaChtYXJrZXIpO1xuICAgICAgYXR0ciA9IGF0dHIuam9pbignLScpOyAvLyBTZXQgbWFya2VyIGF0dHJpYnV0ZVxuXG4gICAgICBtYXJrZXIgPSBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBNYXJrZXIgPyBhcmd1bWVudHNbMV0gOiB0aGlzLmRlZnMoKS5tYXJrZXIod2lkdGgsIGhlaWdodCwgYmxvY2spO1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cihhdHRyLCBtYXJrZXIpO1xuICAgIH1cblxuICB9XG59KTtcbnJlZ2lzdGVyKE1hcmtlciwgJ01hcmtlcicpO1xuXG4vKioqXG5CYXNlIENsYXNzXG49PT09PT09PT09XG5UaGUgYmFzZSBzdGVwcGVyIGNsYXNzIHRoYXQgd2lsbCBiZVxuKioqL1xuXG5mdW5jdGlvbiBtYWtlU2V0dGVyR2V0dGVyKGssIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKHYgPT0gbnVsbCkgcmV0dXJuIHRoaXNba107XG4gICAgdGhpc1trXSA9IHY7XG4gICAgaWYgKGYpIGYuY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuY29uc3QgZWFzaW5nID0ge1xuICAnLSc6IGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zO1xuICB9LFxuICAnPD4nOiBmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIC1NYXRoLmNvcyhwb3MgKiBNYXRoLlBJKSAvIDIgKyAwLjU7XG4gIH0sXG4gICc+JzogZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBNYXRoLnNpbihwb3MgKiBNYXRoLlBJIC8gMik7XG4gIH0sXG4gICc8JzogZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiAtTWF0aC5jb3MocG9zICogTWF0aC5QSSAvIDIpICsgMTtcbiAgfSxcbiAgYmV6aWVyOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAvLyBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1lYXNpbmctMS8jY3ViaWMtYmV6aWVyLWFsZ29cbiAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmICh0IDwgMCkge1xuICAgICAgICBpZiAoeDEgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHkxIC8geDEgKiB0O1xuICAgICAgICB9IGVsc2UgaWYgKHgyID4gMCkge1xuICAgICAgICAgIHJldHVybiB5MiAvIHgyICogdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ID4gMSkge1xuICAgICAgICBpZiAoeDIgPCAxKSB7XG4gICAgICAgICAgcmV0dXJuICgxIC0geTIpIC8gKDEgLSB4MikgKiB0ICsgKHkyIC0geDIpIC8gKDEgLSB4Mik7XG4gICAgICAgIH0gZWxzZSBpZiAoeDEgPCAxKSB7XG4gICAgICAgICAgcmV0dXJuICgxIC0geTEpIC8gKDEgLSB4MSkgKiB0ICsgKHkxIC0geDEpIC8gKDEgLSB4MSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAzICogdCAqICgxIC0gdCkgKiogMiAqIHkxICsgMyAqIHQgKiogMiAqICgxIC0gdCkgKiB5MiArIHQgKiogMztcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICAvLyBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1lYXNpbmctMS8jc3RlcC10aW1pbmctZnVuY3Rpb24tYWxnb1xuICBzdGVwczogZnVuY3Rpb24gKHN0ZXBzLCBzdGVwUG9zaXRpb24gPSAnZW5kJykge1xuICAgIC8vIGRlYWwgd2l0aCBcImp1bXAtXCIgcHJlZml4XG4gICAgc3RlcFBvc2l0aW9uID0gc3RlcFBvc2l0aW9uLnNwbGl0KCctJykucmV2ZXJzZSgpWzBdO1xuICAgIGxldCBqdW1wcyA9IHN0ZXBzO1xuXG4gICAgaWYgKHN0ZXBQb3NpdGlvbiA9PT0gJ25vbmUnKSB7XG4gICAgICAtLWp1bXBzO1xuICAgIH0gZWxzZSBpZiAoc3RlcFBvc2l0aW9uID09PSAnYm90aCcpIHtcbiAgICAgICsranVtcHM7XG4gICAgfSAvLyBUaGUgYmVmb3JlRmxhZyBpcyBlc3NlbnRpYWxseSB1c2VsZXNzXG5cblxuICAgIHJldHVybiAodCwgYmVmb3JlRmxhZyA9IGZhbHNlKSA9PiB7XG4gICAgICAvLyBTdGVwIGlzIGNhbGxlZCBjdXJyZW50U3RlcCBpbiByZWZlcmVuY2VkIHVybFxuICAgICAgbGV0IHN0ZXAgPSBNYXRoLmZsb29yKHQgKiBzdGVwcyk7XG4gICAgICBjb25zdCBqdW1waW5nID0gdCAqIHN0ZXAgJSAxID09PSAwO1xuXG4gICAgICBpZiAoc3RlcFBvc2l0aW9uID09PSAnc3RhcnQnIHx8IHN0ZXBQb3NpdGlvbiA9PT0gJ2JvdGgnKSB7XG4gICAgICAgICsrc3RlcDtcbiAgICAgIH1cblxuICAgICAgaWYgKGJlZm9yZUZsYWcgJiYganVtcGluZykge1xuICAgICAgICAtLXN0ZXA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ID49IDAgJiYgc3RlcCA8IDApIHtcbiAgICAgICAgc3RlcCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0IDw9IDEgJiYgc3RlcCA+IGp1bXBzKSB7XG4gICAgICAgIHN0ZXAgPSBqdW1wcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0ZXAgLyBqdW1wcztcbiAgICB9O1xuICB9XG59O1xuY2xhc3MgU3RlcHBlciB7XG4gIGRvbmUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbn1cbi8qKipcbkVhc2luZyBGdW5jdGlvbnNcbj09PT09PT09PT09PT09PT1cbioqKi9cblxuY2xhc3MgRWFzZSBleHRlbmRzIFN0ZXBwZXIge1xuICBjb25zdHJ1Y3RvcihmbiA9IHRpbWVsaW5lLmVhc2UpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZWFzZSA9IGVhc2luZ1tmbl0gfHwgZm47XG4gIH1cblxuICBzdGVwKGZyb20sIHRvLCBwb3MpIHtcbiAgICBpZiAodHlwZW9mIGZyb20gIT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcG9zIDwgMSA/IGZyb20gOiB0bztcbiAgICB9XG5cbiAgICByZXR1cm4gZnJvbSArICh0byAtIGZyb20pICogdGhpcy5lYXNlKHBvcyk7XG4gIH1cblxufVxuLyoqKlxuQ29udHJvbGxlciBUeXBlc1xuPT09PT09PT09PT09PT09PVxuKioqL1xuXG5jbGFzcyBDb250cm9sbGVyIGV4dGVuZHMgU3RlcHBlciB7XG4gIGNvbnN0cnVjdG9yKGZuKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnN0ZXBwZXIgPSBmbjtcbiAgfVxuXG4gIGRvbmUoYykge1xuICAgIHJldHVybiBjLmRvbmU7XG4gIH1cblxuICBzdGVwKGN1cnJlbnQsIHRhcmdldCwgZHQsIGMpIHtcbiAgICByZXR1cm4gdGhpcy5zdGVwcGVyKGN1cnJlbnQsIHRhcmdldCwgZHQsIGMpO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gcmVjYWxjdWxhdGUoKSB7XG4gIC8vIEFwcGx5IHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcbiAgY29uc3QgZHVyYXRpb24gPSAodGhpcy5fZHVyYXRpb24gfHwgNTAwKSAvIDEwMDA7XG4gIGNvbnN0IG92ZXJzaG9vdCA9IHRoaXMuX292ZXJzaG9vdCB8fCAwOyAvLyBDYWxjdWxhdGUgdGhlIFBJRCBuYXR1cmFsIHJlc3BvbnNlXG5cbiAgY29uc3QgZXBzID0gMWUtMTA7XG4gIGNvbnN0IHBpID0gTWF0aC5QSTtcbiAgY29uc3Qgb3MgPSBNYXRoLmxvZyhvdmVyc2hvb3QgLyAxMDAgKyBlcHMpO1xuICBjb25zdCB6ZXRhID0gLW9zIC8gTWF0aC5zcXJ0KHBpICogcGkgKyBvcyAqIG9zKTtcbiAgY29uc3Qgd24gPSAzLjkgLyAoemV0YSAqIGR1cmF0aW9uKTsgLy8gQ2FsY3VsYXRlIHRoZSBTcHJpbmcgdmFsdWVzXG5cbiAgdGhpcy5kID0gMiAqIHpldGEgKiB3bjtcbiAgdGhpcy5rID0gd24gKiB3bjtcbn1cblxuY2xhc3MgU3ByaW5nIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGR1cmF0aW9uID0gNTAwLCBvdmVyc2hvb3QgPSAwKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmR1cmF0aW9uKGR1cmF0aW9uKS5vdmVyc2hvb3Qob3ZlcnNob290KTtcbiAgfVxuXG4gIHN0ZXAoY3VycmVudCwgdGFyZ2V0LCBkdCwgYykge1xuICAgIGlmICh0eXBlb2YgY3VycmVudCA9PT0gJ3N0cmluZycpIHJldHVybiBjdXJyZW50O1xuICAgIGMuZG9uZSA9IGR0ID09PSBJbmZpbml0eTtcbiAgICBpZiAoZHQgPT09IEluZmluaXR5KSByZXR1cm4gdGFyZ2V0O1xuICAgIGlmIChkdCA9PT0gMCkgcmV0dXJuIGN1cnJlbnQ7XG4gICAgaWYgKGR0ID4gMTAwKSBkdCA9IDE2O1xuICAgIGR0IC89IDEwMDA7IC8vIEdldCB0aGUgcHJldmlvdXMgdmVsb2NpdHlcblxuICAgIGNvbnN0IHZlbG9jaXR5ID0gYy52ZWxvY2l0eSB8fCAwOyAvLyBBcHBseSB0aGUgY29udHJvbCB0byBnZXQgdGhlIG5ldyBwb3NpdGlvbiBhbmQgc3RvcmUgaXRcblxuICAgIGNvbnN0IGFjY2VsZXJhdGlvbiA9IC10aGlzLmQgKiB2ZWxvY2l0eSAtIHRoaXMuayAqIChjdXJyZW50IC0gdGFyZ2V0KTtcbiAgICBjb25zdCBuZXdQb3NpdGlvbiA9IGN1cnJlbnQgKyB2ZWxvY2l0eSAqIGR0ICsgYWNjZWxlcmF0aW9uICogZHQgKiBkdCAvIDI7IC8vIFN0b3JlIHRoZSB2ZWxvY2l0eVxuXG4gICAgYy52ZWxvY2l0eSA9IHZlbG9jaXR5ICsgYWNjZWxlcmF0aW9uICogZHQ7IC8vIEZpZ3VyZSBvdXQgaWYgd2UgaGF2ZSBjb252ZXJnZWQsIGFuZCBpZiBzbywgcGFzcyB0aGUgdmFsdWVcblxuICAgIGMuZG9uZSA9IE1hdGguYWJzKHRhcmdldCAtIG5ld1Bvc2l0aW9uKSArIE1hdGguYWJzKHZlbG9jaXR5KSA8IDAuMDAyO1xuICAgIHJldHVybiBjLmRvbmUgPyB0YXJnZXQgOiBuZXdQb3NpdGlvbjtcbiAgfVxuXG59XG5leHRlbmQoU3ByaW5nLCB7XG4gIGR1cmF0aW9uOiBtYWtlU2V0dGVyR2V0dGVyKCdfZHVyYXRpb24nLCByZWNhbGN1bGF0ZSksXG4gIG92ZXJzaG9vdDogbWFrZVNldHRlckdldHRlcignX292ZXJzaG9vdCcsIHJlY2FsY3VsYXRlKVxufSk7XG5jbGFzcyBQSUQgZXh0ZW5kcyBDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IocCA9IDAuMSwgaSA9IDAuMDEsIGQgPSAwLCB3aW5kdXAgPSAxMDAwKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnAocCkuaShpKS5kKGQpLndpbmR1cCh3aW5kdXApO1xuICB9XG5cbiAgc3RlcChjdXJyZW50LCB0YXJnZXQsIGR0LCBjKSB7XG4gICAgaWYgKHR5cGVvZiBjdXJyZW50ID09PSAnc3RyaW5nJykgcmV0dXJuIGN1cnJlbnQ7XG4gICAgYy5kb25lID0gZHQgPT09IEluZmluaXR5O1xuICAgIGlmIChkdCA9PT0gSW5maW5pdHkpIHJldHVybiB0YXJnZXQ7XG4gICAgaWYgKGR0ID09PSAwKSByZXR1cm4gY3VycmVudDtcbiAgICBjb25zdCBwID0gdGFyZ2V0IC0gY3VycmVudDtcbiAgICBsZXQgaSA9IChjLmludGVncmFsIHx8IDApICsgcCAqIGR0O1xuICAgIGNvbnN0IGQgPSAocCAtIChjLmVycm9yIHx8IDApKSAvIGR0O1xuICAgIGNvbnN0IHdpbmR1cCA9IHRoaXMuX3dpbmR1cDsgLy8gYW50aXdpbmR1cFxuXG4gICAgaWYgKHdpbmR1cCAhPT0gZmFsc2UpIHtcbiAgICAgIGkgPSBNYXRoLm1heCgtd2luZHVwLCBNYXRoLm1pbihpLCB3aW5kdXApKTtcbiAgICB9XG5cbiAgICBjLmVycm9yID0gcDtcbiAgICBjLmludGVncmFsID0gaTtcbiAgICBjLmRvbmUgPSBNYXRoLmFicyhwKSA8IDAuMDAxO1xuICAgIHJldHVybiBjLmRvbmUgPyB0YXJnZXQgOiBjdXJyZW50ICsgKHRoaXMuUCAqIHAgKyB0aGlzLkkgKiBpICsgdGhpcy5EICogZCk7XG4gIH1cblxufVxuZXh0ZW5kKFBJRCwge1xuICB3aW5kdXA6IG1ha2VTZXR0ZXJHZXR0ZXIoJ193aW5kdXAnKSxcbiAgcDogbWFrZVNldHRlckdldHRlcignUCcpLFxuICBpOiBtYWtlU2V0dGVyR2V0dGVyKCdJJyksXG4gIGQ6IG1ha2VTZXR0ZXJHZXR0ZXIoJ0QnKVxufSk7XG5cbmNvbnN0IHNlZ21lbnRQYXJhbWV0ZXJzID0ge1xuICBNOiAyLFxuICBMOiAyLFxuICBIOiAxLFxuICBWOiAxLFxuICBDOiA2LFxuICBTOiA0LFxuICBROiA0LFxuICBUOiAyLFxuICBBOiA3LFxuICBaOiAwXG59O1xuY29uc3QgcGF0aEhhbmRsZXJzID0ge1xuICBNOiBmdW5jdGlvbiAoYywgcCwgcDApIHtcbiAgICBwLnggPSBwMC54ID0gY1swXTtcbiAgICBwLnkgPSBwMC55ID0gY1sxXTtcbiAgICByZXR1cm4gWydNJywgcC54LCBwLnldO1xuICB9LFxuICBMOiBmdW5jdGlvbiAoYywgcCkge1xuICAgIHAueCA9IGNbMF07XG4gICAgcC55ID0gY1sxXTtcbiAgICByZXR1cm4gWydMJywgY1swXSwgY1sxXV07XG4gIH0sXG4gIEg6IGZ1bmN0aW9uIChjLCBwKSB7XG4gICAgcC54ID0gY1swXTtcbiAgICByZXR1cm4gWydIJywgY1swXV07XG4gIH0sXG4gIFY6IGZ1bmN0aW9uIChjLCBwKSB7XG4gICAgcC55ID0gY1swXTtcbiAgICByZXR1cm4gWydWJywgY1swXV07XG4gIH0sXG4gIEM6IGZ1bmN0aW9uIChjLCBwKSB7XG4gICAgcC54ID0gY1s0XTtcbiAgICBwLnkgPSBjWzVdO1xuICAgIHJldHVybiBbJ0MnLCBjWzBdLCBjWzFdLCBjWzJdLCBjWzNdLCBjWzRdLCBjWzVdXTtcbiAgfSxcbiAgUzogZnVuY3Rpb24gKGMsIHApIHtcbiAgICBwLnggPSBjWzJdO1xuICAgIHAueSA9IGNbM107XG4gICAgcmV0dXJuIFsnUycsIGNbMF0sIGNbMV0sIGNbMl0sIGNbM11dO1xuICB9LFxuICBROiBmdW5jdGlvbiAoYywgcCkge1xuICAgIHAueCA9IGNbMl07XG4gICAgcC55ID0gY1szXTtcbiAgICByZXR1cm4gWydRJywgY1swXSwgY1sxXSwgY1syXSwgY1szXV07XG4gIH0sXG4gIFQ6IGZ1bmN0aW9uIChjLCBwKSB7XG4gICAgcC54ID0gY1swXTtcbiAgICBwLnkgPSBjWzFdO1xuICAgIHJldHVybiBbJ1QnLCBjWzBdLCBjWzFdXTtcbiAgfSxcbiAgWjogZnVuY3Rpb24gKGMsIHAsIHAwKSB7XG4gICAgcC54ID0gcDAueDtcbiAgICBwLnkgPSBwMC55O1xuICAgIHJldHVybiBbJ1onXTtcbiAgfSxcbiAgQTogZnVuY3Rpb24gKGMsIHApIHtcbiAgICBwLnggPSBjWzVdO1xuICAgIHAueSA9IGNbNl07XG4gICAgcmV0dXJuIFsnQScsIGNbMF0sIGNbMV0sIGNbMl0sIGNbM10sIGNbNF0sIGNbNV0sIGNbNl1dO1xuICB9XG59O1xuY29uc3QgbWxodnF0Y3NheiA9ICdtbGh2cXRjc2F6Jy5zcGxpdCgnJyk7XG5cbmZvciAobGV0IGkgPSAwLCBpbCA9IG1saHZxdGNzYXoubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICBwYXRoSGFuZGxlcnNbbWxodnF0Y3NheltpXV0gPSBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYywgcCwgcDApIHtcbiAgICAgIGlmIChpID09PSAnSCcpIGNbMF0gPSBjWzBdICsgcC54O2Vsc2UgaWYgKGkgPT09ICdWJykgY1swXSA9IGNbMF0gKyBwLnk7ZWxzZSBpZiAoaSA9PT0gJ0EnKSB7XG4gICAgICAgIGNbNV0gPSBjWzVdICsgcC54O1xuICAgICAgICBjWzZdID0gY1s2XSArIHAueTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IGMubGVuZ3RoOyBqIDwgamw7ICsraikge1xuICAgICAgICAgIGNbal0gPSBjW2pdICsgKGogJSAyID8gcC55IDogcC54KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGhIYW5kbGVyc1tpXShjLCBwLCBwMCk7XG4gICAgfTtcbiAgfShtbGh2cXRjc2F6W2ldLnRvVXBwZXJDYXNlKCkpO1xufVxuXG5mdW5jdGlvbiBtYWtlQWJzb2x1dChwYXJzZXIpIHtcbiAgY29uc3QgY29tbWFuZCA9IHBhcnNlci5zZWdtZW50WzBdO1xuICByZXR1cm4gcGF0aEhhbmRsZXJzW2NvbW1hbmRdKHBhcnNlci5zZWdtZW50LnNsaWNlKDEpLCBwYXJzZXIucCwgcGFyc2VyLnAwKTtcbn1cblxuZnVuY3Rpb24gc2VnbWVudENvbXBsZXRlKHBhcnNlcikge1xuICByZXR1cm4gcGFyc2VyLnNlZ21lbnQubGVuZ3RoICYmIHBhcnNlci5zZWdtZW50Lmxlbmd0aCAtIDEgPT09IHNlZ21lbnRQYXJhbWV0ZXJzW3BhcnNlci5zZWdtZW50WzBdLnRvVXBwZXJDYXNlKCldO1xufVxuXG5mdW5jdGlvbiBzdGFydE5ld1NlZ21lbnQocGFyc2VyLCB0b2tlbikge1xuICBwYXJzZXIuaW5OdW1iZXIgJiYgZmluYWxpemVOdW1iZXIocGFyc2VyLCBmYWxzZSk7XG4gIGNvbnN0IHBhdGhMZXR0ZXIgPSBpc1BhdGhMZXR0ZXIudGVzdCh0b2tlbik7XG5cbiAgaWYgKHBhdGhMZXR0ZXIpIHtcbiAgICBwYXJzZXIuc2VnbWVudCA9IFt0b2tlbl07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGFzdENvbW1hbmQgPSBwYXJzZXIubGFzdENvbW1hbmQ7XG4gICAgY29uc3Qgc21hbGwgPSBsYXN0Q29tbWFuZC50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGlzU21hbGwgPSBsYXN0Q29tbWFuZCA9PT0gc21hbGw7XG4gICAgcGFyc2VyLnNlZ21lbnQgPSBbc21hbGwgPT09ICdtJyA/IGlzU21hbGwgPyAnbCcgOiAnTCcgOiBsYXN0Q29tbWFuZF07XG4gIH1cblxuICBwYXJzZXIuaW5TZWdtZW50ID0gdHJ1ZTtcbiAgcGFyc2VyLmxhc3RDb21tYW5kID0gcGFyc2VyLnNlZ21lbnRbMF07XG4gIHJldHVybiBwYXRoTGV0dGVyO1xufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZU51bWJlcihwYXJzZXIsIGluTnVtYmVyKSB7XG4gIGlmICghcGFyc2VyLmluTnVtYmVyKSB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlciBFcnJvcicpO1xuICBwYXJzZXIubnVtYmVyICYmIHBhcnNlci5zZWdtZW50LnB1c2gocGFyc2VGbG9hdChwYXJzZXIubnVtYmVyKSk7XG4gIHBhcnNlci5pbk51bWJlciA9IGluTnVtYmVyO1xuICBwYXJzZXIubnVtYmVyID0gJyc7XG4gIHBhcnNlci5wb2ludFNlZW4gPSBmYWxzZTtcbiAgcGFyc2VyLmhhc0V4cG9uZW50ID0gZmFsc2U7XG5cbiAgaWYgKHNlZ21lbnRDb21wbGV0ZShwYXJzZXIpKSB7XG4gICAgZmluYWxpemVTZWdtZW50KHBhcnNlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluYWxpemVTZWdtZW50KHBhcnNlcikge1xuICBwYXJzZXIuaW5TZWdtZW50ID0gZmFsc2U7XG5cbiAgaWYgKHBhcnNlci5hYnNvbHV0ZSkge1xuICAgIHBhcnNlci5zZWdtZW50ID0gbWFrZUFic29sdXQocGFyc2VyKTtcbiAgfVxuXG4gIHBhcnNlci5zZWdtZW50cy5wdXNoKHBhcnNlci5zZWdtZW50KTtcbn1cblxuZnVuY3Rpb24gaXNBcmNGbGFnKHBhcnNlcikge1xuICBpZiAoIXBhcnNlci5zZWdtZW50Lmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBpc0FyYyA9IHBhcnNlci5zZWdtZW50WzBdLnRvVXBwZXJDYXNlKCkgPT09ICdBJztcbiAgY29uc3QgbGVuZ3RoID0gcGFyc2VyLnNlZ21lbnQubGVuZ3RoO1xuICByZXR1cm4gaXNBcmMgJiYgKGxlbmd0aCA9PT0gNCB8fCBsZW5ndGggPT09IDUpO1xufVxuXG5mdW5jdGlvbiBpc0V4cG9uZW50aWFsKHBhcnNlcikge1xuICByZXR1cm4gcGFyc2VyLmxhc3RUb2tlbi50b1VwcGVyQ2FzZSgpID09PSAnRSc7XG59XG5cbmZ1bmN0aW9uIHBhdGhQYXJzZXIoZCwgdG9BYnNvbHV0ZSA9IHRydWUpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgbGV0IHRva2VuID0gJyc7XG4gIGNvbnN0IHBhcnNlciA9IHtcbiAgICBzZWdtZW50OiBbXSxcbiAgICBpbk51bWJlcjogZmFsc2UsXG4gICAgbnVtYmVyOiAnJyxcbiAgICBsYXN0VG9rZW46ICcnLFxuICAgIGluU2VnbWVudDogZmFsc2UsXG4gICAgc2VnbWVudHM6IFtdLFxuICAgIHBvaW50U2VlbjogZmFsc2UsXG4gICAgaGFzRXhwb25lbnQ6IGZhbHNlLFxuICAgIGFic29sdXRlOiB0b0Fic29sdXRlLFxuICAgIHAwOiBuZXcgUG9pbnQoKSxcbiAgICBwOiBuZXcgUG9pbnQoKVxuICB9O1xuXG4gIHdoaWxlIChwYXJzZXIubGFzdFRva2VuID0gdG9rZW4sIHRva2VuID0gZC5jaGFyQXQoaW5kZXgrKykpIHtcbiAgICBpZiAoIXBhcnNlci5pblNlZ21lbnQpIHtcbiAgICAgIGlmIChzdGFydE5ld1NlZ21lbnQocGFyc2VyLCB0b2tlbikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRva2VuID09PSAnLicpIHtcbiAgICAgIGlmIChwYXJzZXIucG9pbnRTZWVuIHx8IHBhcnNlci5oYXNFeHBvbmVudCkge1xuICAgICAgICBmaW5hbGl6ZU51bWJlcihwYXJzZXIsIGZhbHNlKTtcbiAgICAgICAgLS1pbmRleDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHBhcnNlci5pbk51bWJlciA9IHRydWU7XG4gICAgICBwYXJzZXIucG9pbnRTZWVuID0gdHJ1ZTtcbiAgICAgIHBhcnNlci5udW1iZXIgKz0gdG9rZW47XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzTmFOKHBhcnNlSW50KHRva2VuKSkpIHtcbiAgICAgIGlmIChwYXJzZXIubnVtYmVyID09PSAnMCcgfHwgaXNBcmNGbGFnKHBhcnNlcikpIHtcbiAgICAgICAgcGFyc2VyLmluTnVtYmVyID0gdHJ1ZTtcbiAgICAgICAgcGFyc2VyLm51bWJlciA9IHRva2VuO1xuICAgICAgICBmaW5hbGl6ZU51bWJlcihwYXJzZXIsIHRydWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcGFyc2VyLmluTnVtYmVyID0gdHJ1ZTtcbiAgICAgIHBhcnNlci5udW1iZXIgKz0gdG9rZW47XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4gPT09ICcgJyB8fCB0b2tlbiA9PT0gJywnKSB7XG4gICAgICBpZiAocGFyc2VyLmluTnVtYmVyKSB7XG4gICAgICAgIGZpbmFsaXplTnVtYmVyKHBhcnNlciwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4gPT09ICctJykge1xuICAgICAgaWYgKHBhcnNlci5pbk51bWJlciAmJiAhaXNFeHBvbmVudGlhbChwYXJzZXIpKSB7XG4gICAgICAgIGZpbmFsaXplTnVtYmVyKHBhcnNlciwgZmFsc2UpO1xuICAgICAgICAtLWluZGV4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcGFyc2VyLm51bWJlciArPSB0b2tlbjtcbiAgICAgIHBhcnNlci5pbk51bWJlciA9IHRydWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4udG9VcHBlckNhc2UoKSA9PT0gJ0UnKSB7XG4gICAgICBwYXJzZXIubnVtYmVyICs9IHRva2VuO1xuICAgICAgcGFyc2VyLmhhc0V4cG9uZW50ID0gdHJ1ZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChpc1BhdGhMZXR0ZXIudGVzdCh0b2tlbikpIHtcbiAgICAgIGlmIChwYXJzZXIuaW5OdW1iZXIpIHtcbiAgICAgICAgZmluYWxpemVOdW1iZXIocGFyc2VyLCBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKCFzZWdtZW50Q29tcGxldGUocGFyc2VyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnNlciBFcnJvcicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmluYWxpemVTZWdtZW50KHBhcnNlcik7XG4gICAgICB9XG5cbiAgICAgIC0taW5kZXg7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnNlci5pbk51bWJlcikge1xuICAgIGZpbmFsaXplTnVtYmVyKHBhcnNlciwgZmFsc2UpO1xuICB9XG5cbiAgaWYgKHBhcnNlci5pblNlZ21lbnQgJiYgc2VnbWVudENvbXBsZXRlKHBhcnNlcikpIHtcbiAgICBmaW5hbGl6ZVNlZ21lbnQocGFyc2VyKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZXIuc2VnbWVudHM7XG59XG5cbmZ1bmN0aW9uIGFycmF5VG9TdHJpbmcoYSkge1xuICBsZXQgcyA9ICcnO1xuXG4gIGZvciAobGV0IGkgPSAwLCBpbCA9IGEubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIHMgKz0gYVtpXVswXTtcblxuICAgIGlmIChhW2ldWzFdICE9IG51bGwpIHtcbiAgICAgIHMgKz0gYVtpXVsxXTtcblxuICAgICAgaWYgKGFbaV1bMl0gIT0gbnVsbCkge1xuICAgICAgICBzICs9ICcgJztcbiAgICAgICAgcyArPSBhW2ldWzJdO1xuXG4gICAgICAgIGlmIChhW2ldWzNdICE9IG51bGwpIHtcbiAgICAgICAgICBzICs9ICcgJztcbiAgICAgICAgICBzICs9IGFbaV1bM107XG4gICAgICAgICAgcyArPSAnICc7XG4gICAgICAgICAgcyArPSBhW2ldWzRdO1xuXG4gICAgICAgICAgaWYgKGFbaV1bNV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcyArPSAnICc7XG4gICAgICAgICAgICBzICs9IGFbaV1bNV07XG4gICAgICAgICAgICBzICs9ICcgJztcbiAgICAgICAgICAgIHMgKz0gYVtpXVs2XTtcblxuICAgICAgICAgICAgaWYgKGFbaV1bN10gIT0gbnVsbCkge1xuICAgICAgICAgICAgICBzICs9ICcgJztcbiAgICAgICAgICAgICAgcyArPSBhW2ldWzddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzICsgJyAnO1xufVxuXG5jbGFzcyBQYXRoQXJyYXkgZXh0ZW5kcyBTVkdBcnJheSB7XG4gIC8vIEdldCBib3VuZGluZyBib3ggb2YgcGF0aFxuICBiYm94KCkge1xuICAgIHBhcnNlcigpLnBhdGguc2V0QXR0cmlidXRlKCdkJywgdGhpcy50b1N0cmluZygpKTtcbiAgICByZXR1cm4gbmV3IEJveChwYXJzZXIubm9kZXMucGF0aC5nZXRCQm94KCkpO1xuICB9IC8vIE1vdmUgcGF0aCBzdHJpbmdcblxuXG4gIG1vdmUoeCwgeSkge1xuICAgIC8vIGdldCBib3VuZGluZyBib3ggb2YgY3VycmVudCBzaXR1YXRpb25cbiAgICBjb25zdCBib3ggPSB0aGlzLmJib3goKTsgLy8gZ2V0IHJlbGF0aXZlIG9mZnNldFxuXG4gICAgeCAtPSBib3gueDtcbiAgICB5IC09IGJveC55O1xuXG4gICAgaWYgKCFpc05hTih4KSAmJiAhaXNOYU4oeSkpIHtcbiAgICAgIC8vIG1vdmUgZXZlcnkgcG9pbnRcbiAgICAgIGZvciAobGV0IGwsIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGwgPSB0aGlzW2ldWzBdO1xuXG4gICAgICAgIGlmIChsID09PSAnTScgfHwgbCA9PT0gJ0wnIHx8IGwgPT09ICdUJykge1xuICAgICAgICAgIHRoaXNbaV1bMV0gKz0geDtcbiAgICAgICAgICB0aGlzW2ldWzJdICs9IHk7XG4gICAgICAgIH0gZWxzZSBpZiAobCA9PT0gJ0gnKSB7XG4gICAgICAgICAgdGhpc1tpXVsxXSArPSB4O1xuICAgICAgICB9IGVsc2UgaWYgKGwgPT09ICdWJykge1xuICAgICAgICAgIHRoaXNbaV1bMV0gKz0geTtcbiAgICAgICAgfSBlbHNlIGlmIChsID09PSAnQycgfHwgbCA9PT0gJ1MnIHx8IGwgPT09ICdRJykge1xuICAgICAgICAgIHRoaXNbaV1bMV0gKz0geDtcbiAgICAgICAgICB0aGlzW2ldWzJdICs9IHk7XG4gICAgICAgICAgdGhpc1tpXVszXSArPSB4O1xuICAgICAgICAgIHRoaXNbaV1bNF0gKz0geTtcblxuICAgICAgICAgIGlmIChsID09PSAnQycpIHtcbiAgICAgICAgICAgIHRoaXNbaV1bNV0gKz0geDtcbiAgICAgICAgICAgIHRoaXNbaV1bNl0gKz0geTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobCA9PT0gJ0EnKSB7XG4gICAgICAgICAgdGhpc1tpXVs2XSArPSB4O1xuICAgICAgICAgIHRoaXNbaV1bN10gKz0geTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIEFic29sdXRpemUgYW5kIHBhcnNlIHBhdGggdG8gYXJyYXlcblxuXG4gIHBhcnNlKGQgPSAnTTAgMCcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkKSkge1xuICAgICAgZCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGQpLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhQYXJzZXIoZCk7XG4gIH0gLy8gUmVzaXplIHBhdGggc3RyaW5nXG5cblxuICBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAvLyBnZXQgYm91bmRpbmcgYm94IG9mIGN1cnJlbnQgc2l0dWF0aW9uXG4gICAgY29uc3QgYm94ID0gdGhpcy5iYm94KCk7XG4gICAgbGV0IGksIGw7IC8vIElmIHRoZSBib3ggd2lkdGggb3IgaGVpZ2h0IGlzIDAgdGhlbiB3ZSBpZ25vcmVcbiAgICAvLyB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIHJlc3BlY3RpdmUgYXhpc1xuXG4gICAgYm94LndpZHRoID0gYm94LndpZHRoID09PSAwID8gMSA6IGJveC53aWR0aDtcbiAgICBib3guaGVpZ2h0ID0gYm94LmhlaWdodCA9PT0gMCA/IDEgOiBib3guaGVpZ2h0OyAvLyByZWNhbGN1bGF0ZSBwb3NpdGlvbiBvZiBhbGwgcG9pbnRzIGFjY29yZGluZyB0byBuZXcgc2l6ZVxuXG4gICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgbCA9IHRoaXNbaV1bMF07XG5cbiAgICAgIGlmIChsID09PSAnTScgfHwgbCA9PT0gJ0wnIHx8IGwgPT09ICdUJykge1xuICAgICAgICB0aGlzW2ldWzFdID0gKHRoaXNbaV1bMV0gLSBib3gueCkgKiB3aWR0aCAvIGJveC53aWR0aCArIGJveC54O1xuICAgICAgICB0aGlzW2ldWzJdID0gKHRoaXNbaV1bMl0gLSBib3gueSkgKiBoZWlnaHQgLyBib3guaGVpZ2h0ICsgYm94Lnk7XG4gICAgICB9IGVsc2UgaWYgKGwgPT09ICdIJykge1xuICAgICAgICB0aGlzW2ldWzFdID0gKHRoaXNbaV1bMV0gLSBib3gueCkgKiB3aWR0aCAvIGJveC53aWR0aCArIGJveC54O1xuICAgICAgfSBlbHNlIGlmIChsID09PSAnVicpIHtcbiAgICAgICAgdGhpc1tpXVsxXSA9ICh0aGlzW2ldWzFdIC0gYm94LnkpICogaGVpZ2h0IC8gYm94LmhlaWdodCArIGJveC55O1xuICAgICAgfSBlbHNlIGlmIChsID09PSAnQycgfHwgbCA9PT0gJ1MnIHx8IGwgPT09ICdRJykge1xuICAgICAgICB0aGlzW2ldWzFdID0gKHRoaXNbaV1bMV0gLSBib3gueCkgKiB3aWR0aCAvIGJveC53aWR0aCArIGJveC54O1xuICAgICAgICB0aGlzW2ldWzJdID0gKHRoaXNbaV1bMl0gLSBib3gueSkgKiBoZWlnaHQgLyBib3guaGVpZ2h0ICsgYm94Lnk7XG4gICAgICAgIHRoaXNbaV1bM10gPSAodGhpc1tpXVszXSAtIGJveC54KSAqIHdpZHRoIC8gYm94LndpZHRoICsgYm94Lng7XG4gICAgICAgIHRoaXNbaV1bNF0gPSAodGhpc1tpXVs0XSAtIGJveC55KSAqIGhlaWdodCAvIGJveC5oZWlnaHQgKyBib3gueTtcblxuICAgICAgICBpZiAobCA9PT0gJ0MnKSB7XG4gICAgICAgICAgdGhpc1tpXVs1XSA9ICh0aGlzW2ldWzVdIC0gYm94LngpICogd2lkdGggLyBib3gud2lkdGggKyBib3gueDtcbiAgICAgICAgICB0aGlzW2ldWzZdID0gKHRoaXNbaV1bNl0gLSBib3gueSkgKiBoZWlnaHQgLyBib3guaGVpZ2h0ICsgYm94Lnk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobCA9PT0gJ0EnKSB7XG4gICAgICAgIC8vIHJlc2l6ZSByYWRpaVxuICAgICAgICB0aGlzW2ldWzFdID0gdGhpc1tpXVsxXSAqIHdpZHRoIC8gYm94LndpZHRoO1xuICAgICAgICB0aGlzW2ldWzJdID0gdGhpc1tpXVsyXSAqIGhlaWdodCAvIGJveC5oZWlnaHQ7IC8vIG1vdmUgcG9zaXRpb24gdmFsdWVzXG5cbiAgICAgICAgdGhpc1tpXVs2XSA9ICh0aGlzW2ldWzZdIC0gYm94LngpICogd2lkdGggLyBib3gud2lkdGggKyBib3gueDtcbiAgICAgICAgdGhpc1tpXVs3XSA9ICh0aGlzW2ldWzddIC0gYm94LnkpICogaGVpZ2h0IC8gYm94LmhlaWdodCArIGJveC55O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIENvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG5cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYXJyYXlUb1N0cmluZyh0aGlzKTtcbiAgfVxuXG59XG5cbmNvbnN0IGdldENsYXNzRm9yVHlwZSA9IHZhbHVlID0+IHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gU1ZHTnVtYmVyO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKENvbG9yLmlzQ29sb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gQ29sb3I7XG4gICAgfSBlbHNlIGlmIChkZWxpbWl0ZXIudGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBpc1BhdGhMZXR0ZXIudGVzdCh2YWx1ZSkgPyBQYXRoQXJyYXkgOiBTVkdBcnJheTtcbiAgICB9IGVsc2UgaWYgKG51bWJlckFuZFVuaXQudGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBTVkdOdW1iZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBOb25Nb3JwaGFibGU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG1vcnBoYWJsZVR5cGVzLmluZGV4T2YodmFsdWUuY29uc3RydWN0b3IpID4gLTEpIHtcbiAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3I7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gU1ZHQXJyYXk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gT2JqZWN0QmFnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBOb25Nb3JwaGFibGU7XG4gIH1cbn07XG5cbmNsYXNzIE1vcnBoYWJsZSB7XG4gIGNvbnN0cnVjdG9yKHN0ZXBwZXIpIHtcbiAgICB0aGlzLl9zdGVwcGVyID0gc3RlcHBlciB8fCBuZXcgRWFzZSgnLScpO1xuICAgIHRoaXMuX2Zyb20gPSBudWxsO1xuICAgIHRoaXMuX3RvID0gbnVsbDtcbiAgICB0aGlzLl90eXBlID0gbnVsbDtcbiAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9tb3JwaE9iaiA9IG51bGw7XG4gIH1cblxuICBhdChwb3MpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9ycGhPYmoubW9ycGgodGhpcy5fZnJvbSwgdGhpcy5fdG8sIHBvcywgdGhpcy5fc3RlcHBlciwgdGhpcy5fY29udGV4dCk7XG4gIH1cblxuICBkb25lKCkge1xuICAgIGNvbnN0IGNvbXBsZXRlID0gdGhpcy5fY29udGV4dC5tYXAodGhpcy5fc3RlcHBlci5kb25lKS5yZWR1Y2UoZnVuY3Rpb24gKGxhc3QsIGN1cnIpIHtcbiAgICAgIHJldHVybiBsYXN0ICYmIGN1cnI7XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY29tcGxldGU7XG4gIH1cblxuICBmcm9tKHZhbCkge1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Zyb207XG4gICAgfVxuXG4gICAgdGhpcy5fZnJvbSA9IHRoaXMuX3NldCh2YWwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3RlcHBlcihzdGVwcGVyKSB7XG4gICAgaWYgKHN0ZXBwZXIgPT0gbnVsbCkgcmV0dXJuIHRoaXMuX3N0ZXBwZXI7XG4gICAgdGhpcy5fc3RlcHBlciA9IHN0ZXBwZXI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0byh2YWwpIHtcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl90bztcbiAgICB9XG5cbiAgICB0aGlzLl90byA9IHRoaXMuX3NldCh2YWwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdHlwZSh0eXBlKSB7XG4gICAgLy8gZ2V0dGVyXG4gICAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgfSAvLyBzZXR0ZXJcblxuXG4gICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBfc2V0KHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLl90eXBlKSB7XG4gICAgICB0aGlzLnR5cGUoZ2V0Q2xhc3NGb3JUeXBlKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IG5ldyB0aGlzLl90eXBlKHZhbHVlKTtcblxuICAgIGlmICh0aGlzLl90eXBlID09PSBDb2xvcikge1xuICAgICAgcmVzdWx0ID0gdGhpcy5fdG8gPyByZXN1bHRbdGhpcy5fdG9bNF1dKCkgOiB0aGlzLl9mcm9tID8gcmVzdWx0W3RoaXMuX2Zyb21bNF1dKCkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3R5cGUgPT09IE9iamVjdEJhZykge1xuICAgICAgcmVzdWx0ID0gdGhpcy5fdG8gPyByZXN1bHQuYWxpZ24odGhpcy5fdG8pIDogdGhpcy5fZnJvbSA/IHJlc3VsdC5hbGlnbih0aGlzLl9mcm9tKSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQgPSByZXN1bHQudG9Db25zdW1hYmxlKCk7XG4gICAgdGhpcy5fbW9ycGhPYmogPSB0aGlzLl9tb3JwaE9iaiB8fCBuZXcgdGhpcy5fdHlwZSgpO1xuICAgIHRoaXMuX2NvbnRleHQgPSB0aGlzLl9jb250ZXh0IHx8IEFycmF5LmFwcGx5KG51bGwsIEFycmF5KHJlc3VsdC5sZW5ndGgpKS5tYXAoT2JqZWN0KS5tYXAoZnVuY3Rpb24gKG8pIHtcbiAgICAgIG8uZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbztcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbn1cbmNsYXNzIE5vbk1vcnBoYWJsZSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICB0aGlzLmluaXQoLi4uYXJncyk7XG4gIH1cblxuICBpbml0KHZhbCkge1xuICAgIHZhbCA9IEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbFswXSA6IHZhbDtcbiAgICB0aGlzLnZhbHVlID0gdmFsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gW3RoaXMudmFsdWVdO1xuICB9XG5cbiAgdmFsdWVPZigpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxuXG59XG5jbGFzcyBUcmFuc2Zvcm1CYWcge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgdGhpcy5pbml0KC4uLmFyZ3MpO1xuICB9XG5cbiAgaW5pdChvYmopIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICBvYmogPSB7XG4gICAgICAgIHNjYWxlWDogb2JqWzBdLFxuICAgICAgICBzY2FsZVk6IG9ialsxXSxcbiAgICAgICAgc2hlYXI6IG9ialsyXSxcbiAgICAgICAgcm90YXRlOiBvYmpbM10sXG4gICAgICAgIHRyYW5zbGF0ZVg6IG9ials0XSxcbiAgICAgICAgdHJhbnNsYXRlWTogb2JqWzVdLFxuICAgICAgICBvcmlnaW5YOiBvYmpbNl0sXG4gICAgICAgIG9yaWdpblk6IG9ials3XVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIFRyYW5zZm9ybUJhZy5kZWZhdWx0cywgb2JqKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRvQXJyYXkoKSB7XG4gICAgY29uc3QgdiA9IHRoaXM7XG4gICAgcmV0dXJuIFt2LnNjYWxlWCwgdi5zY2FsZVksIHYuc2hlYXIsIHYucm90YXRlLCB2LnRyYW5zbGF0ZVgsIHYudHJhbnNsYXRlWSwgdi5vcmlnaW5YLCB2Lm9yaWdpblldO1xuICB9XG5cbn1cblRyYW5zZm9ybUJhZy5kZWZhdWx0cyA9IHtcbiAgc2NhbGVYOiAxLFxuICBzY2FsZVk6IDEsXG4gIHNoZWFyOiAwLFxuICByb3RhdGU6IDAsXG4gIHRyYW5zbGF0ZVg6IDAsXG4gIHRyYW5zbGF0ZVk6IDAsXG4gIG9yaWdpblg6IDAsXG4gIG9yaWdpblk6IDBcbn07XG5cbmNvbnN0IHNvcnRCeUtleSA9IChhLCBiKSA9PiB7XG4gIHJldHVybiBhWzBdIDwgYlswXSA/IC0xIDogYVswXSA+IGJbMF0gPyAxIDogMDtcbn07XG5cbmNsYXNzIE9iamVjdEJhZyB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICB0aGlzLmluaXQoLi4uYXJncyk7XG4gIH1cblxuICBhbGlnbihvdGhlcikge1xuICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gdmFsdWVzLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgIC8vIElmIHRoZSB0eXBlIGlzIHRoZSBzYW1lIHdlIG9ubHkgbmVlZCB0byBjaGVjayBpZiB0aGUgY29sb3IgaXMgaW4gdGhlIGNvcnJlY3QgZm9ybWF0XG4gICAgICBpZiAodmFsdWVzW2kgKyAxXSA9PT0gb3RoZXJbaSArIDFdKSB7XG4gICAgICAgIGlmICh2YWx1ZXNbaSArIDFdID09PSBDb2xvciAmJiBvdGhlcltpICsgN10gIT09IHZhbHVlc1tpICsgN10pIHtcbiAgICAgICAgICBjb25zdCBzcGFjZSA9IG90aGVyW2kgKyA3XTtcbiAgICAgICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcih0aGlzLnZhbHVlcy5zcGxpY2UoaSArIDMsIDUpKVtzcGFjZV0oKS50b0FycmF5KCk7XG4gICAgICAgICAgdGhpcy52YWx1ZXMuc3BsaWNlKGkgKyAzLCAwLCAuLi5jb2xvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpICs9IHZhbHVlc1tpICsgMl0gKyAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvdGhlcltpICsgMV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IC8vIFRoZSB0eXBlcyBkaWZmZXIsIHNvIHdlIG92ZXJ3cml0ZSB0aGUgbmV3IHR5cGUgd2l0aCB0aGUgb2xkIG9uZVxuICAgICAgLy8gQW5kIGluaXRpYWxpemUgaXQgd2l0aCB0aGUgdHlwZXMgZGVmYXVsdCAoZS5nLiBibGFjayBmb3IgY29sb3Igb3IgMCBmb3IgbnVtYmVyKVxuXG5cbiAgICAgIGNvbnN0IGRlZmF1bHRPYmplY3QgPSBuZXcgb3RoZXJbaSArIDFdKCkudG9BcnJheSgpOyAvLyBUaGFuIHdlIGZpeCB0aGUgdmFsdWVzIGFycmF5XG5cbiAgICAgIGNvbnN0IHRvRGVsZXRlID0gdmFsdWVzW2kgKyAyXSArIDM7XG4gICAgICB2YWx1ZXMuc3BsaWNlKGksIHRvRGVsZXRlLCBvdGhlcltpXSwgb3RoZXJbaSArIDFdLCBvdGhlcltpICsgMl0sIC4uLmRlZmF1bHRPYmplY3QpO1xuICAgICAgaSArPSB2YWx1ZXNbaSArIDJdICsgMjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGluaXQob2JqT3JBcnIpIHtcbiAgICB0aGlzLnZhbHVlcyA9IFtdO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqT3JBcnIpKSB7XG4gICAgICB0aGlzLnZhbHVlcyA9IG9iak9yQXJyLnNsaWNlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb2JqT3JBcnIgPSBvYmpPckFyciB8fCB7fTtcbiAgICBjb25zdCBlbnRyaWVzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGkgaW4gb2JqT3JBcnIpIHtcbiAgICAgIGNvbnN0IFR5cGUgPSBnZXRDbGFzc0ZvclR5cGUob2JqT3JBcnJbaV0pO1xuICAgICAgY29uc3QgdmFsID0gbmV3IFR5cGUob2JqT3JBcnJbaV0pLnRvQXJyYXkoKTtcbiAgICAgIGVudHJpZXMucHVzaChbaSwgVHlwZSwgdmFsLmxlbmd0aCwgLi4udmFsXSk7XG4gICAgfVxuXG4gICAgZW50cmllcy5zb3J0KHNvcnRCeUtleSk7XG4gICAgdGhpcy52YWx1ZXMgPSBlbnRyaWVzLnJlZHVjZSgobGFzdCwgY3VycikgPT4gbGFzdC5jb25jYXQoY3VyciksIFtdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzO1xuICB9XG5cbiAgdmFsdWVPZigpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBjb25zdCBhcnIgPSB0aGlzLnZhbHVlczsgLy8gZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuXG4gICAgd2hpbGUgKGFyci5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGtleSA9IGFyci5zaGlmdCgpO1xuICAgICAgY29uc3QgVHlwZSA9IGFyci5zaGlmdCgpO1xuICAgICAgY29uc3QgbnVtID0gYXJyLnNoaWZ0KCk7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBhcnIuc3BsaWNlKDAsIG51bSk7XG4gICAgICBvYmpba2V5XSA9IG5ldyBUeXBlKHZhbHVlcyk7IC8vIC52YWx1ZU9mKClcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbn1cbmNvbnN0IG1vcnBoYWJsZVR5cGVzID0gW05vbk1vcnBoYWJsZSwgVHJhbnNmb3JtQmFnLCBPYmplY3RCYWddO1xuZnVuY3Rpb24gcmVnaXN0ZXJNb3JwaGFibGVUeXBlKHR5cGUgPSBbXSkge1xuICBtb3JwaGFibGVUeXBlcy5wdXNoKC4uLltdLmNvbmNhdCh0eXBlKSk7XG59XG5mdW5jdGlvbiBtYWtlTW9ycGhhYmxlKCkge1xuICBleHRlbmQobW9ycGhhYmxlVHlwZXMsIHtcbiAgICB0byh2YWwpIHtcbiAgICAgIHJldHVybiBuZXcgTW9ycGhhYmxlKCkudHlwZSh0aGlzLmNvbnN0cnVjdG9yKS5mcm9tKHRoaXMudG9BcnJheSgpKSAvLyB0aGlzLnZhbHVlT2YoKSlcbiAgICAgIC50byh2YWwpO1xuICAgIH0sXG5cbiAgICBmcm9tQXJyYXkoYXJyKSB7XG4gICAgICB0aGlzLmluaXQoYXJyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0b0NvbnN1bWFibGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0FycmF5KCk7XG4gICAgfSxcblxuICAgIG1vcnBoKGZyb20sIHRvLCBwb3MsIHN0ZXBwZXIsIGNvbnRleHQpIHtcbiAgICAgIGNvbnN0IG1hcHBlciA9IGZ1bmN0aW9uIChpLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gc3RlcHBlci5zdGVwKGksIHRvW2luZGV4XSwgcG9zLCBjb250ZXh0W2luZGV4XSwgY29udGV4dCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdGhpcy5mcm9tQXJyYXkoZnJvbS5tYXAobWFwcGVyKSk7XG4gICAgfVxuXG4gIH0pO1xufVxuXG5jbGFzcyBQYXRoIGV4dGVuZHMgU2hhcGUge1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdwYXRoJywgbm9kZSksIGF0dHJzKTtcbiAgfSAvLyBHZXQgYXJyYXlcblxuXG4gIGFycmF5KCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheSB8fCAodGhpcy5fYXJyYXkgPSBuZXcgUGF0aEFycmF5KHRoaXMuYXR0cignZCcpKSk7XG4gIH0gLy8gQ2xlYXIgYXJyYXkgY2FjaGVcblxuXG4gIGNsZWFyKCkge1xuICAgIGRlbGV0ZSB0aGlzLl9hcnJheTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBTZXQgaGVpZ2h0IG9mIGVsZW1lbnRcblxuXG4gIGhlaWdodChoZWlnaHQpIHtcbiAgICByZXR1cm4gaGVpZ2h0ID09IG51bGwgPyB0aGlzLmJib3goKS5oZWlnaHQgOiB0aGlzLnNpemUodGhpcy5iYm94KCkud2lkdGgsIGhlaWdodCk7XG4gIH0gLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXJcblxuXG4gIG1vdmUoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ2QnLCB0aGlzLmFycmF5KCkubW92ZSh4LCB5KSk7XG4gIH0gLy8gUGxvdCBuZXcgcGF0aFxuXG5cbiAgcGxvdChkKSB7XG4gICAgcmV0dXJuIGQgPT0gbnVsbCA/IHRoaXMuYXJyYXkoKSA6IHRoaXMuY2xlYXIoKS5hdHRyKCdkJywgdHlwZW9mIGQgPT09ICdzdHJpbmcnID8gZCA6IHRoaXMuX2FycmF5ID0gbmV3IFBhdGhBcnJheShkKSk7XG4gIH0gLy8gU2V0IGVsZW1lbnQgc2l6ZSB0byBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XG5cblxuICBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdkJywgdGhpcy5hcnJheSgpLnNpemUocC53aWR0aCwgcC5oZWlnaHQpKTtcbiAgfSAvLyBTZXQgd2lkdGggb2YgZWxlbWVudFxuXG5cbiAgd2lkdGgod2lkdGgpIHtcbiAgICByZXR1cm4gd2lkdGggPT0gbnVsbCA/IHRoaXMuYmJveCgpLndpZHRoIDogdGhpcy5zaXplKHdpZHRoLCB0aGlzLmJib3goKS5oZWlnaHQpO1xuICB9IC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyIG92ZXIgeC1heGlzXG5cblxuICB4KHgpIHtcbiAgICByZXR1cm4geCA9PSBudWxsID8gdGhpcy5iYm94KCkueCA6IHRoaXMubW92ZSh4LCB0aGlzLmJib3goKS55KTtcbiAgfSAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lciBvdmVyIHktYXhpc1xuXG5cbiAgeSh5KSB7XG4gICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMuYmJveCgpLnkgOiB0aGlzLm1vdmUodGhpcy5iYm94KCkueCwgeSk7XG4gIH1cblxufSAvLyBEZWZpbmUgbW9ycGhhYmxlIGFycmF5XG5cblBhdGgucHJvdG90eXBlLk1vcnBoQXJyYXkgPSBQYXRoQXJyYXk7IC8vIEFkZCBwYXJlbnQgbWV0aG9kXG5cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIENvbnRhaW5lcjoge1xuICAgIC8vIENyZWF0ZSBhIHdyYXBwZWQgcGF0aCBlbGVtZW50XG4gICAgcGF0aDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKGQpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBwbG90IGlzIGNhbGxlZCBhcyBhIHNldHRlclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBQYXRoKCkpLnBsb3QoZCB8fCBuZXcgUGF0aEFycmF5KCkpO1xuICAgIH0pXG4gIH1cbn0pO1xucmVnaXN0ZXIoUGF0aCwgJ1BhdGgnKTtcblxuZnVuY3Rpb24gYXJyYXkoKSB7XG4gIHJldHVybiB0aGlzLl9hcnJheSB8fCAodGhpcy5fYXJyYXkgPSBuZXcgUG9pbnRBcnJheSh0aGlzLmF0dHIoJ3BvaW50cycpKSk7XG59IC8vIENsZWFyIGFycmF5IGNhY2hlXG5cbmZ1bmN0aW9uIGNsZWFyKCkge1xuICBkZWxldGUgdGhpcy5fYXJyYXk7XG4gIHJldHVybiB0aGlzO1xufSAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lclxuXG5mdW5jdGlvbiBtb3ZlJDIoeCwgeSkge1xuICByZXR1cm4gdGhpcy5hdHRyKCdwb2ludHMnLCB0aGlzLmFycmF5KCkubW92ZSh4LCB5KSk7XG59IC8vIFBsb3QgbmV3IHBhdGhcblxuZnVuY3Rpb24gcGxvdChwKSB7XG4gIHJldHVybiBwID09IG51bGwgPyB0aGlzLmFycmF5KCkgOiB0aGlzLmNsZWFyKCkuYXR0cigncG9pbnRzJywgdHlwZW9mIHAgPT09ICdzdHJpbmcnID8gcCA6IHRoaXMuX2FycmF5ID0gbmV3IFBvaW50QXJyYXkocCkpO1xufSAvLyBTZXQgZWxlbWVudCBzaXplIHRvIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcblxuZnVuY3Rpb24gc2l6ZSQxKHdpZHRoLCBoZWlnaHQpIHtcbiAgY29uc3QgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodCk7XG4gIHJldHVybiB0aGlzLmF0dHIoJ3BvaW50cycsIHRoaXMuYXJyYXkoKS5zaXplKHAud2lkdGgsIHAuaGVpZ2h0KSk7XG59XG5cbnZhciBwb2x5ID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIGFycmF5OiBhcnJheSxcbiAgY2xlYXI6IGNsZWFyLFxuICBtb3ZlOiBtb3ZlJDIsXG4gIHBsb3Q6IHBsb3QsXG4gIHNpemU6IHNpemUkMVxufTtcblxuY2xhc3MgUG9seWdvbiBleHRlbmRzIFNoYXBlIHtcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygncG9seWdvbicsIG5vZGUpLCBhdHRycyk7XG4gIH1cblxufVxucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgLy8gQ3JlYXRlIGEgd3JhcHBlZCBwb2x5Z29uIGVsZW1lbnRcbiAgICBwb2x5Z29uOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAocCkge1xuICAgICAgLy8gbWFrZSBzdXJlIHBsb3QgaXMgY2FsbGVkIGFzIGEgc2V0dGVyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFBvbHlnb24oKSkucGxvdChwIHx8IG5ldyBQb2ludEFycmF5KCkpO1xuICAgIH0pXG4gIH1cbn0pO1xuZXh0ZW5kKFBvbHlnb24sIHBvaW50ZWQpO1xuZXh0ZW5kKFBvbHlnb24sIHBvbHkpO1xucmVnaXN0ZXIoUG9seWdvbiwgJ1BvbHlnb24nKTtcblxuY2xhc3MgUG9seWxpbmUgZXh0ZW5kcyBTaGFwZSB7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ3BvbHlsaW5lJywgbm9kZSksIGF0dHJzKTtcbiAgfVxuXG59XG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBDcmVhdGUgYSB3cmFwcGVkIHBvbHlnb24gZWxlbWVudFxuICAgIHBvbHlsaW5lOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAocCkge1xuICAgICAgLy8gbWFrZSBzdXJlIHBsb3QgaXMgY2FsbGVkIGFzIGEgc2V0dGVyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFBvbHlsaW5lKCkpLnBsb3QocCB8fCBuZXcgUG9pbnRBcnJheSgpKTtcbiAgICB9KVxuICB9XG59KTtcbmV4dGVuZChQb2x5bGluZSwgcG9pbnRlZCk7XG5leHRlbmQoUG9seWxpbmUsIHBvbHkpO1xucmVnaXN0ZXIoUG9seWxpbmUsICdQb2x5bGluZScpO1xuXG5jbGFzcyBSZWN0IGV4dGVuZHMgU2hhcGUge1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdyZWN0Jywgbm9kZSksIGF0dHJzKTtcbiAgfVxuXG59XG5leHRlbmQoUmVjdCwge1xuICByeCxcbiAgcnlcbn0pO1xucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgLy8gQ3JlYXRlIGEgcmVjdCBlbGVtZW50XG4gICAgcmVjdDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgUmVjdCgpKS5zaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0pXG4gIH1cbn0pO1xucmVnaXN0ZXIoUmVjdCwgJ1JlY3QnKTtcblxuY2xhc3MgUXVldWUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9maXJzdCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdCA9IG51bGw7XG4gIH0gLy8gU2hvd3MgdXMgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3RcblxuXG4gIGZpcnN0KCkge1xuICAgIHJldHVybiB0aGlzLl9maXJzdCAmJiB0aGlzLl9maXJzdC52YWx1ZTtcbiAgfSAvLyBTaG93cyB1cyB0aGUgbGFzdCBpdGVtIGluIHRoZSBsaXN0XG5cblxuICBsYXN0KCkge1xuICAgIHJldHVybiB0aGlzLl9sYXN0ICYmIHRoaXMuX2xhc3QudmFsdWU7XG4gIH1cblxuICBwdXNoKHZhbHVlKSB7XG4gICAgLy8gQW4gaXRlbSBzdG9yZXMgYW4gaWQgYW5kIHRoZSBwcm92aWRlZCB2YWx1ZVxuICAgIGNvbnN0IGl0ZW0gPSB0eXBlb2YgdmFsdWUubmV4dCAhPT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6IHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIG5leHQ6IG51bGwsXG4gICAgICBwcmV2OiBudWxsXG4gICAgfTsgLy8gRGVhbCB3aXRoIHRoZSBxdWV1ZSBiZWluZyBlbXB0eSBvciBwb3B1bGF0ZWRcblxuICAgIGlmICh0aGlzLl9sYXN0KSB7XG4gICAgICBpdGVtLnByZXYgPSB0aGlzLl9sYXN0O1xuICAgICAgdGhpcy5fbGFzdC5uZXh0ID0gaXRlbTtcbiAgICAgIHRoaXMuX2xhc3QgPSBpdGVtO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9sYXN0ID0gaXRlbTtcbiAgICAgIHRoaXMuX2ZpcnN0ID0gaXRlbTtcbiAgICB9IC8vIFJldHVybiB0aGUgY3VycmVudCBpdGVtXG5cblxuICAgIHJldHVybiBpdGVtO1xuICB9IC8vIFJlbW92ZXMgdGhlIGl0ZW0gdGhhdCB3YXMgcmV0dXJuZWQgZnJvbSB0aGUgcHVzaFxuXG5cbiAgcmVtb3ZlKGl0ZW0pIHtcbiAgICAvLyBSZWxpbmsgdGhlIHByZXZpb3VzIGl0ZW1cbiAgICBpZiAoaXRlbS5wcmV2KSBpdGVtLnByZXYubmV4dCA9IGl0ZW0ubmV4dDtcbiAgICBpZiAoaXRlbS5uZXh0KSBpdGVtLm5leHQucHJldiA9IGl0ZW0ucHJldjtcbiAgICBpZiAoaXRlbSA9PT0gdGhpcy5fbGFzdCkgdGhpcy5fbGFzdCA9IGl0ZW0ucHJldjtcbiAgICBpZiAoaXRlbSA9PT0gdGhpcy5fZmlyc3QpIHRoaXMuX2ZpcnN0ID0gaXRlbS5uZXh0OyAvLyBJbnZhbGlkYXRlIGl0ZW1cblxuICAgIGl0ZW0ucHJldiA9IG51bGw7XG4gICAgaXRlbS5uZXh0ID0gbnVsbDtcbiAgfVxuXG4gIHNoaWZ0KCkge1xuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYSB2YWx1ZVxuICAgIGNvbnN0IHJlbW92ZSA9IHRoaXMuX2ZpcnN0O1xuICAgIGlmICghcmVtb3ZlKSByZXR1cm4gbnVsbDsgLy8gSWYgd2UgZG8sIHJlbW92ZSBpdCBhbmQgcmVsaW5rIHRoaW5nc1xuXG4gICAgdGhpcy5fZmlyc3QgPSByZW1vdmUubmV4dDtcbiAgICBpZiAodGhpcy5fZmlyc3QpIHRoaXMuX2ZpcnN0LnByZXYgPSBudWxsO1xuICAgIHRoaXMuX2xhc3QgPSB0aGlzLl9maXJzdCA/IHRoaXMuX2xhc3QgOiBudWxsO1xuICAgIHJldHVybiByZW1vdmUudmFsdWU7XG4gIH1cblxufVxuXG5jb25zdCBBbmltYXRvciA9IHtcbiAgbmV4dERyYXc6IG51bGwsXG4gIGZyYW1lczogbmV3IFF1ZXVlKCksXG4gIHRpbWVvdXRzOiBuZXcgUXVldWUoKSxcbiAgaW1tZWRpYXRlczogbmV3IFF1ZXVlKCksXG4gIHRpbWVyOiAoKSA9PiBnbG9iYWxzLndpbmRvdy5wZXJmb3JtYW5jZSB8fCBnbG9iYWxzLndpbmRvdy5EYXRlLFxuICB0cmFuc2Zvcm1zOiBbXSxcblxuICBmcmFtZShmbikge1xuICAgIC8vIFN0b3JlIHRoZSBub2RlXG4gICAgY29uc3Qgbm9kZSA9IEFuaW1hdG9yLmZyYW1lcy5wdXNoKHtcbiAgICAgIHJ1bjogZm5cbiAgICB9KTsgLy8gUmVxdWVzdCBhbiBhbmltYXRpb24gZnJhbWUgaWYgd2UgZG9uJ3QgaGF2ZSBvbmVcblxuICAgIGlmIChBbmltYXRvci5uZXh0RHJhdyA9PT0gbnVsbCkge1xuICAgICAgQW5pbWF0b3IubmV4dERyYXcgPSBnbG9iYWxzLndpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoQW5pbWF0b3IuX2RyYXcpO1xuICAgIH0gLy8gUmV0dXJuIHRoZSBub2RlIHNvIHdlIGNhbiByZW1vdmUgaXQgZWFzaWx5XG5cblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIHRpbWVvdXQoZm4sIGRlbGF5KSB7XG4gICAgZGVsYXkgPSBkZWxheSB8fCAwOyAvLyBXb3JrIG91dCB3aGVuIHRoZSBldmVudCBzaG91bGQgZmlyZVxuXG4gICAgY29uc3QgdGltZSA9IEFuaW1hdG9yLnRpbWVyKCkubm93KCkgKyBkZWxheTsgLy8gQWRkIHRoZSB0aW1lb3V0IHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG5cbiAgICBjb25zdCBub2RlID0gQW5pbWF0b3IudGltZW91dHMucHVzaCh7XG4gICAgICBydW46IGZuLFxuICAgICAgdGltZTogdGltZVxuICAgIH0pOyAvLyBSZXF1ZXN0IGFub3RoZXIgYW5pbWF0aW9uIGZyYW1lIGlmIHdlIG5lZWQgb25lXG5cbiAgICBpZiAoQW5pbWF0b3IubmV4dERyYXcgPT09IG51bGwpIHtcbiAgICAgIEFuaW1hdG9yLm5leHREcmF3ID0gZ2xvYmFscy53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKEFuaW1hdG9yLl9kcmF3KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICBpbW1lZGlhdGUoZm4pIHtcbiAgICAvLyBBZGQgdGhlIGltbWVkaWF0ZSBmbiB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuICAgIGNvbnN0IG5vZGUgPSBBbmltYXRvci5pbW1lZGlhdGVzLnB1c2goZm4pOyAvLyBSZXF1ZXN0IGFub3RoZXIgYW5pbWF0aW9uIGZyYW1lIGlmIHdlIG5lZWQgb25lXG5cbiAgICBpZiAoQW5pbWF0b3IubmV4dERyYXcgPT09IG51bGwpIHtcbiAgICAgIEFuaW1hdG9yLm5leHREcmF3ID0gZ2xvYmFscy53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKEFuaW1hdG9yLl9kcmF3KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICBjYW5jZWxGcmFtZShub2RlKSB7XG4gICAgbm9kZSAhPSBudWxsICYmIEFuaW1hdG9yLmZyYW1lcy5yZW1vdmUobm9kZSk7XG4gIH0sXG5cbiAgY2xlYXJUaW1lb3V0KG5vZGUpIHtcbiAgICBub2RlICE9IG51bGwgJiYgQW5pbWF0b3IudGltZW91dHMucmVtb3ZlKG5vZGUpO1xuICB9LFxuXG4gIGNhbmNlbEltbWVkaWF0ZShub2RlKSB7XG4gICAgbm9kZSAhPSBudWxsICYmIEFuaW1hdG9yLmltbWVkaWF0ZXMucmVtb3ZlKG5vZGUpO1xuICB9LFxuXG4gIF9kcmF3KG5vdykge1xuICAgIC8vIFJ1biBhbGwgdGhlIHRpbWVvdXRzIHdlIGNhbiBydW4sIGlmIHRoZXkgYXJlIG5vdCByZWFkeSB5ZXQsIGFkZCB0aGVtXG4gICAgLy8gdG8gdGhlIGVuZCBvZiB0aGUgcXVldWUgaW1tZWRpYXRlbHkhIChiYWQgdGltZW91dHMhISEgW3NhcmNhc21dKVxuICAgIGxldCBuZXh0VGltZW91dCA9IG51bGw7XG4gICAgY29uc3QgbGFzdFRpbWVvdXQgPSBBbmltYXRvci50aW1lb3V0cy5sYXN0KCk7XG5cbiAgICB3aGlsZSAobmV4dFRpbWVvdXQgPSBBbmltYXRvci50aW1lb3V0cy5zaGlmdCgpKSB7XG4gICAgICAvLyBSdW4gdGhlIHRpbWVvdXQgaWYgaXRzIHRpbWUsIG9yIHB1c2ggaXQgdG8gdGhlIGVuZFxuICAgICAgaWYgKG5vdyA+PSBuZXh0VGltZW91dC50aW1lKSB7XG4gICAgICAgIG5leHRUaW1lb3V0LnJ1bigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQW5pbWF0b3IudGltZW91dHMucHVzaChuZXh0VGltZW91dCk7XG4gICAgICB9IC8vIElmIHdlIGhpdCB0aGUgbGFzdCBpdGVtLCB3ZSBzaG91bGQgc3RvcCBzaGlmdGluZyBvdXQgbW9yZSBpdGVtc1xuXG5cbiAgICAgIGlmIChuZXh0VGltZW91dCA9PT0gbGFzdFRpbWVvdXQpIGJyZWFrO1xuICAgIH0gLy8gUnVuIGFsbCBvZiB0aGUgYW5pbWF0aW9uIGZyYW1lc1xuXG5cbiAgICBsZXQgbmV4dEZyYW1lID0gbnVsbDtcbiAgICBjb25zdCBsYXN0RnJhbWUgPSBBbmltYXRvci5mcmFtZXMubGFzdCgpO1xuXG4gICAgd2hpbGUgKG5leHRGcmFtZSAhPT0gbGFzdEZyYW1lICYmIChuZXh0RnJhbWUgPSBBbmltYXRvci5mcmFtZXMuc2hpZnQoKSkpIHtcbiAgICAgIG5leHRGcmFtZS5ydW4obm93KTtcbiAgICB9XG5cbiAgICBsZXQgbmV4dEltbWVkaWF0ZSA9IG51bGw7XG5cbiAgICB3aGlsZSAobmV4dEltbWVkaWF0ZSA9IEFuaW1hdG9yLmltbWVkaWF0ZXMuc2hpZnQoKSkge1xuICAgICAgbmV4dEltbWVkaWF0ZSgpO1xuICAgIH0gLy8gSWYgd2UgaGF2ZSByZW1haW5pbmcgdGltZW91dHMgb3IgZnJhbWVzLCBkcmF3IHVudGlsIHdlIGRvbid0IGFueW1vcmVcblxuXG4gICAgQW5pbWF0b3IubmV4dERyYXcgPSBBbmltYXRvci50aW1lb3V0cy5maXJzdCgpIHx8IEFuaW1hdG9yLmZyYW1lcy5maXJzdCgpID8gZ2xvYmFscy53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKEFuaW1hdG9yLl9kcmF3KSA6IG51bGw7XG4gIH1cblxufTtcblxuY29uc3QgbWFrZVNjaGVkdWxlID0gZnVuY3Rpb24gKHJ1bm5lckluZm8pIHtcbiAgY29uc3Qgc3RhcnQgPSBydW5uZXJJbmZvLnN0YXJ0O1xuICBjb25zdCBkdXJhdGlvbiA9IHJ1bm5lckluZm8ucnVubmVyLmR1cmF0aW9uKCk7XG4gIGNvbnN0IGVuZCA9IHN0YXJ0ICsgZHVyYXRpb247XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICBlbmQ6IGVuZCxcbiAgICBydW5uZXI6IHJ1bm5lckluZm8ucnVubmVyXG4gIH07XG59O1xuXG5jb25zdCBkZWZhdWx0U291cmNlID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCB3ID0gZ2xvYmFscy53aW5kb3c7XG4gIHJldHVybiAody5wZXJmb3JtYW5jZSB8fCB3LkRhdGUpLm5vdygpO1xufTtcblxuY2xhc3MgVGltZWxpbmUgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gIC8vIENvbnN0cnVjdCBhIG5ldyB0aW1lbGluZSBvbiB0aGUgZ2l2ZW4gZWxlbWVudFxuICBjb25zdHJ1Y3Rvcih0aW1lU291cmNlID0gZGVmYXVsdFNvdXJjZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fdGltZVNvdXJjZSA9IHRpbWVTb3VyY2U7IC8vIFN0b3JlIHRoZSB0aW1pbmcgdmFyaWFibGVzXG5cbiAgICB0aGlzLl9zdGFydFRpbWUgPSAwO1xuICAgIHRoaXMuX3NwZWVkID0gMS4wOyAvLyBEZXRlcm1pbmVzIGhvdyBsb25nIGEgcnVubmVyIGlzIGhvbGQgaW4gbWVtb3J5LiBDYW4gYmUgYSBkdCBvciB0cnVlL2ZhbHNlXG5cbiAgICB0aGlzLl9wZXJzaXN0ID0gMDsgLy8gS2VlcCB0cmFjayBvZiB0aGUgcnVubmluZyBhbmltYXRpb25zIGFuZCB0aGVpciBzdGFydGluZyBwYXJhbWV0ZXJzXG5cbiAgICB0aGlzLl9uZXh0RnJhbWUgPSBudWxsO1xuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgdGhpcy5fcnVubmVycyA9IFtdO1xuICAgIHRoaXMuX3J1bm5lcklkcyA9IFtdO1xuICAgIHRoaXMuX2xhc3RSdW5uZXJJZCA9IC0xO1xuICAgIHRoaXMuX3RpbWUgPSAwO1xuICAgIHRoaXMuX2xhc3RTb3VyY2VUaW1lID0gMDtcbiAgICB0aGlzLl9sYXN0U3RlcFRpbWUgPSAwOyAvLyBNYWtlIHN1cmUgdGhhdCBzdGVwIGlzIGFsd2F5cyBjYWxsZWQgaW4gY2xhc3MgY29udGV4dFxuXG4gICAgdGhpcy5fc3RlcCA9IHRoaXMuX3N0ZXBGbi5iaW5kKHRoaXMsIGZhbHNlKTtcbiAgICB0aGlzLl9zdGVwSW1tZWRpYXRlID0gdGhpcy5fc3RlcEZuLmJpbmQodGhpcywgdHJ1ZSk7XG4gIH1cblxuICBhY3RpdmUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fbmV4dEZyYW1lO1xuICB9XG5cbiAgZmluaXNoKCkge1xuICAgIC8vIEdvIHRvIGVuZCBhbmQgcGF1c2VcbiAgICB0aGlzLnRpbWUodGhpcy5nZXRFbmRUaW1lT2ZUaW1lbGluZSgpICsgMSk7XG4gICAgcmV0dXJuIHRoaXMucGF1c2UoKTtcbiAgfSAvLyBDYWxjdWxhdGVzIHRoZSBlbmQgb2YgdGhlIHRpbWVsaW5lXG5cblxuICBnZXRFbmRUaW1lKCkge1xuICAgIGNvbnN0IGxhc3RSdW5uZXJJbmZvID0gdGhpcy5nZXRMYXN0UnVubmVySW5mbygpO1xuICAgIGNvbnN0IGxhc3REdXJhdGlvbiA9IGxhc3RSdW5uZXJJbmZvID8gbGFzdFJ1bm5lckluZm8ucnVubmVyLmR1cmF0aW9uKCkgOiAwO1xuICAgIGNvbnN0IGxhc3RTdGFydFRpbWUgPSBsYXN0UnVubmVySW5mbyA/IGxhc3RSdW5uZXJJbmZvLnN0YXJ0IDogdGhpcy5fdGltZTtcbiAgICByZXR1cm4gbGFzdFN0YXJ0VGltZSArIGxhc3REdXJhdGlvbjtcbiAgfVxuXG4gIGdldEVuZFRpbWVPZlRpbWVsaW5lKCkge1xuICAgIGNvbnN0IGVuZFRpbWVzID0gdGhpcy5fcnVubmVycy5tYXAoaSA9PiBpLnN0YXJ0ICsgaS5ydW5uZXIuZHVyYXRpb24oKSk7XG5cbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgLi4uZW5kVGltZXMpO1xuICB9XG5cbiAgZ2V0TGFzdFJ1bm5lckluZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVubmVySW5mb0J5SWQodGhpcy5fbGFzdFJ1bm5lcklkKTtcbiAgfVxuXG4gIGdldFJ1bm5lckluZm9CeUlkKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3J1bm5lcnNbdGhpcy5fcnVubmVySWRzLmluZGV4T2YoaWQpXSB8fCBudWxsO1xuICB9XG5cbiAgcGF1c2UoKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5fY29udGludWUoKTtcbiAgfVxuXG4gIHBlcnNpc3QoZHRPckZvcmV2ZXIpIHtcbiAgICBpZiAoZHRPckZvcmV2ZXIgPT0gbnVsbCkgcmV0dXJuIHRoaXMuX3BlcnNpc3Q7XG4gICAgdGhpcy5fcGVyc2lzdCA9IGR0T3JGb3JldmVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcGxheSgpIHtcbiAgICAvLyBOb3cgbWFrZSBzdXJlIHdlIGFyZSBub3QgcGF1c2VkIGFuZCBjb250aW51ZSB0aGUgYW5pbWF0aW9uXG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVGltZSgpLl9jb250aW51ZSgpO1xuICB9XG5cbiAgcmV2ZXJzZSh5ZXMpIHtcbiAgICBjb25zdCBjdXJyZW50U3BlZWQgPSB0aGlzLnNwZWVkKCk7XG4gICAgaWYgKHllcyA9PSBudWxsKSByZXR1cm4gdGhpcy5zcGVlZCgtY3VycmVudFNwZWVkKTtcbiAgICBjb25zdCBwb3NpdGl2ZSA9IE1hdGguYWJzKGN1cnJlbnRTcGVlZCk7XG4gICAgcmV0dXJuIHRoaXMuc3BlZWQoeWVzID8gLXBvc2l0aXZlIDogcG9zaXRpdmUpO1xuICB9IC8vIHNjaGVkdWxlcyBhIHJ1bm5lciBvbiB0aGUgdGltZWxpbmVcblxuXG4gIHNjaGVkdWxlKHJ1bm5lciwgZGVsYXksIHdoZW4pIHtcbiAgICBpZiAocnVubmVyID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5uZXJzLm1hcChtYWtlU2NoZWR1bGUpO1xuICAgIH0gLy8gVGhlIHN0YXJ0IHRpbWUgZm9yIHRoZSBuZXh0IGFuaW1hdGlvbiBjYW4gZWl0aGVyIGJlIGdpdmVuIGV4cGxpY2l0bHksXG4gICAgLy8gZGVyaXZlZCBmcm9tIHRoZSBjdXJyZW50IHRpbWVsaW5lIHRpbWUgb3IgaXQgY2FuIGJlIHJlbGF0aXZlIHRvIHRoZVxuICAgIC8vIGxhc3Qgc3RhcnQgdGltZSB0byBjaGFpbiBhbmltYXRpb25zIGRpcmVjdGx5XG5cblxuICAgIGxldCBhYnNvbHV0ZVN0YXJ0VGltZSA9IDA7XG4gICAgY29uc3QgZW5kVGltZSA9IHRoaXMuZ2V0RW5kVGltZSgpO1xuICAgIGRlbGF5ID0gZGVsYXkgfHwgMDsgLy8gV29yayBvdXQgd2hlbiB0byBzdGFydCB0aGUgYW5pbWF0aW9uXG5cbiAgICBpZiAod2hlbiA9PSBudWxsIHx8IHdoZW4gPT09ICdsYXN0JyB8fCB3aGVuID09PSAnYWZ0ZXInKSB7XG4gICAgICAvLyBUYWtlIHRoZSBsYXN0IHRpbWUgYW5kIGluY3JlbWVudFxuICAgICAgYWJzb2x1dGVTdGFydFRpbWUgPSBlbmRUaW1lO1xuICAgIH0gZWxzZSBpZiAod2hlbiA9PT0gJ2Fic29sdXRlJyB8fCB3aGVuID09PSAnc3RhcnQnKSB7XG4gICAgICBhYnNvbHV0ZVN0YXJ0VGltZSA9IGRlbGF5O1xuICAgICAgZGVsYXkgPSAwO1xuICAgIH0gZWxzZSBpZiAod2hlbiA9PT0gJ25vdycpIHtcbiAgICAgIGFic29sdXRlU3RhcnRUaW1lID0gdGhpcy5fdGltZTtcbiAgICB9IGVsc2UgaWYgKHdoZW4gPT09ICdyZWxhdGl2ZScpIHtcbiAgICAgIGNvbnN0IHJ1bm5lckluZm8gPSB0aGlzLmdldFJ1bm5lckluZm9CeUlkKHJ1bm5lci5pZCk7XG5cbiAgICAgIGlmIChydW5uZXJJbmZvKSB7XG4gICAgICAgIGFic29sdXRlU3RhcnRUaW1lID0gcnVubmVySW5mby5zdGFydCArIGRlbGF5O1xuICAgICAgICBkZWxheSA9IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh3aGVuID09PSAnd2l0aC1sYXN0Jykge1xuICAgICAgY29uc3QgbGFzdFJ1bm5lckluZm8gPSB0aGlzLmdldExhc3RSdW5uZXJJbmZvKCk7XG4gICAgICBjb25zdCBsYXN0U3RhcnRUaW1lID0gbGFzdFJ1bm5lckluZm8gPyBsYXN0UnVubmVySW5mby5zdGFydCA6IHRoaXMuX3RpbWU7XG4gICAgICBhYnNvbHV0ZVN0YXJ0VGltZSA9IGxhc3RTdGFydFRpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgdGhlIFwid2hlblwiIHBhcmFtZXRlcicpO1xuICAgIH0gLy8gTWFuYWdlIHJ1bm5lclxuXG5cbiAgICBydW5uZXIudW5zY2hlZHVsZSgpO1xuICAgIHJ1bm5lci50aW1lbGluZSh0aGlzKTtcbiAgICBjb25zdCBwZXJzaXN0ID0gcnVubmVyLnBlcnNpc3QoKTtcbiAgICBjb25zdCBydW5uZXJJbmZvID0ge1xuICAgICAgcGVyc2lzdDogcGVyc2lzdCA9PT0gbnVsbCA/IHRoaXMuX3BlcnNpc3QgOiBwZXJzaXN0LFxuICAgICAgc3RhcnQ6IGFic29sdXRlU3RhcnRUaW1lICsgZGVsYXksXG4gICAgICBydW5uZXJcbiAgICB9O1xuICAgIHRoaXMuX2xhc3RSdW5uZXJJZCA9IHJ1bm5lci5pZDtcblxuICAgIHRoaXMuX3J1bm5lcnMucHVzaChydW5uZXJJbmZvKTtcblxuICAgIHRoaXMuX3J1bm5lcnMuc29ydCgoYSwgYikgPT4gYS5zdGFydCAtIGIuc3RhcnQpO1xuXG4gICAgdGhpcy5fcnVubmVySWRzID0gdGhpcy5fcnVubmVycy5tYXAoaW5mbyA9PiBpbmZvLnJ1bm5lci5pZCk7XG5cbiAgICB0aGlzLnVwZGF0ZVRpbWUoKS5fY29udGludWUoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2VlayhkdCkge1xuICAgIHJldHVybiB0aGlzLnRpbWUodGhpcy5fdGltZSArIGR0KTtcbiAgfVxuXG4gIHNvdXJjZShmbikge1xuICAgIGlmIChmbiA9PSBudWxsKSByZXR1cm4gdGhpcy5fdGltZVNvdXJjZTtcbiAgICB0aGlzLl90aW1lU291cmNlID0gZm47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzcGVlZChzcGVlZCkge1xuICAgIGlmIChzcGVlZCA9PSBudWxsKSByZXR1cm4gdGhpcy5fc3BlZWQ7XG4gICAgdGhpcy5fc3BlZWQgPSBzcGVlZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgLy8gR28gdG8gc3RhcnQgYW5kIHBhdXNlXG4gICAgdGhpcy50aW1lKDApO1xuICAgIHJldHVybiB0aGlzLnBhdXNlKCk7XG4gIH1cblxuICB0aW1lKHRpbWUpIHtcbiAgICBpZiAodGltZSA9PSBudWxsKSByZXR1cm4gdGhpcy5fdGltZTtcbiAgICB0aGlzLl90aW1lID0gdGltZTtcbiAgICByZXR1cm4gdGhpcy5fY29udGludWUodHJ1ZSk7XG4gIH0gLy8gUmVtb3ZlIHRoZSBydW5uZXIgZnJvbSB0aGlzIHRpbWVsaW5lXG5cblxuICB1bnNjaGVkdWxlKHJ1bm5lcikge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fcnVubmVySWRzLmluZGV4T2YocnVubmVyLmlkKTtcblxuICAgIGlmIChpbmRleCA8IDApIHJldHVybiB0aGlzO1xuXG4gICAgdGhpcy5fcnVubmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgdGhpcy5fcnVubmVySWRzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICBydW5uZXIudGltZWxpbmUobnVsbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gTWFrZXMgc3VyZSwgdGhhdCBhZnRlciBwYXVzaW5nIHRoZSB0aW1lIGRvZXNuJ3QganVtcFxuXG5cbiAgdXBkYXRlVGltZSgpIHtcbiAgICBpZiAoIXRoaXMuYWN0aXZlKCkpIHtcbiAgICAgIHRoaXMuX2xhc3RTb3VyY2VUaW1lID0gdGhpcy5fdGltZVNvdXJjZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIENoZWNrcyBpZiB3ZSBhcmUgcnVubmluZyBhbmQgY29udGludWVzIHRoZSBhbmltYXRpb25cblxuXG4gIF9jb250aW51ZShpbW1lZGlhdGVTdGVwID0gZmFsc2UpIHtcbiAgICBBbmltYXRvci5jYW5jZWxGcmFtZSh0aGlzLl9uZXh0RnJhbWUpO1xuICAgIHRoaXMuX25leHRGcmFtZSA9IG51bGw7XG4gICAgaWYgKGltbWVkaWF0ZVN0ZXApIHJldHVybiB0aGlzLl9zdGVwSW1tZWRpYXRlKCk7XG4gICAgaWYgKHRoaXMuX3BhdXNlZCkgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5fbmV4dEZyYW1lID0gQW5pbWF0b3IuZnJhbWUodGhpcy5fc3RlcCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBfc3RlcEZuKGltbWVkaWF0ZVN0ZXAgPSBmYWxzZSkge1xuICAgIC8vIEdldCB0aGUgdGltZSBkZWx0YSBmcm9tIHRoZSBsYXN0IHRpbWUgYW5kIHVwZGF0ZSB0aGUgdGltZVxuICAgIGNvbnN0IHRpbWUgPSB0aGlzLl90aW1lU291cmNlKCk7XG5cbiAgICBsZXQgZHRTb3VyY2UgPSB0aW1lIC0gdGhpcy5fbGFzdFNvdXJjZVRpbWU7XG4gICAgaWYgKGltbWVkaWF0ZVN0ZXApIGR0U291cmNlID0gMDtcbiAgICBjb25zdCBkdFRpbWUgPSB0aGlzLl9zcGVlZCAqIGR0U291cmNlICsgKHRoaXMuX3RpbWUgLSB0aGlzLl9sYXN0U3RlcFRpbWUpO1xuICAgIHRoaXMuX2xhc3RTb3VyY2VUaW1lID0gdGltZTsgLy8gT25seSB1cGRhdGUgdGhlIHRpbWUgaWYgd2UgdXNlIHRoZSB0aW1lU291cmNlLlxuICAgIC8vIE90aGVyd2lzZSB1c2UgdGhlIGN1cnJlbnQgdGltZVxuXG4gICAgaWYgKCFpbW1lZGlhdGVTdGVwKSB7XG4gICAgICAvLyBVcGRhdGUgdGhlIHRpbWVcbiAgICAgIHRoaXMuX3RpbWUgKz0gZHRUaW1lO1xuICAgICAgdGhpcy5fdGltZSA9IHRoaXMuX3RpbWUgPCAwID8gMCA6IHRoaXMuX3RpbWU7XG4gICAgfVxuXG4gICAgdGhpcy5fbGFzdFN0ZXBUaW1lID0gdGhpcy5fdGltZTtcbiAgICB0aGlzLmZpcmUoJ3RpbWUnLCB0aGlzLl90aW1lKTsgLy8gVGhpcyBpcyBmb3IgdGhlIGNhc2UgdGhhdCB0aGUgdGltZWxpbmUgd2FzIHNlZWtlZCBzbyB0aGF0IHRoZSB0aW1lXG4gICAgLy8gaXMgbm93IGJlZm9yZSB0aGUgc3RhcnRUaW1lIG9mIHRoZSBydW5uZXIuIFRoYXQgaXMgd2h5IHdlIG5lZWQgdG8gc2V0XG4gICAgLy8gdGhlIHJ1bm5lciB0byBwb3NpdGlvbiAwXG4gICAgLy8gRklYTUU6XG4gICAgLy8gSG93ZXZlciwgcmVzZXR0aW5nIGluIGluc2VydGlvbiBvcmRlciBsZWFkcyB0byBidWdzLiBDb25zaWRlcmluZyB0aGUgY2FzZSxcbiAgICAvLyB3aGVyZSAyIHJ1bm5lcnMgY2hhbmdlIHRoZSBzYW1lIGF0dHJpYnV0ZSBidXQgaW4gZGlmZmVyZW50IHRpbWVzLFxuICAgIC8vIHJlc2V0dGluZyBib3RoIG9mIHRoZW0gd2lsbCBsZWFkIHRvIHRoZSBjYXNlIHdoZXJlIHRoZSBsYXRlciBkZWZpbmVkXG4gICAgLy8gcnVubmVyIGFsd2F5cyB3aW5zIHRoZSByZXNldCBldmVuIGlmIHRoZSBvdGhlciBydW5uZXIgc3RhcnRlZCBlYXJsaWVyXG4gICAgLy8gYW5kIHRoZXJlZm9yZSBzaG91bGQgd2luIHRoZSBhdHRyaWJ1dGUgYmF0dGxlXG4gICAgLy8gdGhpcyBjYW4gYmUgc29sdmVkIGJ5IHJlc2V0dGluZyB0aGVtIGJhY2t3YXJkc1xuXG4gICAgZm9yIChsZXQgayA9IHRoaXMuX3J1bm5lcnMubGVuZ3RoOyBrLS07KSB7XG4gICAgICAvLyBHZXQgYW5kIHJ1biB0aGUgY3VycmVudCBydW5uZXIgYW5kIGlnbm9yZSBpdCBpZiBpdHMgaW5hY3RpdmVcbiAgICAgIGNvbnN0IHJ1bm5lckluZm8gPSB0aGlzLl9ydW5uZXJzW2tdO1xuICAgICAgY29uc3QgcnVubmVyID0gcnVubmVySW5mby5ydW5uZXI7IC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGdpdmUgdGhlIGFjdHVhbCBkaWZmZXJlbmNlXG4gICAgICAvLyBiZXR3ZWVuIHJ1bm5lciBzdGFydCB0aW1lIGFuZCBub3dcblxuICAgICAgY29uc3QgZHRUb1N0YXJ0ID0gdGhpcy5fdGltZSAtIHJ1bm5lckluZm8uc3RhcnQ7IC8vIERvbnQgcnVuIHJ1bm5lciBpZiBub3Qgc3RhcnRlZCB5ZXRcbiAgICAgIC8vIGFuZCB0cnkgdG8gcmVzZXQgaXRcblxuICAgICAgaWYgKGR0VG9TdGFydCA8PSAwKSB7XG4gICAgICAgIHJ1bm5lci5yZXNldCgpO1xuICAgICAgfVxuICAgIH0gLy8gUnVuIGFsbCBvZiB0aGUgcnVubmVycyBkaXJlY3RseVxuXG5cbiAgICBsZXQgcnVubmVyc0xlZnQgPSBmYWxzZTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9ydW5uZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAvLyBHZXQgYW5kIHJ1biB0aGUgY3VycmVudCBydW5uZXIgYW5kIGlnbm9yZSBpdCBpZiBpdHMgaW5hY3RpdmVcbiAgICAgIGNvbnN0IHJ1bm5lckluZm8gPSB0aGlzLl9ydW5uZXJzW2ldO1xuICAgICAgY29uc3QgcnVubmVyID0gcnVubmVySW5mby5ydW5uZXI7XG4gICAgICBsZXQgZHQgPSBkdFRpbWU7IC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGdpdmUgdGhlIGFjdHVhbCBkaWZmZXJlbmNlXG4gICAgICAvLyBiZXR3ZWVuIHJ1bm5lciBzdGFydCB0aW1lIGFuZCBub3dcblxuICAgICAgY29uc3QgZHRUb1N0YXJ0ID0gdGhpcy5fdGltZSAtIHJ1bm5lckluZm8uc3RhcnQ7IC8vIERvbnQgcnVuIHJ1bm5lciBpZiBub3Qgc3RhcnRlZCB5ZXRcblxuICAgICAgaWYgKGR0VG9TdGFydCA8PSAwKSB7XG4gICAgICAgIHJ1bm5lcnNMZWZ0ID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKGR0VG9TdGFydCA8IGR0KSB7XG4gICAgICAgIC8vIEFkanVzdCBkdCB0byBtYWtlIHN1cmUgdGhhdCBhbmltYXRpb24gaXMgb24gcG9pbnRcbiAgICAgICAgZHQgPSBkdFRvU3RhcnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghcnVubmVyLmFjdGl2ZSgpKSBjb250aW51ZTsgLy8gSWYgdGhpcyBydW5uZXIgaXMgc3RpbGwgZ29pbmcsIHNpZ25hbCB0aGF0IHdlIG5lZWQgYW5vdGhlciBhbmltYXRpb25cbiAgICAgIC8vIGZyYW1lLCBvdGhlcndpc2UsIHJlbW92ZSB0aGUgY29tcGxldGVkIHJ1bm5lclxuXG4gICAgICBjb25zdCBmaW5pc2hlZCA9IHJ1bm5lci5zdGVwKGR0KS5kb25lO1xuXG4gICAgICBpZiAoIWZpbmlzaGVkKSB7XG4gICAgICAgIHJ1bm5lcnNMZWZ0ID0gdHJ1ZTsgLy8gY29udGludWVcbiAgICAgIH0gZWxzZSBpZiAocnVubmVySW5mby5wZXJzaXN0ICE9PSB0cnVlKSB7XG4gICAgICAgIC8vIHJ1bm5lciBpcyBmaW5pc2hlZC4gQW5kIHJ1bm5lciBtaWdodCBnZXQgcmVtb3ZlZFxuICAgICAgICBjb25zdCBlbmRUaW1lID0gcnVubmVyLmR1cmF0aW9uKCkgLSBydW5uZXIudGltZSgpICsgdGhpcy5fdGltZTtcblxuICAgICAgICBpZiAoZW5kVGltZSArIHJ1bm5lckluZm8ucGVyc2lzdCA8IHRoaXMuX3RpbWUpIHtcbiAgICAgICAgICAvLyBEZWxldGUgcnVubmVyIGFuZCBjb3JyZWN0IGluZGV4XG4gICAgICAgICAgcnVubmVyLnVuc2NoZWR1bGUoKTtcbiAgICAgICAgICAtLWk7XG4gICAgICAgICAgLS1sZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIEJhc2ljYWxseTogd2UgY29udGludWUgd2hlbiB0aGVyZSBhcmUgcnVubmVycyByaWdodCBmcm9tIHVzIGluIHRpbWVcbiAgICAvLyB3aGVuIC0tPiwgYW5kIHdoZW4gcnVubmVycyBhcmUgbGVmdCBmcm9tIHVzIHdoZW4gPC0tXG5cblxuICAgIGlmIChydW5uZXJzTGVmdCAmJiAhKHRoaXMuX3NwZWVkIDwgMCAmJiB0aGlzLl90aW1lID09PSAwKSB8fCB0aGlzLl9ydW5uZXJJZHMubGVuZ3RoICYmIHRoaXMuX3NwZWVkIDwgMCAmJiB0aGlzLl90aW1lID4gMCkge1xuICAgICAgdGhpcy5fY29udGludWUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgdGhpcy5maXJlKCdmaW5pc2hlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn1cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIEVsZW1lbnQ6IHtcbiAgICB0aW1lbGluZTogZnVuY3Rpb24gKHRpbWVsaW5lKSB7XG4gICAgICBpZiAodGltZWxpbmUgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl90aW1lbGluZSA9IHRoaXMuX3RpbWVsaW5lIHx8IG5ldyBUaW1lbGluZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdGltZWxpbmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl90aW1lbGluZSA9IHRpbWVsaW5lO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG5jbGFzcyBSdW5uZXIgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpOyAvLyBTdG9yZSBhIHVuaXF1ZSBpZCBvbiB0aGUgcnVubmVyLCBzbyB0aGF0IHdlIGNhbiBpZGVudGlmeSBpdCBsYXRlclxuXG4gICAgdGhpcy5pZCA9IFJ1bm5lci5pZCsrOyAvLyBFbnN1cmUgYSBkZWZhdWx0IHZhbHVlXG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyA9PSBudWxsID8gdGltZWxpbmUuZHVyYXRpb24gOiBvcHRpb25zOyAvLyBFbnN1cmUgdGhhdCB3ZSBnZXQgYSBjb250cm9sbGVyXG5cbiAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgPyBuZXcgQ29udHJvbGxlcihvcHRpb25zKSA6IG9wdGlvbnM7IC8vIERlY2xhcmUgYWxsIG9mIHRoZSB2YXJpYWJsZXNcblxuICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX3RpbWVsaW5lID0gbnVsbDtcbiAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdOyAvLyBXb3JrIG91dCB0aGUgc3RlcHBlciBhbmQgdGhlIGR1cmF0aW9uXG5cbiAgICB0aGlzLl9kdXJhdGlvbiA9IHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJyAmJiBvcHRpb25zO1xuICAgIHRoaXMuX2lzRGVjbGFyYXRpdmUgPSBvcHRpb25zIGluc3RhbmNlb2YgQ29udHJvbGxlcjtcbiAgICB0aGlzLl9zdGVwcGVyID0gdGhpcy5faXNEZWNsYXJhdGl2ZSA/IG9wdGlvbnMgOiBuZXcgRWFzZSgpOyAvLyBXZSBjb3B5IHRoZSBjdXJyZW50IHZhbHVlcyBmcm9tIHRoZSB0aW1lbGluZSBiZWNhdXNlIHRoZXkgY2FuIGNoYW5nZVxuXG4gICAgdGhpcy5faGlzdG9yeSA9IHt9OyAvLyBTdG9yZSB0aGUgc3RhdGUgb2YgdGhlIHJ1bm5lclxuXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLl90aW1lID0gMDtcbiAgICB0aGlzLl9sYXN0VGltZSA9IDA7IC8vIEF0IGNyZWF0aW9uLCB0aGUgcnVubmVyIGlzIGluIHJlc2V0IHN0YXRlXG5cbiAgICB0aGlzLl9yZXNldGVkID0gdHJ1ZTsgLy8gU2F2ZSB0cmFuc2Zvcm1zIGFwcGxpZWQgdG8gdGhpcyBydW5uZXJcblxuICAgIHRoaXMudHJhbnNmb3JtcyA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLnRyYW5zZm9ybUlkID0gMTsgLy8gTG9vcGluZyB2YXJpYWJsZXNcblxuICAgIHRoaXMuX2hhdmVSZXZlcnNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JldmVyc2UgPSBmYWxzZTtcbiAgICB0aGlzLl9sb29wc0RvbmUgPSAwO1xuICAgIHRoaXMuX3N3aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd2FpdCA9IDA7XG4gICAgdGhpcy5fdGltZXMgPSAxO1xuICAgIHRoaXMuX2ZyYW1lSWQgPSBudWxsOyAvLyBTdG9yZXMgaG93IGxvbmcgYSBydW5uZXIgaXMgc3RvcmVkIGFmdGVyIGJlaW5nIGRvbmVcblxuICAgIHRoaXMuX3BlcnNpc3QgPSB0aGlzLl9pc0RlY2xhcmF0aXZlID8gdHJ1ZSA6IG51bGw7XG4gIH1cblxuICBzdGF0aWMgc2FuaXRpc2UoZHVyYXRpb24sIGRlbGF5LCB3aGVuKSB7XG4gICAgLy8gSW5pdGlhbGlzZSB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG4gICAgbGV0IHRpbWVzID0gMTtcbiAgICBsZXQgc3dpbmcgPSBmYWxzZTtcbiAgICBsZXQgd2FpdCA9IDA7XG4gICAgZHVyYXRpb24gPSBkdXJhdGlvbiB8fCB0aW1lbGluZS5kdXJhdGlvbjtcbiAgICBkZWxheSA9IGRlbGF5IHx8IHRpbWVsaW5lLmRlbGF5O1xuICAgIHdoZW4gPSB3aGVuIHx8ICdsYXN0JzsgLy8gSWYgd2UgaGF2ZSBhbiBvYmplY3QsIHVucGFjayB0aGUgdmFsdWVzXG5cbiAgICBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJiAhKGR1cmF0aW9uIGluc3RhbmNlb2YgU3RlcHBlcikpIHtcbiAgICAgIGRlbGF5ID0gZHVyYXRpb24uZGVsYXkgfHwgZGVsYXk7XG4gICAgICB3aGVuID0gZHVyYXRpb24ud2hlbiB8fCB3aGVuO1xuICAgICAgc3dpbmcgPSBkdXJhdGlvbi5zd2luZyB8fCBzd2luZztcbiAgICAgIHRpbWVzID0gZHVyYXRpb24udGltZXMgfHwgdGltZXM7XG4gICAgICB3YWl0ID0gZHVyYXRpb24ud2FpdCB8fCB3YWl0O1xuICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbi5kdXJhdGlvbiB8fCB0aW1lbGluZS5kdXJhdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgZGVsYXk6IGRlbGF5LFxuICAgICAgc3dpbmc6IHN3aW5nLFxuICAgICAgdGltZXM6IHRpbWVzLFxuICAgICAgd2FpdDogd2FpdCxcbiAgICAgIHdoZW46IHdoZW5cbiAgICB9O1xuICB9XG5cbiAgYWN0aXZlKGVuYWJsZWQpIHtcbiAgICBpZiAoZW5hYmxlZCA9PSBudWxsKSByZXR1cm4gdGhpcy5lbmFibGVkO1xuICAgIHRoaXMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLypcbiAgUHJpdmF0ZSBNZXRob2RzXG4gID09PT09PT09PT09PT09PVxuICBNZXRob2RzIHRoYXQgc2hvdWxkbid0IGJlIHVzZWQgZXh0ZXJuYWxseVxuICAqL1xuXG5cbiAgYWRkVHJhbnNmb3JtKHRyYW5zZm9ybSwgaW5kZXgpIHtcbiAgICB0aGlzLnRyYW5zZm9ybXMubG11bHRpcGx5Tyh0cmFuc2Zvcm0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYWZ0ZXIoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5vbignZmluaXNoZWQnLCBmbik7XG4gIH1cblxuICBhbmltYXRlKGR1cmF0aW9uLCBkZWxheSwgd2hlbikge1xuICAgIGNvbnN0IG8gPSBSdW5uZXIuc2FuaXRpc2UoZHVyYXRpb24sIGRlbGF5LCB3aGVuKTtcbiAgICBjb25zdCBydW5uZXIgPSBuZXcgUnVubmVyKG8uZHVyYXRpb24pO1xuICAgIGlmICh0aGlzLl90aW1lbGluZSkgcnVubmVyLnRpbWVsaW5lKHRoaXMuX3RpbWVsaW5lKTtcbiAgICBpZiAodGhpcy5fZWxlbWVudCkgcnVubmVyLmVsZW1lbnQodGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHJ1bm5lci5sb29wKG8pLnNjaGVkdWxlKG8uZGVsYXksIG8ud2hlbik7XG4gIH1cblxuICBjbGVhclRyYW5zZm9ybSgpIHtcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSBuZXcgTWF0cml4KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gVE9ETzogS2VlcCB0cmFjayBvZiBhbGwgdHJhbnNmb3JtYXRpb25zIHNvIHRoYXQgZGVsZXRpb24gaXMgZmFzdGVyXG5cblxuICBjbGVhclRyYW5zZm9ybXNGcm9tUXVldWUoKSB7XG4gICAgaWYgKCF0aGlzLmRvbmUgfHwgIXRoaXMuX3RpbWVsaW5lIHx8ICF0aGlzLl90aW1lbGluZS5fcnVubmVySWRzLmluY2x1ZGVzKHRoaXMuaWQpKSB7XG4gICAgICB0aGlzLl9xdWV1ZSA9IHRoaXMuX3F1ZXVlLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgcmV0dXJuICFpdGVtLmlzVHJhbnNmb3JtO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZGVsYXkoZGVsYXkpIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRlKDAsIGRlbGF5KTtcbiAgfVxuXG4gIGR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lcyAqICh0aGlzLl93YWl0ICsgdGhpcy5fZHVyYXRpb24pIC0gdGhpcy5fd2FpdDtcbiAgfVxuXG4gIGR1cmluZyhmbikge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlKG51bGwsIGZuKTtcbiAgfVxuXG4gIGVhc2UoZm4pIHtcbiAgICB0aGlzLl9zdGVwcGVyID0gbmV3IEVhc2UoZm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qXG4gIFJ1bm5lciBEZWZpbml0aW9uc1xuICA9PT09PT09PT09PT09PT09PT1cbiAgVGhlc2UgbWV0aG9kcyBoZWxwIHVzIGRlZmluZSB0aGUgcnVudGltZSBiZWhhdmlvdXIgb2YgdGhlIFJ1bm5lciBvciB0aGV5XG4gIGhlbHAgdXMgbWFrZSBuZXcgcnVubmVycyBmcm9tIHRoZSBjdXJyZW50IHJ1bm5lclxuICAqL1xuXG5cbiAgZWxlbWVudChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICBlbGVtZW50Ll9wcmVwYXJlUnVubmVyKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZpbmlzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGVwKEluZmluaXR5KTtcbiAgfVxuXG4gIGxvb3AodGltZXMsIHN3aW5nLCB3YWl0KSB7XG4gICAgLy8gRGVhbCB3aXRoIHRoZSB1c2VyIHBhc3NpbmcgaW4gYW4gb2JqZWN0XG4gICAgaWYgKHR5cGVvZiB0aW1lcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHN3aW5nID0gdGltZXMuc3dpbmc7XG4gICAgICB3YWl0ID0gdGltZXMud2FpdDtcbiAgICAgIHRpbWVzID0gdGltZXMudGltZXM7XG4gICAgfSAvLyBTYW5pdGlzZSB0aGUgdmFsdWVzIGFuZCBzdG9yZSB0aGVtXG5cblxuICAgIHRoaXMuX3RpbWVzID0gdGltZXMgfHwgSW5maW5pdHk7XG4gICAgdGhpcy5fc3dpbmcgPSBzd2luZyB8fCBmYWxzZTtcbiAgICB0aGlzLl93YWl0ID0gd2FpdCB8fCAwOyAvLyBBbGxvdyB0cnVlIHRvIGJlIHBhc3NlZFxuXG4gICAgaWYgKHRoaXMuX3RpbWVzID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl90aW1lcyA9IEluZmluaXR5O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbG9vcHMocCkge1xuICAgIGNvbnN0IGxvb3BEdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fd2FpdDtcblxuICAgIGlmIChwID09IG51bGwpIHtcbiAgICAgIGNvbnN0IGxvb3BzRG9uZSA9IE1hdGguZmxvb3IodGhpcy5fdGltZSAvIGxvb3BEdXJhdGlvbik7XG4gICAgICBjb25zdCByZWxhdGl2ZVRpbWUgPSB0aGlzLl90aW1lIC0gbG9vcHNEb25lICogbG9vcER1cmF0aW9uO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSByZWxhdGl2ZVRpbWUgLyB0aGlzLl9kdXJhdGlvbjtcbiAgICAgIHJldHVybiBNYXRoLm1pbihsb29wc0RvbmUgKyBwb3NpdGlvbiwgdGhpcy5fdGltZXMpO1xuICAgIH1cblxuICAgIGNvbnN0IHdob2xlID0gTWF0aC5mbG9vcihwKTtcbiAgICBjb25zdCBwYXJ0aWFsID0gcCAlIDE7XG4gICAgY29uc3QgdGltZSA9IGxvb3BEdXJhdGlvbiAqIHdob2xlICsgdGhpcy5fZHVyYXRpb24gKiBwYXJ0aWFsO1xuICAgIHJldHVybiB0aGlzLnRpbWUodGltZSk7XG4gIH1cblxuICBwZXJzaXN0KGR0T3JGb3JldmVyKSB7XG4gICAgaWYgKGR0T3JGb3JldmVyID09IG51bGwpIHJldHVybiB0aGlzLl9wZXJzaXN0O1xuICAgIHRoaXMuX3BlcnNpc3QgPSBkdE9yRm9yZXZlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHBvc2l0aW9uKHApIHtcbiAgICAvLyBHZXQgYWxsIG9mIHRoZSB2YXJpYWJsZXMgd2UgbmVlZFxuICAgIGNvbnN0IHggPSB0aGlzLl90aW1lO1xuICAgIGNvbnN0IGQgPSB0aGlzLl9kdXJhdGlvbjtcbiAgICBjb25zdCB3ID0gdGhpcy5fd2FpdDtcbiAgICBjb25zdCB0ID0gdGhpcy5fdGltZXM7XG4gICAgY29uc3QgcyA9IHRoaXMuX3N3aW5nO1xuICAgIGNvbnN0IHIgPSB0aGlzLl9yZXZlcnNlO1xuICAgIGxldCBwb3NpdGlvbjtcblxuICAgIGlmIChwID09IG51bGwpIHtcbiAgICAgIC8qXG4gICAgICBUaGlzIGZ1bmN0aW9uIGNvbnZlcnRzIGEgdGltZSB0byBhIHBvc2l0aW9uIGluIHRoZSByYW5nZSBbMCwgMV1cbiAgICAgIFRoZSBmdWxsIGV4cGxhbmF0aW9uIGNhbiBiZSBmb3VuZCBpbiB0aGlzIGRlc21vcyBkZW1vbnN0cmF0aW9uXG4gICAgICAgIGh0dHBzOi8vd3d3LmRlc21vcy5jb20vY2FsY3VsYXRvci91NGZiYXZnY2hlXG4gICAgICBUaGUgbG9naWMgaXMgc2xpZ2h0bHkgc2ltcGxpZmllZCBoZXJlIGJlY2F1c2Ugd2UgY2FuIHVzZSBib29sZWFuc1xuICAgICAgKi9cbiAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIHZhbHVlIHdpdGhvdXQgdGhpbmtpbmcgYWJvdXQgdGhlIHN0YXJ0IG9yIGVuZCB0aW1lXG4gICAgICBjb25zdCBmID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgY29uc3Qgc3dpbmdpbmcgPSBzICogTWF0aC5mbG9vcih4ICUgKDIgKiAodyArIGQpKSAvICh3ICsgZCkpO1xuICAgICAgICBjb25zdCBiYWNrd2FyZHMgPSBzd2luZ2luZyAmJiAhciB8fCAhc3dpbmdpbmcgJiYgcjtcbiAgICAgICAgY29uc3QgdW5jbGlwZWQgPSBNYXRoLnBvdygtMSwgYmFja3dhcmRzKSAqICh4ICUgKHcgKyBkKSkgLyBkICsgYmFja3dhcmRzO1xuICAgICAgICBjb25zdCBjbGlwcGVkID0gTWF0aC5tYXgoTWF0aC5taW4odW5jbGlwZWQsIDEpLCAwKTtcbiAgICAgICAgcmV0dXJuIGNsaXBwZWQ7XG4gICAgICB9OyAvLyBGaWd1cmUgb3V0IHRoZSB2YWx1ZSBieSBpbmNvcnBvcmF0aW5nIHRoZSBzdGFydCB0aW1lXG5cblxuICAgICAgY29uc3QgZW5kVGltZSA9IHQgKiAodyArIGQpIC0gdztcbiAgICAgIHBvc2l0aW9uID0geCA8PSAwID8gTWF0aC5yb3VuZChmKDFlLTUpKSA6IHggPCBlbmRUaW1lID8gZih4KSA6IE1hdGgucm91bmQoZihlbmRUaW1lIC0gMWUtNSkpO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH0gLy8gV29yayBvdXQgdGhlIGxvb3BzIGRvbmUgYW5kIGFkZCB0aGUgcG9zaXRpb24gdG8gdGhlIGxvb3BzIGRvbmVcblxuXG4gICAgY29uc3QgbG9vcHNEb25lID0gTWF0aC5mbG9vcih0aGlzLmxvb3BzKCkpO1xuICAgIGNvbnN0IHN3aW5nRm9yd2FyZCA9IHMgJiYgbG9vcHNEb25lICUgMiA9PT0gMDtcbiAgICBjb25zdCBmb3J3YXJkcyA9IHN3aW5nRm9yd2FyZCAmJiAhciB8fCByICYmIHN3aW5nRm9yd2FyZDtcbiAgICBwb3NpdGlvbiA9IGxvb3BzRG9uZSArIChmb3J3YXJkcyA/IHAgOiAxIC0gcCk7XG4gICAgcmV0dXJuIHRoaXMubG9vcHMocG9zaXRpb24pO1xuICB9XG5cbiAgcHJvZ3Jlc3MocCkge1xuICAgIGlmIChwID09IG51bGwpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbigxLCB0aGlzLl90aW1lIC8gdGhpcy5kdXJhdGlvbigpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50aW1lKHAgKiB0aGlzLmR1cmF0aW9uKCkpO1xuICB9XG4gIC8qXG4gIEJhc2ljIEZ1bmN0aW9uYWxpdHlcbiAgPT09PT09PT09PT09PT09PT09PVxuICBUaGVzZSBtZXRob2RzIGFsbG93IHVzIHRvIGF0dGFjaCBiYXNpYyBmdW5jdGlvbnMgdG8gdGhlIHJ1bm5lciBkaXJlY3RseVxuICAqL1xuXG5cbiAgcXVldWUoaW5pdEZuLCBydW5GbiwgcmV0YXJnZXRGbiwgaXNUcmFuc2Zvcm0pIHtcbiAgICB0aGlzLl9xdWV1ZS5wdXNoKHtcbiAgICAgIGluaXRpYWxpc2VyOiBpbml0Rm4gfHwgbm9vcCxcbiAgICAgIHJ1bm5lcjogcnVuRm4gfHwgbm9vcCxcbiAgICAgIHJldGFyZ2V0OiByZXRhcmdldEZuLFxuICAgICAgaXNUcmFuc2Zvcm06IGlzVHJhbnNmb3JtLFxuICAgICAgaW5pdGlhbGlzZWQ6IGZhbHNlLFxuICAgICAgZmluaXNoZWQ6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBjb25zdCB0aW1lbGluZSA9IHRoaXMudGltZWxpbmUoKTtcbiAgICB0aW1lbGluZSAmJiB0aGlzLnRpbWVsaW5lKCkuX2NvbnRpbnVlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICBpZiAodGhpcy5fcmVzZXRlZCkgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy50aW1lKDApO1xuICAgIHRoaXMuX3Jlc2V0ZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmV2ZXJzZShyZXZlcnNlKSB7XG4gICAgdGhpcy5fcmV2ZXJzZSA9IHJldmVyc2UgPT0gbnVsbCA/ICF0aGlzLl9yZXZlcnNlIDogcmV2ZXJzZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNjaGVkdWxlKHRpbWVsaW5lLCBkZWxheSwgd2hlbikge1xuICAgIC8vIFRoZSB1c2VyIGRvZXNuJ3QgbmVlZCB0byBwYXNzIGEgdGltZWxpbmUgaWYgd2UgYWxyZWFkeSBoYXZlIG9uZVxuICAgIGlmICghKHRpbWVsaW5lIGluc3RhbmNlb2YgVGltZWxpbmUpKSB7XG4gICAgICB3aGVuID0gZGVsYXk7XG4gICAgICBkZWxheSA9IHRpbWVsaW5lO1xuICAgICAgdGltZWxpbmUgPSB0aGlzLnRpbWVsaW5lKCk7XG4gICAgfSAvLyBJZiB0aGVyZSBpcyBubyB0aW1lbGluZSwgeWVsbCBhdCB0aGUgdXNlci4uLlxuXG5cbiAgICBpZiAoIXRpbWVsaW5lKSB7XG4gICAgICB0aHJvdyBFcnJvcignUnVubmVyIGNhbm5vdCBiZSBzY2hlZHVsZWQgd2l0aG91dCB0aW1lbGluZScpO1xuICAgIH0gLy8gU2NoZWR1bGUgdGhlIHJ1bm5lciBvbiB0aGUgdGltZWxpbmUgcHJvdmlkZWRcblxuXG4gICAgdGltZWxpbmUuc2NoZWR1bGUodGhpcywgZGVsYXksIHdoZW4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3RlcChkdCkge1xuICAgIC8vIElmIHdlIGFyZSBpbmFjdGl2ZSwgdGhpcyBzdGVwcGVyIGp1c3QgZ2V0cyBza2lwcGVkXG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybiB0aGlzOyAvLyBVcGRhdGUgdGhlIHRpbWUgYW5kIGdldCB0aGUgbmV3IHBvc2l0aW9uXG5cbiAgICBkdCA9IGR0ID09IG51bGwgPyAxNiA6IGR0O1xuICAgIHRoaXMuX3RpbWUgKz0gZHQ7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uKCk7IC8vIEZpZ3VyZSBvdXQgaWYgd2UgbmVlZCB0byBydW4gdGhlIHN0ZXBwZXIgaW4gdGhpcyBmcmFtZVxuXG4gICAgY29uc3QgcnVubmluZyA9IHRoaXMuX2xhc3RQb3NpdGlvbiAhPT0gcG9zaXRpb24gJiYgdGhpcy5fdGltZSA+PSAwO1xuICAgIHRoaXMuX2xhc3RQb3NpdGlvbiA9IHBvc2l0aW9uOyAvLyBGaWd1cmUgb3V0IGlmIHdlIGp1c3Qgc3RhcnRlZFxuXG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uKCk7XG4gICAgY29uc3QganVzdFN0YXJ0ZWQgPSB0aGlzLl9sYXN0VGltZSA8PSAwICYmIHRoaXMuX3RpbWUgPiAwO1xuICAgIGNvbnN0IGp1c3RGaW5pc2hlZCA9IHRoaXMuX2xhc3RUaW1lIDwgZHVyYXRpb24gJiYgdGhpcy5fdGltZSA+PSBkdXJhdGlvbjtcbiAgICB0aGlzLl9sYXN0VGltZSA9IHRoaXMuX3RpbWU7XG5cbiAgICBpZiAoanVzdFN0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuZmlyZSgnc3RhcnQnLCB0aGlzKTtcbiAgICB9IC8vIFdvcmsgb3V0IGlmIHRoZSBydW5uZXIgaXMgZmluaXNoZWQgc2V0IHRoZSBkb25lIGZsYWcgaGVyZSBzbyBhbmltYXRpb25zXG4gICAgLy8ga25vdywgdGhhdCB0aGV5IGFyZSBydW5uaW5nIGluIHRoZSBsYXN0IHN0ZXAgKHRoaXMgaXMgZ29vZCBmb3JcbiAgICAvLyB0cmFuc2Zvcm1hdGlvbnMgd2hpY2ggY2FuIGJlIG1lcmdlZClcblxuXG4gICAgY29uc3QgZGVjbGFyYXRpdmUgPSB0aGlzLl9pc0RlY2xhcmF0aXZlO1xuICAgIHRoaXMuZG9uZSA9ICFkZWNsYXJhdGl2ZSAmJiAhanVzdEZpbmlzaGVkICYmIHRoaXMuX3RpbWUgPj0gZHVyYXRpb247IC8vIFJ1bm5lciBpcyBydW5uaW5nLiBTbyBpdHMgbm90IGluIHJlc2V0IHN0YXRlIGFueW1vcmVcblxuICAgIHRoaXMuX3Jlc2V0ZWQgPSBmYWxzZTtcbiAgICBsZXQgY29udmVyZ2VkID0gZmFsc2U7IC8vIENhbGwgaW5pdGlhbGlzZSBhbmQgdGhlIHJ1biBmdW5jdGlvblxuXG4gICAgaWYgKHJ1bm5pbmcgfHwgZGVjbGFyYXRpdmUpIHtcbiAgICAgIHRoaXMuX2luaXRpYWxpc2UocnVubmluZyk7IC8vIGNsZWFyIHRoZSB0cmFuc2Zvcm1zIG9uIHRoaXMgcnVubmVyIHNvIHRoZXkgZG9udCBnZXQgYWRkZWQgYWdhaW4gYW5kIGFnYWluXG5cblxuICAgICAgdGhpcy50cmFuc2Zvcm1zID0gbmV3IE1hdHJpeCgpO1xuICAgICAgY29udmVyZ2VkID0gdGhpcy5fcnVuKGRlY2xhcmF0aXZlID8gZHQgOiBwb3NpdGlvbik7XG4gICAgICB0aGlzLmZpcmUoJ3N0ZXAnLCB0aGlzKTtcbiAgICB9IC8vIGNvcnJlY3QgdGhlIGRvbmUgZmxhZyBoZXJlXG4gICAgLy8gZGVjbGFyYXRpdmUgYW5pbWF0aW9ucyBpdHNlbGYga25vdyB3aGVuIHRoZXkgY29udmVyZ2VkXG5cblxuICAgIHRoaXMuZG9uZSA9IHRoaXMuZG9uZSB8fCBjb252ZXJnZWQgJiYgZGVjbGFyYXRpdmU7XG5cbiAgICBpZiAoanVzdEZpbmlzaGVkKSB7XG4gICAgICB0aGlzLmZpcmUoJ2ZpbmlzaGVkJywgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLypcbiAgUnVubmVyIGFuaW1hdGlvbiBtZXRob2RzXG4gID09PT09PT09PT09PT09PT09PT09PT09PVxuICBDb250cm9sIGhvdyB0aGUgYW5pbWF0aW9uIHBsYXlzXG4gICovXG5cblxuICB0aW1lKHRpbWUpIHtcbiAgICBpZiAodGltZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGltZTtcbiAgICB9XG5cbiAgICBjb25zdCBkdCA9IHRpbWUgLSB0aGlzLl90aW1lO1xuICAgIHRoaXMuc3RlcChkdCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aW1lbGluZSh0aW1lbGluZSkge1xuICAgIC8vIGNoZWNrIGV4cGxpY2l0bHkgZm9yIHVuZGVmaW5lZCBzbyB3ZSBjYW4gc2V0IHRoZSB0aW1lbGluZSB0byBudWxsXG4gICAgaWYgKHR5cGVvZiB0aW1lbGluZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiB0aGlzLl90aW1lbGluZTtcbiAgICB0aGlzLl90aW1lbGluZSA9IHRpbWVsaW5lO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdW5zY2hlZHVsZSgpIHtcbiAgICBjb25zdCB0aW1lbGluZSA9IHRoaXMudGltZWxpbmUoKTtcbiAgICB0aW1lbGluZSAmJiB0aW1lbGluZS51bnNjaGVkdWxlKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIFJ1biBlYWNoIGluaXRpYWxpc2UgZnVuY3Rpb24gaW4gdGhlIHJ1bm5lciBpZiByZXF1aXJlZFxuXG5cbiAgX2luaXRpYWxpc2UocnVubmluZykge1xuICAgIC8vIElmIHdlIGFyZW4ndCBydW5uaW5nLCB3ZSBzaG91bGRuJ3QgaW5pdGlhbGlzZSB3aGVuIG5vdCBkZWNsYXJhdGl2ZVxuICAgIGlmICghcnVubmluZyAmJiAhdGhpcy5faXNEZWNsYXJhdGl2ZSkgcmV0dXJuOyAvLyBMb29wIHRocm91Z2ggYWxsIG9mIHRoZSBpbml0aWFsaXNlcnNcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGluaXRpYWxpc2VyXG4gICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5fcXVldWVbaV07IC8vIERldGVybWluZSB3aGV0aGVyIHdlIG5lZWQgdG8gaW5pdGlhbGlzZVxuXG4gICAgICBjb25zdCBuZWVkc0l0ID0gdGhpcy5faXNEZWNsYXJhdGl2ZSB8fCAhY3VycmVudC5pbml0aWFsaXNlZCAmJiBydW5uaW5nO1xuICAgICAgcnVubmluZyA9ICFjdXJyZW50LmZpbmlzaGVkOyAvLyBDYWxsIHRoZSBpbml0aWFsaXNlciBpZiB3ZSBuZWVkIHRvXG5cbiAgICAgIGlmIChuZWVkc0l0ICYmIHJ1bm5pbmcpIHtcbiAgICAgICAgY3VycmVudC5pbml0aWFsaXNlci5jYWxsKHRoaXMpO1xuICAgICAgICBjdXJyZW50LmluaXRpYWxpc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gU2F2ZSBhIG1vcnBoZXIgdG8gdGhlIG1vcnBoZXIgbGlzdCBzbyB0aGF0IHdlIGNhbiByZXRhcmdldCBpdCBsYXRlclxuXG5cbiAgX3JlbWVtYmVyTW9ycGhlcihtZXRob2QsIG1vcnBoZXIpIHtcbiAgICB0aGlzLl9oaXN0b3J5W21ldGhvZF0gPSB7XG4gICAgICBtb3JwaGVyOiBtb3JwaGVyLFxuICAgICAgY2FsbGVyOiB0aGlzLl9xdWV1ZVt0aGlzLl9xdWV1ZS5sZW5ndGggLSAxXVxuICAgIH07IC8vIFdlIGhhdmUgdG8gcmVzdW1lIHRoZSB0aW1lbGluZSBpbiBjYXNlIGEgY29udHJvbGxlclxuICAgIC8vIGlzIGFscmVhZHkgZG9uZSB3aXRob3V0IGJlaW5nIGV2ZXIgcnVuXG4gICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gZS5nLiB0aGlzIGlzIGRvbmU6XG4gICAgLy8gICAgYW5pbSA9IGVsLmFuaW1hdGUobmV3IFNWRy5TcHJpbmcpXG4gICAgLy8gYW5kIGxhdGVyXG4gICAgLy8gICAgYW5pbS5tb3ZlKC4uLilcblxuICAgIGlmICh0aGlzLl9pc0RlY2xhcmF0aXZlKSB7XG4gICAgICBjb25zdCB0aW1lbGluZSA9IHRoaXMudGltZWxpbmUoKTtcbiAgICAgIHRpbWVsaW5lICYmIHRpbWVsaW5lLnBsYXkoKTtcbiAgICB9XG4gIH0gLy8gVHJ5IHRvIHNldCB0aGUgdGFyZ2V0IGZvciBhIG1vcnBoZXIgaWYgdGhlIG1vcnBoZXIgZXhpc3RzLCBvdGhlcndpc2VcbiAgLy8gUnVuIGVhY2ggcnVuIGZ1bmN0aW9uIGZvciB0aGUgcG9zaXRpb24gb3IgZHQgZ2l2ZW5cblxuXG4gIF9ydW4ocG9zaXRpb25PckR0KSB7XG4gICAgLy8gUnVuIGFsbCBvZiB0aGUgX3F1ZXVlIGRpcmVjdGx5XG4gICAgbGV0IGFsbGZpbmlzaGVkID0gdHJ1ZTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGZ1bmN0aW9uIHRvIHJ1blxuICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuX3F1ZXVlW2ldOyAvLyBSdW4gdGhlIGZ1bmN0aW9uIGlmIGl0cyBub3QgZmluaXNoZWQsIHdlIGtlZXAgdHJhY2sgb2YgdGhlIGZpbmlzaGVkXG4gICAgICAvLyBmbGFnIGZvciB0aGUgc2FrZSBvZiBkZWNsYXJhdGl2ZSBfcXVldWVcblxuICAgICAgY29uc3QgY29udmVyZ2VkID0gY3VycmVudC5ydW5uZXIuY2FsbCh0aGlzLCBwb3NpdGlvbk9yRHQpO1xuICAgICAgY3VycmVudC5maW5pc2hlZCA9IGN1cnJlbnQuZmluaXNoZWQgfHwgY29udmVyZ2VkID09PSB0cnVlO1xuICAgICAgYWxsZmluaXNoZWQgPSBhbGxmaW5pc2hlZCAmJiBjdXJyZW50LmZpbmlzaGVkO1xuICAgIH0gLy8gV2UgcmVwb3J0IHdoZW4gYWxsIG9mIHRoZSBjb25zdHJ1Y3RvcnMgYXJlIGZpbmlzaGVkXG5cblxuICAgIHJldHVybiBhbGxmaW5pc2hlZDtcbiAgfSAvLyBkbyBub3RoaW5nIGFuZCByZXR1cm4gZmFsc2VcblxuXG4gIF90cnlSZXRhcmdldChtZXRob2QsIHRhcmdldCwgZXh0cmEpIHtcbiAgICBpZiAodGhpcy5faGlzdG9yeVttZXRob2RdKSB7XG4gICAgICAvLyBpZiB0aGUgbGFzdCBtZXRob2Qgd2Fzbid0IGV2ZW4gaW5pdGlhbGlzZWQsIHRocm93IGl0IGF3YXlcbiAgICAgIGlmICghdGhpcy5faGlzdG9yeVttZXRob2RdLmNhbGxlci5pbml0aWFsaXNlZCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX3F1ZXVlLmluZGV4T2YodGhpcy5faGlzdG9yeVttZXRob2RdLmNhbGxlcik7XG5cbiAgICAgICAgdGhpcy5fcXVldWUuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIGZvciB0aGUgY2FzZSBvZiB0cmFuc2Zvcm1hdGlvbnMsIHdlIHVzZSB0aGUgc3BlY2lhbCByZXRhcmdldCBmdW5jdGlvblxuICAgICAgLy8gd2hpY2ggaGFzIGFjY2VzcyB0byB0aGUgb3V0ZXIgc2NvcGVcblxuXG4gICAgICBpZiAodGhpcy5faGlzdG9yeVttZXRob2RdLmNhbGxlci5yZXRhcmdldCkge1xuICAgICAgICB0aGlzLl9oaXN0b3J5W21ldGhvZF0uY2FsbGVyLnJldGFyZ2V0LmNhbGwodGhpcywgdGFyZ2V0LCBleHRyYSk7IC8vIGZvciBldmVyeXRoaW5nIGVsc2UgYSBzaW1wbGUgbW9ycGhlciBjaGFuZ2UgaXMgc3VmZmljaWVudFxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9oaXN0b3J5W21ldGhvZF0ubW9ycGhlci50byh0YXJnZXQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9oaXN0b3J5W21ldGhvZF0uY2FsbGVyLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICBjb25zdCB0aW1lbGluZSA9IHRoaXMudGltZWxpbmUoKTtcbiAgICAgIHRpbWVsaW5lICYmIHRpbWVsaW5lLnBsYXkoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG59XG5SdW5uZXIuaWQgPSAwO1xuY2xhc3MgRmFrZVJ1bm5lciB7XG4gIGNvbnN0cnVjdG9yKHRyYW5zZm9ybXMgPSBuZXcgTWF0cml4KCksIGlkID0gLTEsIGRvbmUgPSB0cnVlKSB7XG4gICAgdGhpcy50cmFuc2Zvcm1zID0gdHJhbnNmb3JtcztcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5kb25lID0gZG9uZTtcbiAgfVxuXG4gIGNsZWFyVHJhbnNmb3Jtc0Zyb21RdWV1ZSgpIHt9XG5cbn1cbmV4dGVuZChbUnVubmVyLCBGYWtlUnVubmVyXSwge1xuICBtZXJnZVdpdGgocnVubmVyKSB7XG4gICAgcmV0dXJuIG5ldyBGYWtlUnVubmVyKHJ1bm5lci50cmFuc2Zvcm1zLmxtdWx0aXBseSh0aGlzLnRyYW5zZm9ybXMpLCBydW5uZXIuaWQpO1xuICB9XG5cbn0pOyAvLyBGYWtlUnVubmVyLmVtcHR5UnVubmVyID0gbmV3IEZha2VSdW5uZXIoKVxuXG5jb25zdCBsbXVsdGlwbHkgPSAobGFzdCwgY3VycikgPT4gbGFzdC5sbXVsdGlwbHlPKGN1cnIpO1xuXG5jb25zdCBnZXRSdW5uZXJUcmFuc2Zvcm0gPSBydW5uZXIgPT4gcnVubmVyLnRyYW5zZm9ybXM7XG5cbmZ1bmN0aW9uIG1lcmdlVHJhbnNmb3JtcygpIHtcbiAgLy8gRmluZCB0aGUgbWF0cml4IHRvIGFwcGx5IHRvIHRoZSBlbGVtZW50IGFuZCBhcHBseSBpdFxuICBjb25zdCBydW5uZXJzID0gdGhpcy5fdHJhbnNmb3JtYXRpb25SdW5uZXJzLnJ1bm5lcnM7XG4gIGNvbnN0IG5ldFRyYW5zZm9ybSA9IHJ1bm5lcnMubWFwKGdldFJ1bm5lclRyYW5zZm9ybSkucmVkdWNlKGxtdWx0aXBseSwgbmV3IE1hdHJpeCgpKTtcbiAgdGhpcy50cmFuc2Zvcm0obmV0VHJhbnNmb3JtKTtcblxuICB0aGlzLl90cmFuc2Zvcm1hdGlvblJ1bm5lcnMubWVyZ2UoKTtcblxuICBpZiAodGhpcy5fdHJhbnNmb3JtYXRpb25SdW5uZXJzLmxlbmd0aCgpID09PSAxKSB7XG4gICAgdGhpcy5fZnJhbWVJZCA9IG51bGw7XG4gIH1cbn1cblxuY2xhc3MgUnVubmVyQXJyYXkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnJ1bm5lcnMgPSBbXTtcbiAgICB0aGlzLmlkcyA9IFtdO1xuICB9XG5cbiAgYWRkKHJ1bm5lcikge1xuICAgIGlmICh0aGlzLnJ1bm5lcnMuaW5jbHVkZXMocnVubmVyKSkgcmV0dXJuO1xuICAgIGNvbnN0IGlkID0gcnVubmVyLmlkICsgMTtcbiAgICB0aGlzLnJ1bm5lcnMucHVzaChydW5uZXIpO1xuICAgIHRoaXMuaWRzLnB1c2goaWQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2xlYXJCZWZvcmUoaWQpIHtcbiAgICBjb25zdCBkZWxldGVDbnQgPSB0aGlzLmlkcy5pbmRleE9mKGlkICsgMSkgfHwgMTtcbiAgICB0aGlzLmlkcy5zcGxpY2UoMCwgZGVsZXRlQ250LCAwKTtcbiAgICB0aGlzLnJ1bm5lcnMuc3BsaWNlKDAsIGRlbGV0ZUNudCwgbmV3IEZha2VSdW5uZXIoKSkuZm9yRWFjaChyID0+IHIuY2xlYXJUcmFuc2Zvcm1zRnJvbVF1ZXVlKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZWRpdChpZCwgbmV3UnVubmVyKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmlkcy5pbmRleE9mKGlkICsgMSk7XG4gICAgdGhpcy5pZHMuc3BsaWNlKGluZGV4LCAxLCBpZCArIDEpO1xuICAgIHRoaXMucnVubmVycy5zcGxpY2UoaW5kZXgsIDEsIG5ld1J1bm5lcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXRCeUlEKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMucnVubmVyc1t0aGlzLmlkcy5pbmRleE9mKGlkICsgMSldO1xuICB9XG5cbiAgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmlkcy5sZW5ndGg7XG4gIH1cblxuICBtZXJnZSgpIHtcbiAgICBsZXQgbGFzdFJ1bm5lciA9IG51bGw7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucnVubmVycy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgcnVubmVyID0gdGhpcy5ydW5uZXJzW2ldO1xuICAgICAgY29uc3QgY29uZGl0aW9uID0gbGFzdFJ1bm5lciAmJiBydW5uZXIuZG9uZSAmJiBsYXN0UnVubmVyLmRvbmUgLy8gZG9uJ3QgbWVyZ2UgcnVubmVyIHdoZW4gcGVyc2lzdGVkIG9uIHRpbWVsaW5lXG4gICAgICAmJiAoIXJ1bm5lci5fdGltZWxpbmUgfHwgIXJ1bm5lci5fdGltZWxpbmUuX3J1bm5lcklkcy5pbmNsdWRlcyhydW5uZXIuaWQpKSAmJiAoIWxhc3RSdW5uZXIuX3RpbWVsaW5lIHx8ICFsYXN0UnVubmVyLl90aW1lbGluZS5fcnVubmVySWRzLmluY2x1ZGVzKGxhc3RSdW5uZXIuaWQpKTtcblxuICAgICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICAvLyB0aGUgKzEgaGFwcGVucyBpbiB0aGUgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5yZW1vdmUocnVubmVyLmlkKTtcbiAgICAgICAgY29uc3QgbmV3UnVubmVyID0gcnVubmVyLm1lcmdlV2l0aChsYXN0UnVubmVyKTtcbiAgICAgICAgdGhpcy5lZGl0KGxhc3RSdW5uZXIuaWQsIG5ld1J1bm5lcik7XG4gICAgICAgIGxhc3RSdW5uZXIgPSBuZXdSdW5uZXI7XG4gICAgICAgIC0taTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RSdW5uZXIgPSBydW5uZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZW1vdmUoaWQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuaWRzLmluZGV4T2YoaWQgKyAxKTtcbiAgICB0aGlzLmlkcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHRoaXMucnVubmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn1cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIEVsZW1lbnQ6IHtcbiAgICBhbmltYXRlKGR1cmF0aW9uLCBkZWxheSwgd2hlbikge1xuICAgICAgY29uc3QgbyA9IFJ1bm5lci5zYW5pdGlzZShkdXJhdGlvbiwgZGVsYXksIHdoZW4pO1xuICAgICAgY29uc3QgdGltZWxpbmUgPSB0aGlzLnRpbWVsaW5lKCk7XG4gICAgICByZXR1cm4gbmV3IFJ1bm5lcihvLmR1cmF0aW9uKS5sb29wKG8pLmVsZW1lbnQodGhpcykudGltZWxpbmUodGltZWxpbmUucGxheSgpKS5zY2hlZHVsZShvLmRlbGF5LCBvLndoZW4pO1xuICAgIH0sXG5cbiAgICBkZWxheShieSwgd2hlbikge1xuICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSgwLCBieSwgd2hlbik7XG4gICAgfSxcblxuICAgIC8vIHRoaXMgZnVuY3Rpb24gc2VhcmNoZXMgZm9yIGFsbCBydW5uZXJzIG9uIHRoZSBlbGVtZW50IGFuZCBkZWxldGVzIHRoZSBvbmVzXG4gICAgLy8gd2hpY2ggcnVuIGJlZm9yZSB0aGUgY3VycmVudCBvbmUuIFRoaXMgaXMgYmVjYXVzZSBhYnNvbHV0ZSB0cmFuc2Zvcm1hdGlvbnNcbiAgICAvLyBvdmVyd3JpdGUgYW55dGhpbmcgYW55d2F5IHNvIHRoZXJlIGlzIG5vIG5lZWQgdG8gd2FzdGUgdGltZSBjb21wdXRpbmdcbiAgICAvLyBvdGhlciBydW5uZXJzXG4gICAgX2NsZWFyVHJhbnNmb3JtUnVubmVyc0JlZm9yZShjdXJyZW50UnVubmVyKSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1hdGlvblJ1bm5lcnMuY2xlYXJCZWZvcmUoY3VycmVudFJ1bm5lci5pZCk7XG4gICAgfSxcblxuICAgIF9jdXJyZW50VHJhbnNmb3JtKGN1cnJlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1hdGlvblJ1bm5lcnMucnVubmVycyAvLyB3ZSBuZWVkIHRoZSBlcXVhbCBzaWduIGhlcmUgdG8gbWFrZSBzdXJlLCB0aGF0IGFsc28gdHJhbnNmb3JtYXRpb25zXG4gICAgICAvLyBvbiB0aGUgc2FtZSBydW5uZXIgd2hpY2ggZXhlY3V0ZSBiZWZvcmUgdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gYXJlXG4gICAgICAvLyB0YWtlbiBpbnRvIGFjY291bnRcbiAgICAgIC5maWx0ZXIocnVubmVyID0+IHJ1bm5lci5pZCA8PSBjdXJyZW50LmlkKS5tYXAoZ2V0UnVubmVyVHJhbnNmb3JtKS5yZWR1Y2UobG11bHRpcGx5LCBuZXcgTWF0cml4KCkpO1xuICAgIH0sXG5cbiAgICBfYWRkUnVubmVyKHJ1bm5lcikge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtYXRpb25SdW5uZXJzLmFkZChydW5uZXIpOyAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcnVubmVyIG1lcmdlIGlzIGV4ZWN1dGVkIGF0IHRoZSB2ZXJ5IGVuZCBvZlxuICAgICAgLy8gYWxsIEFuaW1hdG9yIGZ1bmN0aW9ucy4gVGhhdCBpcyB3aHkgd2UgdXNlIGltbWVkaWF0ZSBoZXJlIHRvIGV4ZWN1dGVcbiAgICAgIC8vIHRoZSBtZXJnZSByaWdodCBhZnRlciBhbGwgZnJhbWVzIGFyZSBydW5cblxuXG4gICAgICBBbmltYXRvci5jYW5jZWxJbW1lZGlhdGUodGhpcy5fZnJhbWVJZCk7XG4gICAgICB0aGlzLl9mcmFtZUlkID0gQW5pbWF0b3IuaW1tZWRpYXRlKG1lcmdlVHJhbnNmb3Jtcy5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgX3ByZXBhcmVSdW5uZXIoKSB7XG4gICAgICBpZiAodGhpcy5fZnJhbWVJZCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWF0aW9uUnVubmVycyA9IG5ldyBSdW5uZXJBcnJheSgpLmFkZChuZXcgRmFrZVJ1bm5lcihuZXcgTWF0cml4KHRoaXMpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cbn0pOyAvLyBXaWxsIG91dHB1dCB0aGUgZWxlbWVudHMgZnJvbSBhcnJheSBBIHRoYXQgYXJlIG5vdCBpbiB0aGUgYXJyYXkgQlxuXG5jb25zdCBkaWZmZXJlbmNlID0gKGEsIGIpID0+IGEuZmlsdGVyKHggPT4gIWIuaW5jbHVkZXMoeCkpO1xuXG5leHRlbmQoUnVubmVyLCB7XG4gIGF0dHIoYSwgdikge1xuICAgIHJldHVybiB0aGlzLnN0eWxlQXR0cignYXR0cicsIGEsIHYpO1xuICB9LFxuXG4gIC8vIEFkZCBhbmltYXRhYmxlIHN0eWxlc1xuICBjc3Mocywgdikge1xuICAgIHJldHVybiB0aGlzLnN0eWxlQXR0cignY3NzJywgcywgdik7XG4gIH0sXG5cbiAgc3R5bGVBdHRyKHR5cGUsIG5hbWVPckF0dHJzLCB2YWwpIHtcbiAgICBpZiAodHlwZW9mIG5hbWVPckF0dHJzID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMuc3R5bGVBdHRyKHR5cGUsIHtcbiAgICAgICAgW25hbWVPckF0dHJzXTogdmFsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgYXR0cnMgPSBuYW1lT3JBdHRycztcbiAgICBpZiAodGhpcy5fdHJ5UmV0YXJnZXQodHlwZSwgYXR0cnMpKSByZXR1cm4gdGhpcztcbiAgICBsZXQgbW9ycGhlciA9IG5ldyBNb3JwaGFibGUodGhpcy5fc3RlcHBlcikudG8oYXR0cnMpO1xuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMoYXR0cnMpO1xuICAgIHRoaXMucXVldWUoZnVuY3Rpb24gKCkge1xuICAgICAgbW9ycGhlciA9IG1vcnBoZXIuZnJvbSh0aGlzLmVsZW1lbnQoKVt0eXBlXShrZXlzKSk7XG4gICAgfSwgZnVuY3Rpb24gKHBvcykge1xuICAgICAgdGhpcy5lbGVtZW50KClbdHlwZV0obW9ycGhlci5hdChwb3MpLnZhbHVlT2YoKSk7XG4gICAgICByZXR1cm4gbW9ycGhlci5kb25lKCk7XG4gICAgfSwgZnVuY3Rpb24gKG5ld1RvQXR0cnMpIHtcbiAgICAgIC8vIENoZWNrIGlmIGFueSBuZXcga2V5cyB3ZXJlIGFkZGVkXG4gICAgICBjb25zdCBuZXdLZXlzID0gT2JqZWN0LmtleXMobmV3VG9BdHRycyk7XG4gICAgICBjb25zdCBkaWZmZXJlbmNlcyA9IGRpZmZlcmVuY2UobmV3S2V5cywga2V5cyk7IC8vIElmIHRoZWlyIGFyZSBuZXcga2V5cywgaW5pdGlhbGl6ZSB0aGVtIGFuZCBhZGQgdGhlbSB0byBtb3JwaGVyXG5cbiAgICAgIGlmIChkaWZmZXJlbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gR2V0IHRoZSB2YWx1ZXNcbiAgICAgICAgY29uc3QgYWRkZWRGcm9tQXR0cnMgPSB0aGlzLmVsZW1lbnQoKVt0eXBlXShkaWZmZXJlbmNlcyk7IC8vIEdldCB0aGUgYWxyZWFkeSBpbml0aWFsaXplZCB2YWx1ZXNcblxuICAgICAgICBjb25zdCBvbGRGcm9tQXR0cnMgPSBuZXcgT2JqZWN0QmFnKG1vcnBoZXIuZnJvbSgpKS52YWx1ZU9mKCk7IC8vIE1lcmdlIG9sZCBhbmQgbmV3XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihvbGRGcm9tQXR0cnMsIGFkZGVkRnJvbUF0dHJzKTtcbiAgICAgICAgbW9ycGhlci5mcm9tKG9sZEZyb21BdHRycyk7XG4gICAgICB9IC8vIEdldCB0aGUgb2JqZWN0IGZyb20gdGhlIG1vcnBoZXJcblxuXG4gICAgICBjb25zdCBvbGRUb0F0dHJzID0gbmV3IE9iamVjdEJhZyhtb3JwaGVyLnRvKCkpLnZhbHVlT2YoKTsgLy8gTWVyZ2UgaW4gbmV3IGF0dHJpYnV0ZXNcblxuICAgICAgT2JqZWN0LmFzc2lnbihvbGRUb0F0dHJzLCBuZXdUb0F0dHJzKTsgLy8gQ2hhbmdlIG1vcnBoZXIgdGFyZ2V0XG5cbiAgICAgIG1vcnBoZXIudG8ob2xkVG9BdHRycyk7IC8vIE1ha2Ugc3VyZSB0aGF0IHdlIHNhdmUgdGhlIHdvcmsgd2UgZGlkIHNvIHdlIGRvbid0IG5lZWQgaXQgdG8gZG8gYWdhaW5cblxuICAgICAga2V5cyA9IG5ld0tleXM7XG4gICAgICBhdHRycyA9IG5ld1RvQXR0cnM7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9yZW1lbWJlck1vcnBoZXIodHlwZSwgbW9ycGhlcik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICB6b29tKGxldmVsLCBwb2ludCkge1xuICAgIGlmICh0aGlzLl90cnlSZXRhcmdldCgnem9vbScsIGxldmVsLCBwb2ludCkpIHJldHVybiB0aGlzO1xuICAgIGxldCBtb3JwaGVyID0gbmV3IE1vcnBoYWJsZSh0aGlzLl9zdGVwcGVyKS50byhuZXcgU1ZHTnVtYmVyKGxldmVsKSk7XG4gICAgdGhpcy5xdWV1ZShmdW5jdGlvbiAoKSB7XG4gICAgICBtb3JwaGVyID0gbW9ycGhlci5mcm9tKHRoaXMuZWxlbWVudCgpLnpvb20oKSk7XG4gICAgfSwgZnVuY3Rpb24gKHBvcykge1xuICAgICAgdGhpcy5lbGVtZW50KCkuem9vbShtb3JwaGVyLmF0KHBvcyksIHBvaW50KTtcbiAgICAgIHJldHVybiBtb3JwaGVyLmRvbmUoKTtcbiAgICB9LCBmdW5jdGlvbiAobmV3TGV2ZWwsIG5ld1BvaW50KSB7XG4gICAgICBwb2ludCA9IG5ld1BvaW50O1xuICAgICAgbW9ycGhlci50byhuZXdMZXZlbCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9yZW1lbWJlck1vcnBoZXIoJ3pvb20nLCBtb3JwaGVyKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiogYWJzb2x1dGUgdHJhbnNmb3JtYXRpb25zXG4gICAqKi9cbiAgLy9cbiAgLy8gTSB2IC0tLS0tfC0tLS0tKEQgTSB2ID0gRiB2KS0tLS0tLXwtLS0tLT4gIFQgdlxuICAvL1xuICAvLyAxLiBkZWZpbmUgdGhlIGZpbmFsIHN0YXRlIChUKSBhbmQgZGVjb21wb3NlIGl0IChvbmNlKVxuICAvLyAgICB0ID0gW3R4LCB0eSwgdGhlLCBsYW0sIHN5LCBzeF1cbiAgLy8gMi4gb24gZXZlcnkgZnJhbWU6IHB1bGwgdGhlIGN1cnJlbnQgc3RhdGUgb2YgYWxsIHByZXZpb3VzIHRyYW5zZm9ybXNcbiAgLy8gICAgKE0gLSBtIGNhbiBjaGFuZ2UpXG4gIC8vICAgYW5kIHRoZW4gd3JpdGUgdGhpcyBhcyBtID0gW3R4MCwgdHkwLCB0aGUwLCBsYW0wLCBzeTAsIHN4MF1cbiAgLy8gMy4gRmluZCB0aGUgaW50ZXJwb2xhdGVkIG1hdHJpeCBGKHBvcykgPSBtICsgcG9zICogKHQgLSBtKVxuICAvLyAgIC0gTm90ZSBGKDApID0gTVxuICAvLyAgIC0gTm90ZSBGKDEpID0gVFxuICAvLyA0LiBOb3cgeW91IGdldCB0aGUgZGVsdGEgbWF0cml4IGFzIGEgcmVzdWx0OiBEID0gRiAqIGludihNKVxuICB0cmFuc2Zvcm0odHJhbnNmb3JtcywgcmVsYXRpdmUsIGFmZmluZSkge1xuICAgIC8vIElmIHdlIGhhdmUgYSBkZWNsYXJhdGl2ZSBmdW5jdGlvbiwgd2Ugc2hvdWxkIHJldGFyZ2V0IGl0IGlmIHBvc3NpYmxlXG4gICAgcmVsYXRpdmUgPSB0cmFuc2Zvcm1zLnJlbGF0aXZlIHx8IHJlbGF0aXZlO1xuXG4gICAgaWYgKHRoaXMuX2lzRGVjbGFyYXRpdmUgJiYgIXJlbGF0aXZlICYmIHRoaXMuX3RyeVJldGFyZ2V0KCd0cmFuc2Zvcm0nLCB0cmFuc2Zvcm1zKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSAvLyBQYXJzZSB0aGUgcGFyYW1ldGVyc1xuXG5cbiAgICBjb25zdCBpc01hdHJpeCA9IE1hdHJpeC5pc01hdHJpeExpa2UodHJhbnNmb3Jtcyk7XG4gICAgYWZmaW5lID0gdHJhbnNmb3Jtcy5hZmZpbmUgIT0gbnVsbCA/IHRyYW5zZm9ybXMuYWZmaW5lIDogYWZmaW5lICE9IG51bGwgPyBhZmZpbmUgOiAhaXNNYXRyaXg7IC8vIENyZWF0ZSBhIG1vcnBoZXIgYW5kIHNldCBpdHMgdHlwZVxuXG4gICAgY29uc3QgbW9ycGhlciA9IG5ldyBNb3JwaGFibGUodGhpcy5fc3RlcHBlcikudHlwZShhZmZpbmUgPyBUcmFuc2Zvcm1CYWcgOiBNYXRyaXgpO1xuICAgIGxldCBvcmlnaW47XG4gICAgbGV0IGVsZW1lbnQ7XG4gICAgbGV0IGN1cnJlbnQ7XG4gICAgbGV0IGN1cnJlbnRBbmdsZTtcbiAgICBsZXQgc3RhcnRUcmFuc2Zvcm07XG5cbiAgICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBlbGVtZW50IGFuZCBvcmlnaW4gaXMgZGVmaW5lZFxuICAgICAgZWxlbWVudCA9IGVsZW1lbnQgfHwgdGhpcy5lbGVtZW50KCk7XG4gICAgICBvcmlnaW4gPSBvcmlnaW4gfHwgZ2V0T3JpZ2luKHRyYW5zZm9ybXMsIGVsZW1lbnQpO1xuICAgICAgc3RhcnRUcmFuc2Zvcm0gPSBuZXcgTWF0cml4KHJlbGF0aXZlID8gdW5kZWZpbmVkIDogZWxlbWVudCk7IC8vIGFkZCB0aGUgcnVubmVyIHRvIHRoZSBlbGVtZW50IHNvIGl0IGNhbiBtZXJnZSB0cmFuc2Zvcm1hdGlvbnNcblxuICAgICAgZWxlbWVudC5fYWRkUnVubmVyKHRoaXMpOyAvLyBEZWFjdGl2YXRlIGFsbCB0cmFuc2Zvcm1zIHRoYXQgaGF2ZSBydW4gc28gZmFyIGlmIHdlIGFyZSBhYnNvbHV0ZVxuXG5cbiAgICAgIGlmICghcmVsYXRpdmUpIHtcbiAgICAgICAgZWxlbWVudC5fY2xlYXJUcmFuc2Zvcm1SdW5uZXJzQmVmb3JlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bihwb3MpIHtcbiAgICAgIC8vIGNsZWFyIGFsbCBvdGhlciB0cmFuc2Zvcm1zIGJlZm9yZSB0aGlzIGluIGNhc2Ugc29tZXRoaW5nIGlzIHNhdmVkXG4gICAgICAvLyBvbiB0aGlzIHJ1bm5lci4gV2UgYXJlIGFic29sdXRlLiBXZSBkb250IG5lZWQgdGhlc2UhXG4gICAgICBpZiAoIXJlbGF0aXZlKSB0aGlzLmNsZWFyVHJhbnNmb3JtKCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBuZXcgUG9pbnQob3JpZ2luKS50cmFuc2Zvcm0oZWxlbWVudC5fY3VycmVudFRyYW5zZm9ybSh0aGlzKSk7XG4gICAgICBsZXQgdGFyZ2V0ID0gbmV3IE1hdHJpeCh7IC4uLnRyYW5zZm9ybXMsXG4gICAgICAgIG9yaWdpbjogW3gsIHldXG4gICAgICB9KTtcbiAgICAgIGxldCBzdGFydCA9IHRoaXMuX2lzRGVjbGFyYXRpdmUgJiYgY3VycmVudCA/IGN1cnJlbnQgOiBzdGFydFRyYW5zZm9ybTtcblxuICAgICAgaWYgKGFmZmluZSkge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQuZGVjb21wb3NlKHgsIHkpO1xuICAgICAgICBzdGFydCA9IHN0YXJ0LmRlY29tcG9zZSh4LCB5KTsgLy8gR2V0IHRoZSBjdXJyZW50IGFuZCB0YXJnZXQgYW5nbGUgYXMgaXQgd2FzIHNldFxuXG4gICAgICAgIGNvbnN0IHJUYXJnZXQgPSB0YXJnZXQucm90YXRlO1xuICAgICAgICBjb25zdCByQ3VycmVudCA9IHN0YXJ0LnJvdGF0ZTsgLy8gRmlndXJlIG91dCB0aGUgc2hvcnRlc3QgcGF0aCB0byByb3RhdGUgZGlyZWN0bHlcblxuICAgICAgICBjb25zdCBwb3NzaWJpbGl0aWVzID0gW3JUYXJnZXQgLSAzNjAsIHJUYXJnZXQsIHJUYXJnZXQgKyAzNjBdO1xuICAgICAgICBjb25zdCBkaXN0YW5jZXMgPSBwb3NzaWJpbGl0aWVzLm1hcChhID0+IE1hdGguYWJzKGEgLSByQ3VycmVudCkpO1xuICAgICAgICBjb25zdCBzaG9ydGVzdCA9IE1hdGgubWluKC4uLmRpc3RhbmNlcyk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZGlzdGFuY2VzLmluZGV4T2Yoc2hvcnRlc3QpO1xuICAgICAgICB0YXJnZXQucm90YXRlID0gcG9zc2liaWxpdGllc1tpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICAvLyB3ZSBoYXZlIHRvIGJlIGNhcmVmdWwgaGVyZSBub3QgdG8gb3ZlcndyaXRlIHRoZSByb3RhdGlvblxuICAgICAgICAvLyB3aXRoIHRoZSByb3RhdGUgbWV0aG9kIG9mIE1hdHJpeFxuICAgICAgICBpZiAoIWlzTWF0cml4KSB7XG4gICAgICAgICAgdGFyZ2V0LnJvdGF0ZSA9IHRyYW5zZm9ybXMucm90YXRlIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faXNEZWNsYXJhdGl2ZSAmJiBjdXJyZW50QW5nbGUpIHtcbiAgICAgICAgICBzdGFydC5yb3RhdGUgPSBjdXJyZW50QW5nbGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbW9ycGhlci5mcm9tKHN0YXJ0KTtcbiAgICAgIG1vcnBoZXIudG8odGFyZ2V0KTtcbiAgICAgIGNvbnN0IGFmZmluZVBhcmFtZXRlcnMgPSBtb3JwaGVyLmF0KHBvcyk7XG4gICAgICBjdXJyZW50QW5nbGUgPSBhZmZpbmVQYXJhbWV0ZXJzLnJvdGF0ZTtcbiAgICAgIGN1cnJlbnQgPSBuZXcgTWF0cml4KGFmZmluZVBhcmFtZXRlcnMpO1xuICAgICAgdGhpcy5hZGRUcmFuc2Zvcm0oY3VycmVudCk7XG5cbiAgICAgIGVsZW1lbnQuX2FkZFJ1bm5lcih0aGlzKTtcblxuICAgICAgcmV0dXJuIG1vcnBoZXIuZG9uZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJldGFyZ2V0KG5ld1RyYW5zZm9ybXMpIHtcbiAgICAgIC8vIG9ubHkgZ2V0IGEgbmV3IG9yaWdpbiBpZiBpdCBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGNhbGxcbiAgICAgIGlmICgobmV3VHJhbnNmb3Jtcy5vcmlnaW4gfHwgJ2NlbnRlcicpLnRvU3RyaW5nKCkgIT09ICh0cmFuc2Zvcm1zLm9yaWdpbiB8fCAnY2VudGVyJykudG9TdHJpbmcoKSkge1xuICAgICAgICBvcmlnaW4gPSBnZXRPcmlnaW4obmV3VHJhbnNmb3JtcywgZWxlbWVudCk7XG4gICAgICB9IC8vIG92ZXJ3cml0ZSB0aGUgb2xkIHRyYW5zZm9ybWF0aW9ucyB3aXRoIHRoZSBuZXcgb25lc1xuXG5cbiAgICAgIHRyYW5zZm9ybXMgPSB7IC4uLm5ld1RyYW5zZm9ybXMsXG4gICAgICAgIG9yaWdpblxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLnF1ZXVlKHNldHVwLCBydW4sIHJldGFyZ2V0LCB0cnVlKTtcbiAgICB0aGlzLl9pc0RlY2xhcmF0aXZlICYmIHRoaXMuX3JlbWVtYmVyTW9ycGhlcigndHJhbnNmb3JtJywgbW9ycGhlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gQW5pbWF0YWJsZSB4LWF4aXNcbiAgeCh4LCByZWxhdGl2ZSkge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlcigneCcsIHgpO1xuICB9LFxuXG4gIC8vIEFuaW1hdGFibGUgeS1heGlzXG4gIHkoeSkge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlcigneScsIHkpO1xuICB9LFxuXG4gIGR4KHggPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlTnVtYmVyRGVsdGEoJ3gnLCB4KTtcbiAgfSxcblxuICBkeSh5ID0gMCkge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlckRlbHRhKCd5JywgeSk7XG4gIH0sXG5cbiAgZG1vdmUoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmR4KHgpLmR5KHkpO1xuICB9LFxuXG4gIF9xdWV1ZU51bWJlckRlbHRhKG1ldGhvZCwgdG8pIHtcbiAgICB0byA9IG5ldyBTVkdOdW1iZXIodG8pOyAvLyBUcnkgdG8gY2hhbmdlIHRoZSB0YXJnZXQgaWYgd2UgaGF2ZSB0aGlzIG1ldGhvZCBhbHJlYWR5IHJlZ2lzdGVyZWRcblxuICAgIGlmICh0aGlzLl90cnlSZXRhcmdldChtZXRob2QsIHRvKSkgcmV0dXJuIHRoaXM7IC8vIE1ha2UgYSBtb3JwaGVyIGFuZCBxdWV1ZSB0aGUgYW5pbWF0aW9uXG5cbiAgICBjb25zdCBtb3JwaGVyID0gbmV3IE1vcnBoYWJsZSh0aGlzLl9zdGVwcGVyKS50byh0byk7XG4gICAgbGV0IGZyb20gPSBudWxsO1xuICAgIHRoaXMucXVldWUoZnVuY3Rpb24gKCkge1xuICAgICAgZnJvbSA9IHRoaXMuZWxlbWVudCgpW21ldGhvZF0oKTtcbiAgICAgIG1vcnBoZXIuZnJvbShmcm9tKTtcbiAgICAgIG1vcnBoZXIudG8oZnJvbSArIHRvKTtcbiAgICB9LCBmdW5jdGlvbiAocG9zKSB7XG4gICAgICB0aGlzLmVsZW1lbnQoKVttZXRob2RdKG1vcnBoZXIuYXQocG9zKSk7XG4gICAgICByZXR1cm4gbW9ycGhlci5kb25lKCk7XG4gICAgfSwgZnVuY3Rpb24gKG5ld1RvKSB7XG4gICAgICBtb3JwaGVyLnRvKGZyb20gKyBuZXcgU1ZHTnVtYmVyKG5ld1RvKSk7XG4gICAgfSk7IC8vIFJlZ2lzdGVyIHRoZSBtb3JwaGVyIHNvIHRoYXQgaWYgaXQgaXMgY2hhbmdlZCBhZ2Fpbiwgd2UgY2FuIHJldGFyZ2V0IGl0XG5cbiAgICB0aGlzLl9yZW1lbWJlck1vcnBoZXIobWV0aG9kLCBtb3JwaGVyKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9xdWV1ZU9iamVjdChtZXRob2QsIHRvKSB7XG4gICAgLy8gVHJ5IHRvIGNoYW5nZSB0aGUgdGFyZ2V0IGlmIHdlIGhhdmUgdGhpcyBtZXRob2QgYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgaWYgKHRoaXMuX3RyeVJldGFyZ2V0KG1ldGhvZCwgdG8pKSByZXR1cm4gdGhpczsgLy8gTWFrZSBhIG1vcnBoZXIgYW5kIHF1ZXVlIHRoZSBhbmltYXRpb25cblxuICAgIGNvbnN0IG1vcnBoZXIgPSBuZXcgTW9ycGhhYmxlKHRoaXMuX3N0ZXBwZXIpLnRvKHRvKTtcbiAgICB0aGlzLnF1ZXVlKGZ1bmN0aW9uICgpIHtcbiAgICAgIG1vcnBoZXIuZnJvbSh0aGlzLmVsZW1lbnQoKVttZXRob2RdKCkpO1xuICAgIH0sIGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIHRoaXMuZWxlbWVudCgpW21ldGhvZF0obW9ycGhlci5hdChwb3MpKTtcbiAgICAgIHJldHVybiBtb3JwaGVyLmRvbmUoKTtcbiAgICB9KTsgLy8gUmVnaXN0ZXIgdGhlIG1vcnBoZXIgc28gdGhhdCBpZiBpdCBpcyBjaGFuZ2VkIGFnYWluLCB3ZSBjYW4gcmV0YXJnZXQgaXRcblxuICAgIHRoaXMuX3JlbWVtYmVyTW9ycGhlcihtZXRob2QsIG1vcnBoZXIpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX3F1ZXVlTnVtYmVyKG1ldGhvZCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVldWVPYmplY3QobWV0aG9kLCBuZXcgU1ZHTnVtYmVyKHZhbHVlKSk7XG4gIH0sXG5cbiAgLy8gQW5pbWF0YWJsZSBjZW50ZXIgeC1heGlzXG4gIGN4KHgpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVldWVOdW1iZXIoJ2N4JywgeCk7XG4gIH0sXG5cbiAgLy8gQW5pbWF0YWJsZSBjZW50ZXIgeS1heGlzXG4gIGN5KHkpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVldWVOdW1iZXIoJ2N5JywgeSk7XG4gIH0sXG5cbiAgLy8gQWRkIGFuaW1hdGFibGUgbW92ZVxuICBtb3ZlKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy54KHgpLnkoeSk7XG4gIH0sXG5cbiAgLy8gQWRkIGFuaW1hdGFibGUgY2VudGVyXG4gIGNlbnRlcih4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuY3goeCkuY3koeSk7XG4gIH0sXG5cbiAgLy8gQWRkIGFuaW1hdGFibGUgc2l6ZVxuICBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAvLyBhbmltYXRlIGJib3ggYmFzZWQgc2l6ZSBmb3IgYWxsIG90aGVyIGVsZW1lbnRzXG4gICAgbGV0IGJveDtcblxuICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgYm94ID0gdGhpcy5fZWxlbWVudC5iYm94KCk7XG4gICAgfVxuXG4gICAgaWYgKCF3aWR0aCkge1xuICAgICAgd2lkdGggPSBib3gud2lkdGggLyBib3guaGVpZ2h0ICogaGVpZ2h0O1xuICAgIH1cblxuICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgPSBib3guaGVpZ2h0IC8gYm94LndpZHRoICogd2lkdGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMud2lkdGgod2lkdGgpLmhlaWdodChoZWlnaHQpO1xuICB9LFxuXG4gIC8vIEFkZCBhbmltYXRhYmxlIHdpZHRoXG4gIHdpZHRoKHdpZHRoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlTnVtYmVyKCd3aWR0aCcsIHdpZHRoKTtcbiAgfSxcblxuICAvLyBBZGQgYW5pbWF0YWJsZSBoZWlnaHRcbiAgaGVpZ2h0KGhlaWdodCkge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlcignaGVpZ2h0JywgaGVpZ2h0KTtcbiAgfSxcblxuICAvLyBBZGQgYW5pbWF0YWJsZSBwbG90XG4gIHBsb3QoYSwgYiwgYywgZCkge1xuICAgIC8vIExpbmVzIGNhbiBiZSBwbG90dGVkIHdpdGggNCBhcmd1bWVudHNcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgcmV0dXJuIHRoaXMucGxvdChbYSwgYiwgYywgZF0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl90cnlSZXRhcmdldCgncGxvdCcsIGEpKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBtb3JwaGVyID0gbmV3IE1vcnBoYWJsZSh0aGlzLl9zdGVwcGVyKS50eXBlKHRoaXMuX2VsZW1lbnQuTW9ycGhBcnJheSkudG8oYSk7XG4gICAgdGhpcy5xdWV1ZShmdW5jdGlvbiAoKSB7XG4gICAgICBtb3JwaGVyLmZyb20odGhpcy5fZWxlbWVudC5hcnJheSgpKTtcbiAgICB9LCBmdW5jdGlvbiAocG9zKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnBsb3QobW9ycGhlci5hdChwb3MpKTtcblxuICAgICAgcmV0dXJuIG1vcnBoZXIuZG9uZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fcmVtZW1iZXJNb3JwaGVyKCdwbG90JywgbW9ycGhlcik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyBBZGQgbGVhZGluZyBtZXRob2RcbiAgbGVhZGluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlcignbGVhZGluZycsIHZhbHVlKTtcbiAgfSxcblxuICAvLyBBZGQgYW5pbWF0YWJsZSB2aWV3Ym94XG4gIHZpZXdib3goeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZU9iamVjdCgndmlld2JveCcsIG5ldyBCb3goeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuICB9LFxuXG4gIHVwZGF0ZShvKSB7XG4gICAgaWYgKHR5cGVvZiBvICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKHtcbiAgICAgICAgb2Zmc2V0OiBhcmd1bWVudHNbMF0sXG4gICAgICAgIGNvbG9yOiBhcmd1bWVudHNbMV0sXG4gICAgICAgIG9wYWNpdHk6IGFyZ3VtZW50c1syXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG8ub3BhY2l0eSAhPSBudWxsKSB0aGlzLmF0dHIoJ3N0b3Atb3BhY2l0eScsIG8ub3BhY2l0eSk7XG4gICAgaWYgKG8uY29sb3IgIT0gbnVsbCkgdGhpcy5hdHRyKCdzdG9wLWNvbG9yJywgby5jb2xvcik7XG4gICAgaWYgKG8ub2Zmc2V0ICE9IG51bGwpIHRoaXMuYXR0cignb2Zmc2V0Jywgby5vZmZzZXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn0pO1xuZXh0ZW5kKFJ1bm5lciwge1xuICByeCxcbiAgcnksXG4gIGZyb20sXG4gIHRvXG59KTtcbnJlZ2lzdGVyKFJ1bm5lciwgJ1J1bm5lcicpO1xuXG5jbGFzcyBTdmcgZXh0ZW5kcyBDb250YWluZXIge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ3N2ZycsIG5vZGUpLCBhdHRycyk7XG4gICAgdGhpcy5uYW1lc3BhY2UoKTtcbiAgfSAvLyBDcmVhdGVzIGFuZCByZXR1cm5zIGRlZnMgZWxlbWVudFxuXG5cbiAgZGVmcygpIHtcbiAgICBpZiAoIXRoaXMuaXNSb290KCkpIHJldHVybiB0aGlzLnJvb3QoKS5kZWZzKCk7XG4gICAgcmV0dXJuIGFkb3B0KHRoaXMubm9kZS5xdWVyeVNlbGVjdG9yKCdkZWZzJykpIHx8IHRoaXMucHV0KG5ldyBEZWZzKCkpO1xuICB9XG5cbiAgaXNSb290KCkge1xuICAgIHJldHVybiAhdGhpcy5ub2RlLnBhcmVudE5vZGUgfHwgISh0aGlzLm5vZGUucGFyZW50Tm9kZSBpbnN0YW5jZW9mIGdsb2JhbHMud2luZG93LlNWR0VsZW1lbnQpICYmIHRoaXMubm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lICE9PSAnI2RvY3VtZW50LWZyYWdtZW50JztcbiAgfSAvLyBBZGQgbmFtZXNwYWNlc1xuXG5cbiAgbmFtZXNwYWNlKCkge1xuICAgIGlmICghdGhpcy5pc1Jvb3QoKSkgcmV0dXJuIHRoaXMucm9vdCgpLm5hbWVzcGFjZSgpO1xuICAgIHJldHVybiB0aGlzLmF0dHIoe1xuICAgICAgeG1sbnM6IHN2ZyxcbiAgICAgIHZlcnNpb246ICcxLjEnXG4gICAgfSkuYXR0cigneG1sbnM6eGxpbmsnLCB4bGluaywgeG1sbnMpLmF0dHIoJ3htbG5zOnN2Z2pzJywgc3ZnanMsIHhtbG5zKTtcbiAgfVxuXG4gIHJlbW92ZU5hbWVzcGFjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKHtcbiAgICAgIHhtbG5zOiBudWxsLFxuICAgICAgdmVyc2lvbjogbnVsbFxuICAgIH0pLmF0dHIoJ3htbG5zOnhsaW5rJywgbnVsbCwgeG1sbnMpLmF0dHIoJ3htbG5zOnN2Z2pzJywgbnVsbCwgeG1sbnMpO1xuICB9IC8vIENoZWNrIGlmIHRoaXMgaXMgYSByb290IHN2Z1xuICAvLyBJZiBub3QsIGNhbGwgcm9vdCgpIGZyb20gdGhpcyBlbGVtZW50XG5cblxuICByb290KCkge1xuICAgIGlmICh0aGlzLmlzUm9vdCgpKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gc3VwZXIucm9vdCgpO1xuICB9XG5cbn1cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIENvbnRhaW5lcjoge1xuICAgIC8vIENyZWF0ZSBuZXN0ZWQgc3ZnIGRvY3VtZW50XG4gICAgbmVzdGVkOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFN2ZygpKTtcbiAgICB9KVxuICB9XG59KTtcbnJlZ2lzdGVyKFN2ZywgJ1N2ZycsIHRydWUpO1xuXG5jbGFzcyBTeW1ib2wgZXh0ZW5kcyBDb250YWluZXIge1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdzeW1ib2wnLCBub2RlKSwgYXR0cnMpO1xuICB9XG5cbn1cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIENvbnRhaW5lcjoge1xuICAgIHN5bWJvbDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTeW1ib2woKSk7XG4gICAgfSlcbiAgfVxufSk7XG5yZWdpc3RlcihTeW1ib2wsICdTeW1ib2wnKTtcblxuZnVuY3Rpb24gcGxhaW4odGV4dCkge1xuICAvLyBjbGVhciBpZiBidWlsZCBtb2RlIGlzIGRpc2FibGVkXG4gIGlmICh0aGlzLl9idWlsZCA9PT0gZmFsc2UpIHtcbiAgICB0aGlzLmNsZWFyKCk7XG4gIH0gLy8gY3JlYXRlIHRleHQgbm9kZVxuXG5cbiAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGdsb2JhbHMuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpO1xuICByZXR1cm4gdGhpcztcbn0gLy8gR2V0IGxlbmd0aCBvZiB0ZXh0IGVsZW1lbnRcblxuZnVuY3Rpb24gbGVuZ3RoKCkge1xuICByZXR1cm4gdGhpcy5ub2RlLmdldENvbXB1dGVkVGV4dExlbmd0aCgpO1xufSAvLyBNb3ZlIG92ZXIgeC1heGlzXG4vLyBUZXh0IGlzIG1vdmVkIGJ5IGl0cyBib3VuZGluZyBib3hcbi8vIHRleHQtYW5jaG9yIGRvZXMgTk9UIG1hdHRlclxuXG5mdW5jdGlvbiB4JDEoeCwgYm94ID0gdGhpcy5iYm94KCkpIHtcbiAgaWYgKHggPT0gbnVsbCkge1xuICAgIHJldHVybiBib3gueDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmF0dHIoJ3gnLCB0aGlzLmF0dHIoJ3gnKSArIHggLSBib3gueCk7XG59IC8vIE1vdmUgb3ZlciB5LWF4aXNcblxuZnVuY3Rpb24geSQxKHksIGJveCA9IHRoaXMuYmJveCgpKSB7XG4gIGlmICh5ID09IG51bGwpIHtcbiAgICByZXR1cm4gYm94Lnk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5hdHRyKCd5JywgdGhpcy5hdHRyKCd5JykgKyB5IC0gYm94LnkpO1xufVxuZnVuY3Rpb24gbW92ZSQxKHgsIHksIGJveCA9IHRoaXMuYmJveCgpKSB7XG4gIHJldHVybiB0aGlzLngoeCwgYm94KS55KHksIGJveCk7XG59IC8vIE1vdmUgY2VudGVyIG92ZXIgeC1heGlzXG5cbmZ1bmN0aW9uIGN4KHgsIGJveCA9IHRoaXMuYmJveCgpKSB7XG4gIGlmICh4ID09IG51bGwpIHtcbiAgICByZXR1cm4gYm94LmN4O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXR0cigneCcsIHRoaXMuYXR0cigneCcpICsgeCAtIGJveC5jeCk7XG59IC8vIE1vdmUgY2VudGVyIG92ZXIgeS1heGlzXG5cbmZ1bmN0aW9uIGN5KHksIGJveCA9IHRoaXMuYmJveCgpKSB7XG4gIGlmICh5ID09IG51bGwpIHtcbiAgICByZXR1cm4gYm94LmN5O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXR0cigneScsIHRoaXMuYXR0cigneScpICsgeSAtIGJveC5jeSk7XG59XG5mdW5jdGlvbiBjZW50ZXIoeCwgeSwgYm94ID0gdGhpcy5iYm94KCkpIHtcbiAgcmV0dXJuIHRoaXMuY3goeCwgYm94KS5jeSh5LCBib3gpO1xufVxuZnVuY3Rpb24gYXgoeCkge1xuICByZXR1cm4gdGhpcy5hdHRyKCd4JywgeCk7XG59XG5mdW5jdGlvbiBheSh5KSB7XG4gIHJldHVybiB0aGlzLmF0dHIoJ3knLCB5KTtcbn1cbmZ1bmN0aW9uIGFtb3ZlKHgsIHkpIHtcbiAgcmV0dXJuIHRoaXMuYXgoeCkuYXkoeSk7XG59IC8vIEVuYWJsZSAvIGRpc2FibGUgYnVpbGQgbW9kZVxuXG5mdW5jdGlvbiBidWlsZChidWlsZCkge1xuICB0aGlzLl9idWlsZCA9ICEhYnVpbGQ7XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgdGV4dGFibGUgPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgcGxhaW46IHBsYWluLFxuICBsZW5ndGg6IGxlbmd0aCxcbiAgeDogeCQxLFxuICB5OiB5JDEsXG4gIG1vdmU6IG1vdmUkMSxcbiAgY3g6IGN4LFxuICBjeTogY3ksXG4gIGNlbnRlcjogY2VudGVyLFxuICBheDogYXgsXG4gIGF5OiBheSxcbiAgYW1vdmU6IGFtb3ZlLFxuICBidWlsZDogYnVpbGRcbn07XG5cbmNsYXNzIFRleHQgZXh0ZW5kcyBTaGFwZSB7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ3RleHQnLCBub2RlKSwgYXR0cnMpO1xuICAgIHRoaXMuZG9tLmxlYWRpbmcgPSBuZXcgU1ZHTnVtYmVyKDEuMyk7IC8vIHN0b3JlIGxlYWRpbmcgdmFsdWUgZm9yIHJlYnVpbGRpbmdcblxuICAgIHRoaXMuX3JlYnVpbGQgPSB0cnVlOyAvLyBlbmFibGUgYXV0b21hdGljIHVwZGF0aW5nIG9mIGR5IHZhbHVlc1xuXG4gICAgdGhpcy5fYnVpbGQgPSBmYWxzZTsgLy8gZGlzYWJsZSBidWlsZCBtb2RlIGZvciBhZGRpbmcgbXVsdGlwbGUgbGluZXNcbiAgfSAvLyBTZXQgLyBnZXQgbGVhZGluZ1xuXG5cbiAgbGVhZGluZyh2YWx1ZSkge1xuICAgIC8vIGFjdCBhcyBnZXR0ZXJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuZG9tLmxlYWRpbmc7XG4gICAgfSAvLyBhY3QgYXMgc2V0dGVyXG5cblxuICAgIHRoaXMuZG9tLmxlYWRpbmcgPSBuZXcgU1ZHTnVtYmVyKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5yZWJ1aWxkKCk7XG4gIH0gLy8gUmVidWlsZCBhcHBlYXJhbmNlIHR5cGVcblxuXG4gIHJlYnVpbGQocmVidWlsZCkge1xuICAgIC8vIHN0b3JlIG5ldyByZWJ1aWxkIGZsYWcgaWYgZ2l2ZW5cbiAgICBpZiAodHlwZW9mIHJlYnVpbGQgPT09ICdib29sZWFuJykge1xuICAgICAgdGhpcy5fcmVidWlsZCA9IHJlYnVpbGQ7XG4gICAgfSAvLyBkZWZpbmUgcG9zaXRpb24gb2YgYWxsIGxpbmVzXG5cblxuICAgIGlmICh0aGlzLl9yZWJ1aWxkKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGxldCBibGFua0xpbmVPZmZzZXQgPSAwO1xuICAgICAgY29uc3QgbGVhZGluZyA9IHRoaXMuZG9tLmxlYWRpbmc7XG4gICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSBnbG9iYWxzLndpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMubm9kZSkuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udC1zaXplJyk7XG4gICAgICAgIGNvbnN0IGR5ID0gbGVhZGluZyAqIG5ldyBTVkdOdW1iZXIoZm9udFNpemUpO1xuXG4gICAgICAgIGlmICh0aGlzLmRvbS5uZXdMaW5lZCkge1xuICAgICAgICAgIHRoaXMuYXR0cigneCcsIHNlbGYuYXR0cigneCcpKTtcblxuICAgICAgICAgIGlmICh0aGlzLnRleHQoKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIGJsYW5rTGluZU9mZnNldCArPSBkeTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hdHRyKCdkeScsIGkgPyBkeSArIGJsYW5rTGluZU9mZnNldCA6IDApO1xuICAgICAgICAgICAgYmxhbmtMaW5lT2Zmc2V0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5maXJlKCdyZWJ1aWxkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gb3ZlcndyaXRlIG1ldGhvZCBmcm9tIHBhcmVudCB0byBzZXQgZGF0YSBwcm9wZXJseVxuXG5cbiAgc2V0RGF0YShvKSB7XG4gICAgdGhpcy5kb20gPSBvO1xuICAgIHRoaXMuZG9tLmxlYWRpbmcgPSBuZXcgU1ZHTnVtYmVyKG8ubGVhZGluZyB8fCAxLjMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIFNldCB0aGUgdGV4dCBjb250ZW50XG5cblxuICB0ZXh0KHRleHQpIHtcbiAgICAvLyBhY3QgYXMgZ2V0dGVyXG4gICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLm5vZGUuY2hpbGROb2RlcztcbiAgICAgIGxldCBmaXJzdExpbmUgPSAwO1xuICAgICAgdGV4dCA9ICcnO1xuXG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgLy8gc2tpcCB0ZXh0UGF0aHMgLSB0aGV5IGFyZSBubyBsaW5lc1xuICAgICAgICBpZiAoY2hpbGRyZW5baV0ubm9kZU5hbWUgPT09ICd0ZXh0UGF0aCcpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkgZmlyc3RMaW5lID0gMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBhZGQgbmV3bGluZSBpZiBpdHMgbm90IHRoZSBmaXJzdCBjaGlsZCBhbmQgbmV3TGluZWQgaXMgc2V0IHRvIHRydWVcblxuXG4gICAgICAgIGlmIChpICE9PSBmaXJzdExpbmUgJiYgY2hpbGRyZW5baV0ubm9kZVR5cGUgIT09IDMgJiYgYWRvcHQoY2hpbGRyZW5baV0pLmRvbS5uZXdMaW5lZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRleHQgKz0gJ1xcbic7XG4gICAgICAgIH0gLy8gYWRkIGNvbnRlbnQgb2YgdGhpcyBub2RlXG5cblxuICAgICAgICB0ZXh0ICs9IGNoaWxkcmVuW2ldLnRleHRDb250ZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9IC8vIHJlbW92ZSBleGlzdGluZyBjb250ZW50XG5cblxuICAgIHRoaXMuY2xlYXIoKS5idWlsZCh0cnVlKTtcblxuICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gY2FsbCBibG9ja1xuICAgICAgdGV4dC5jYWxsKHRoaXMsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdG9yZSB0ZXh0IGFuZCBtYWtlIHN1cmUgdGV4dCBpcyBub3QgYmxhbmtcbiAgICAgIHRleHQgPSAodGV4dCArICcnKS5zcGxpdCgnXFxuJyk7IC8vIGJ1aWxkIG5ldyBsaW5lc1xuXG4gICAgICBmb3IgKGxldCBqID0gMCwgamwgPSB0ZXh0Lmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgdGhpcy5uZXdMaW5lKHRleHRbal0pO1xuICAgICAgfVxuICAgIH0gLy8gZGlzYWJsZSBidWlsZCBtb2RlIGFuZCByZWJ1aWxkIGxpbmVzXG5cblxuICAgIHJldHVybiB0aGlzLmJ1aWxkKGZhbHNlKS5yZWJ1aWxkKCk7XG4gIH1cblxufVxuZXh0ZW5kKFRleHQsIHRleHRhYmxlKTtcbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIENvbnRhaW5lcjoge1xuICAgIC8vIENyZWF0ZSB0ZXh0IGVsZW1lbnRcbiAgICB0ZXh0OiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAodGV4dCA9ICcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFRleHQoKSkudGV4dCh0ZXh0KTtcbiAgICB9KSxcbiAgICAvLyBDcmVhdGUgcGxhaW4gdGV4dCBlbGVtZW50XG4gICAgcGxhaW46IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh0ZXh0ID0gJycpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgVGV4dCgpKS5wbGFpbih0ZXh0KTtcbiAgICB9KVxuICB9XG59KTtcbnJlZ2lzdGVyKFRleHQsICdUZXh0Jyk7XG5cbmNsYXNzIFRzcGFuIGV4dGVuZHMgU2hhcGUge1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCd0c3BhbicsIG5vZGUpLCBhdHRycyk7XG4gICAgdGhpcy5fYnVpbGQgPSBmYWxzZTsgLy8gZGlzYWJsZSBidWlsZCBtb2RlIGZvciBhZGRpbmcgbXVsdGlwbGUgbGluZXNcbiAgfSAvLyBTaG9ydGN1dCBkeFxuXG5cbiAgZHgoZHgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdkeCcsIGR4KTtcbiAgfSAvLyBTaG9ydGN1dCBkeVxuXG5cbiAgZHkoZHkpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdkeScsIGR5KTtcbiAgfSAvLyBDcmVhdGUgbmV3IGxpbmVcblxuXG4gIG5ld0xpbmUoKSB7XG4gICAgLy8gbWFyayBuZXcgbGluZVxuICAgIHRoaXMuZG9tLm5ld0xpbmVkID0gdHJ1ZTsgLy8gZmV0Y2ggcGFyZW50XG5cbiAgICBjb25zdCB0ZXh0ID0gdGhpcy5wYXJlbnQoKTsgLy8gZWFybHkgcmV0dXJuIGluIGNhc2Ugd2UgYXJlIG5vdCBpbiBhIHRleHQgZWxlbWVudFxuXG4gICAgaWYgKCEodGV4dCBpbnN0YW5jZW9mIFRleHQpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBpID0gdGV4dC5pbmRleCh0aGlzKTtcbiAgICBjb25zdCBmb250U2l6ZSA9IGdsb2JhbHMud2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5ub2RlKS5nZXRQcm9wZXJ0eVZhbHVlKCdmb250LXNpemUnKTtcbiAgICBjb25zdCBkeSA9IHRleHQuZG9tLmxlYWRpbmcgKiBuZXcgU1ZHTnVtYmVyKGZvbnRTaXplKTsgLy8gYXBwbHkgbmV3IHBvc2l0aW9uXG5cbiAgICByZXR1cm4gdGhpcy5keShpID8gZHkgOiAwKS5hdHRyKCd4JywgdGV4dC54KCkpO1xuICB9IC8vIFNldCB0ZXh0IGNvbnRlbnRcblxuXG4gIHRleHQodGV4dCkge1xuICAgIGlmICh0ZXh0ID09IG51bGwpIHJldHVybiB0aGlzLm5vZGUudGV4dENvbnRlbnQgKyAodGhpcy5kb20ubmV3TGluZWQgPyAnXFxuJyA6ICcnKTtcblxuICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5jbGVhcigpLmJ1aWxkKHRydWUpO1xuICAgICAgdGV4dC5jYWxsKHRoaXMsIHRoaXMpO1xuICAgICAgdGhpcy5idWlsZChmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxhaW4odGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufVxuZXh0ZW5kKFRzcGFuLCB0ZXh0YWJsZSk7XG5yZWdpc3Rlck1ldGhvZHMoe1xuICBUc3Bhbjoge1xuICAgIHRzcGFuOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAodGV4dCA9ICcnKSB7XG4gICAgICBjb25zdCB0c3BhbiA9IG5ldyBUc3BhbigpOyAvLyBjbGVhciBpZiBidWlsZCBtb2RlIGlzIGRpc2FibGVkXG5cbiAgICAgIGlmICghdGhpcy5fYnVpbGQpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgfSAvLyBhZGQgbmV3IHRzcGFuXG5cblxuICAgICAgcmV0dXJuIHRoaXMucHV0KHRzcGFuKS50ZXh0KHRleHQpO1xuICAgIH0pXG4gIH0sXG4gIFRleHQ6IHtcbiAgICBuZXdMaW5lOiBmdW5jdGlvbiAodGV4dCA9ICcnKSB7XG4gICAgICByZXR1cm4gdGhpcy50c3Bhbih0ZXh0KS5uZXdMaW5lKCk7XG4gICAgfVxuICB9XG59KTtcbnJlZ2lzdGVyKFRzcGFuLCAnVHNwYW4nKTtcblxuY2xhc3MgQ2lyY2xlIGV4dGVuZHMgU2hhcGUge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ2NpcmNsZScsIG5vZGUpLCBhdHRycyk7XG4gIH1cblxuICByYWRpdXMocikge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ3InLCByKTtcbiAgfSAvLyBSYWRpdXMgeCB2YWx1ZVxuXG5cbiAgcngocngpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdyJywgcngpO1xuICB9IC8vIEFsaWFzIHJhZGl1cyB4IHZhbHVlXG5cblxuICByeShyeSkge1xuICAgIHJldHVybiB0aGlzLnJ4KHJ5KTtcbiAgfVxuXG4gIHNpemUoc2l6ZSkge1xuICAgIHJldHVybiB0aGlzLnJhZGl1cyhuZXcgU1ZHTnVtYmVyKHNpemUpLmRpdmlkZSgyKSk7XG4gIH1cblxufVxuZXh0ZW5kKENpcmNsZSwge1xuICB4OiB4JDMsXG4gIHk6IHkkMyxcbiAgY3g6IGN4JDEsXG4gIGN5OiBjeSQxLFxuICB3aWR0aDogd2lkdGgkMixcbiAgaGVpZ2h0OiBoZWlnaHQkMlxufSk7XG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBDcmVhdGUgY2lyY2xlIGVsZW1lbnRcbiAgICBjaXJjbGU6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uIChzaXplID0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBDaXJjbGUoKSkuc2l6ZShzaXplKS5tb3ZlKDAsIDApO1xuICAgIH0pXG4gIH1cbn0pO1xucmVnaXN0ZXIoQ2lyY2xlLCAnQ2lyY2xlJyk7XG5cbmNsYXNzIENsaXBQYXRoIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdjbGlwUGF0aCcsIG5vZGUpLCBhdHRycyk7XG4gIH0gLy8gVW5jbGlwIGFsbCBjbGlwcGVkIGVsZW1lbnRzIGFuZCByZW1vdmUgaXRzZWxmXG5cblxuICByZW1vdmUoKSB7XG4gICAgLy8gdW5jbGlwIGFsbCB0YXJnZXRzXG4gICAgdGhpcy50YXJnZXRzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGVsLnVuY2xpcCgpO1xuICAgIH0pOyAvLyByZW1vdmUgY2xpcFBhdGggZnJvbSBwYXJlbnRcblxuICAgIHJldHVybiBzdXBlci5yZW1vdmUoKTtcbiAgfVxuXG4gIHRhcmdldHMoKSB7XG4gICAgcmV0dXJuIGJhc2VGaW5kKCdzdmcgW2NsaXAtcGF0aCo9JyArIHRoaXMuaWQoKSArICddJyk7XG4gIH1cblxufVxucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgLy8gQ3JlYXRlIGNsaXBwaW5nIGVsZW1lbnRcbiAgICBjbGlwOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWZzKCkucHV0KG5ldyBDbGlwUGF0aCgpKTtcbiAgICB9KVxuICB9LFxuICBFbGVtZW50OiB7XG4gICAgLy8gRGlzdHJpYnV0ZSBjbGlwUGF0aCB0byBzdmcgZWxlbWVudFxuICAgIGNsaXBwZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2UoJ2NsaXAtcGF0aCcpO1xuICAgIH0sXG5cbiAgICBjbGlwV2l0aChlbGVtZW50KSB7XG4gICAgICAvLyB1c2UgZ2l2ZW4gY2xpcCBvciBjcmVhdGUgYSBuZXcgb25lXG4gICAgICBjb25zdCBjbGlwcGVyID0gZWxlbWVudCBpbnN0YW5jZW9mIENsaXBQYXRoID8gZWxlbWVudCA6IHRoaXMucGFyZW50KCkuY2xpcCgpLmFkZChlbGVtZW50KTsgLy8gYXBwbHkgbWFza1xuXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdjbGlwLXBhdGgnLCAndXJsKCMnICsgY2xpcHBlci5pZCgpICsgJyknKTtcbiAgICB9LFxuXG4gICAgLy8gVW5jbGlwIGVsZW1lbnRcbiAgICB1bmNsaXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdjbGlwLXBhdGgnLCBudWxsKTtcbiAgICB9XG5cbiAgfVxufSk7XG5yZWdpc3RlcihDbGlwUGF0aCwgJ0NsaXBQYXRoJyk7XG5cbmNsYXNzIEZvcmVpZ25PYmplY3QgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdmb3JlaWduT2JqZWN0Jywgbm9kZSksIGF0dHJzKTtcbiAgfVxuXG59XG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICBmb3JlaWduT2JqZWN0OiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBGb3JlaWduT2JqZWN0KCkpLnNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfSlcbiAgfVxufSk7XG5yZWdpc3RlcihGb3JlaWduT2JqZWN0LCAnRm9yZWlnbk9iamVjdCcpO1xuXG5mdW5jdGlvbiBkbW92ZShkeCwgZHkpIHtcbiAgdGhpcy5jaGlsZHJlbigpLmZvckVhY2goKGNoaWxkLCBpKSA9PiB7XG4gICAgbGV0IGJib3g7IC8vIFdlIGhhdmUgdG8gd3JhcCB0aGlzIGZvciBlbGVtZW50cyB0aGF0IGRvbnQgaGF2ZSBhIGJib3hcbiAgICAvLyBlLmcuIHRpdGxlIGFuZCBvdGhlciBkZXNjcmlwdGl2ZSBlbGVtZW50c1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCB0aGUgY2hpbGRzIGJib3hcbiAgICAgIGJib3ggPSBjaGlsZC5iYm94KCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gR2V0IGNoaWxkcyBtYXRyaXhcblxuXG4gICAgY29uc3QgbSA9IG5ldyBNYXRyaXgoY2hpbGQpOyAvLyBUcmFuc2xhdGUgY2hpbGRzIG1hdHJpeCBieSBhbW91bnQgYW5kXG4gICAgLy8gdHJhbnNmb3JtIGl0IGJhY2sgaW50byBwYXJlbnRzIHNwYWNlXG5cbiAgICBjb25zdCBtYXRyaXggPSBtLnRyYW5zbGF0ZShkeCwgZHkpLnRyYW5zZm9ybShtLmludmVyc2UoKSk7IC8vIENhbGN1bGF0ZSBuZXcgeCBhbmQgeSBmcm9tIG9sZCBib3hcblxuICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQoYmJveC54LCBiYm94LnkpLnRyYW5zZm9ybShtYXRyaXgpOyAvLyBNb3ZlIGVsZW1lbnRcblxuICAgIGNoaWxkLm1vdmUocC54LCBwLnkpO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBkeChkeCkge1xuICByZXR1cm4gdGhpcy5kbW92ZShkeCwgMCk7XG59XG5mdW5jdGlvbiBkeShkeSkge1xuICByZXR1cm4gdGhpcy5kbW92ZSgwLCBkeSk7XG59XG5mdW5jdGlvbiBoZWlnaHQoaGVpZ2h0LCBib3ggPSB0aGlzLmJib3goKSkge1xuICBpZiAoaGVpZ2h0ID09IG51bGwpIHJldHVybiBib3guaGVpZ2h0O1xuICByZXR1cm4gdGhpcy5zaXplKGJveC53aWR0aCwgaGVpZ2h0LCBib3gpO1xufVxuZnVuY3Rpb24gbW92ZSh4ID0gMCwgeSA9IDAsIGJveCA9IHRoaXMuYmJveCgpKSB7XG4gIGNvbnN0IGR4ID0geCAtIGJveC54O1xuICBjb25zdCBkeSA9IHkgLSBib3gueTtcbiAgcmV0dXJuIHRoaXMuZG1vdmUoZHgsIGR5KTtcbn1cbmZ1bmN0aW9uIHNpemUod2lkdGgsIGhlaWdodCwgYm94ID0gdGhpcy5iYm94KCkpIHtcbiAgY29uc3QgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodCwgYm94KTtcbiAgY29uc3Qgc2NhbGVYID0gcC53aWR0aCAvIGJveC53aWR0aDtcbiAgY29uc3Qgc2NhbGVZID0gcC5oZWlnaHQgLyBib3guaGVpZ2h0O1xuICB0aGlzLmNoaWxkcmVuKCkuZm9yRWFjaCgoY2hpbGQsIGkpID0+IHtcbiAgICBjb25zdCBvID0gbmV3IFBvaW50KGJveCkudHJhbnNmb3JtKG5ldyBNYXRyaXgoY2hpbGQpLmludmVyc2UoKSk7XG4gICAgY2hpbGQuc2NhbGUoc2NhbGVYLCBzY2FsZVksIG8ueCwgby55KTtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gd2lkdGgod2lkdGgsIGJveCA9IHRoaXMuYmJveCgpKSB7XG4gIGlmICh3aWR0aCA9PSBudWxsKSByZXR1cm4gYm94LndpZHRoO1xuICByZXR1cm4gdGhpcy5zaXplKHdpZHRoLCBib3guaGVpZ2h0LCBib3gpO1xufVxuZnVuY3Rpb24geCh4LCBib3ggPSB0aGlzLmJib3goKSkge1xuICBpZiAoeCA9PSBudWxsKSByZXR1cm4gYm94Lng7XG4gIHJldHVybiB0aGlzLm1vdmUoeCwgYm94LnksIGJveCk7XG59XG5mdW5jdGlvbiB5KHksIGJveCA9IHRoaXMuYmJveCgpKSB7XG4gIGlmICh5ID09IG51bGwpIHJldHVybiBib3gueTtcbiAgcmV0dXJuIHRoaXMubW92ZShib3gueCwgeSwgYm94KTtcbn1cblxudmFyIGNvbnRhaW5lckdlb21ldHJ5ID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIGRtb3ZlOiBkbW92ZSxcbiAgZHg6IGR4LFxuICBkeTogZHksXG4gIGhlaWdodDogaGVpZ2h0LFxuICBtb3ZlOiBtb3ZlLFxuICBzaXplOiBzaXplLFxuICB3aWR0aDogd2lkdGgsXG4gIHg6IHgsXG4gIHk6IHlcbn07XG5cbmNsYXNzIEcgZXh0ZW5kcyBDb250YWluZXIge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ2cnLCBub2RlKSwgYXR0cnMpO1xuICB9XG5cbn1cbmV4dGVuZChHLCBjb250YWluZXJHZW9tZXRyeSk7XG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBDcmVhdGUgYSBncm91cCBlbGVtZW50XG4gICAgZ3JvdXA6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgRygpKTtcbiAgICB9KVxuICB9XG59KTtcbnJlZ2lzdGVyKEcsICdHJyk7XG5cbmNsYXNzIEEgZXh0ZW5kcyBDb250YWluZXIge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ2EnLCBub2RlKSwgYXR0cnMpO1xuICB9IC8vIExpbmsgdGFyZ2V0IGF0dHJpYnV0ZVxuXG5cbiAgdGFyZ2V0KHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ3RhcmdldCcsIHRhcmdldCk7XG4gIH0gLy8gTGluayB1cmxcblxuXG4gIHRvKHVybCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ2hyZWYnLCB1cmwsIHhsaW5rKTtcbiAgfVxuXG59XG5leHRlbmQoQSwgY29udGFpbmVyR2VvbWV0cnkpO1xucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgLy8gQ3JlYXRlIGEgaHlwZXJsaW5rIGVsZW1lbnRcbiAgICBsaW5rOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAodXJsKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IEEoKSkudG8odXJsKTtcbiAgICB9KVxuICB9LFxuICBFbGVtZW50OiB7XG4gICAgdW5saW5rKCkge1xuICAgICAgY29uc3QgbGluayA9IHRoaXMubGlua2VyKCk7XG4gICAgICBpZiAoIWxpbmspIHJldHVybiB0aGlzO1xuICAgICAgY29uc3QgcGFyZW50ID0gbGluay5wYXJlbnQoKTtcblxuICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGluZGV4ID0gcGFyZW50LmluZGV4KGxpbmspO1xuICAgICAgcGFyZW50LmFkZCh0aGlzLCBpbmRleCk7XG4gICAgICBsaW5rLnJlbW92ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGxpbmtUbyh1cmwpIHtcbiAgICAgIC8vIHJldXNlIG9sZCBsaW5rIGlmIHBvc3NpYmxlXG4gICAgICBsZXQgbGluayA9IHRoaXMubGlua2VyKCk7XG5cbiAgICAgIGlmICghbGluaykge1xuICAgICAgICBsaW5rID0gbmV3IEEoKTtcbiAgICAgICAgdGhpcy53cmFwKGxpbmspO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB1cmwuY2FsbChsaW5rLCBsaW5rKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmsudG8odXJsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGxpbmtlcigpIHtcbiAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLnBhcmVudCgpO1xuXG4gICAgICBpZiAobGluayAmJiBsaW5rLm5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG4gICAgICAgIHJldHVybiBsaW5rO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgfVxufSk7XG5yZWdpc3RlcihBLCAnQScpO1xuXG5jbGFzcyBNYXNrIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygnbWFzaycsIG5vZGUpLCBhdHRycyk7XG4gIH0gLy8gVW5tYXNrIGFsbCBtYXNrZWQgZWxlbWVudHMgYW5kIHJlbW92ZSBpdHNlbGZcblxuXG4gIHJlbW92ZSgpIHtcbiAgICAvLyB1bm1hc2sgYWxsIHRhcmdldHNcbiAgICB0aGlzLnRhcmdldHMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgZWwudW5tYXNrKCk7XG4gICAgfSk7IC8vIHJlbW92ZSBtYXNrIGZyb20gcGFyZW50XG5cbiAgICByZXR1cm4gc3VwZXIucmVtb3ZlKCk7XG4gIH1cblxuICB0YXJnZXRzKCkge1xuICAgIHJldHVybiBiYXNlRmluZCgnc3ZnIFttYXNrKj0nICsgdGhpcy5pZCgpICsgJ10nKTtcbiAgfVxuXG59XG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICBtYXNrOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWZzKCkucHV0KG5ldyBNYXNrKCkpO1xuICAgIH0pXG4gIH0sXG4gIEVsZW1lbnQ6IHtcbiAgICAvLyBEaXN0cmlidXRlIG1hc2sgdG8gc3ZnIGVsZW1lbnRcbiAgICBtYXNrZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2UoJ21hc2snKTtcbiAgICB9LFxuXG4gICAgbWFza1dpdGgoZWxlbWVudCkge1xuICAgICAgLy8gdXNlIGdpdmVuIG1hc2sgb3IgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgY29uc3QgbWFza2VyID0gZWxlbWVudCBpbnN0YW5jZW9mIE1hc2sgPyBlbGVtZW50IDogdGhpcy5wYXJlbnQoKS5tYXNrKCkuYWRkKGVsZW1lbnQpOyAvLyBhcHBseSBtYXNrXG5cbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ21hc2snLCAndXJsKCMnICsgbWFza2VyLmlkKCkgKyAnKScpO1xuICAgIH0sXG5cbiAgICAvLyBVbm1hc2sgZWxlbWVudFxuICAgIHVubWFzaygpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ21hc2snLCBudWxsKTtcbiAgICB9XG5cbiAgfVxufSk7XG5yZWdpc3RlcihNYXNrLCAnTWFzaycpO1xuXG5jbGFzcyBTdG9wIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygnc3RvcCcsIG5vZGUpLCBhdHRycyk7XG4gIH0gLy8gYWRkIGNvbG9yIHN0b3BzXG5cblxuICB1cGRhdGUobykge1xuICAgIGlmICh0eXBlb2YgbyA9PT0gJ251bWJlcicgfHwgbyBpbnN0YW5jZW9mIFNWR051bWJlcikge1xuICAgICAgbyA9IHtcbiAgICAgICAgb2Zmc2V0OiBhcmd1bWVudHNbMF0sXG4gICAgICAgIGNvbG9yOiBhcmd1bWVudHNbMV0sXG4gICAgICAgIG9wYWNpdHk6IGFyZ3VtZW50c1syXVxuICAgICAgfTtcbiAgICB9IC8vIHNldCBhdHRyaWJ1dGVzXG5cblxuICAgIGlmIChvLm9wYWNpdHkgIT0gbnVsbCkgdGhpcy5hdHRyKCdzdG9wLW9wYWNpdHknLCBvLm9wYWNpdHkpO1xuICAgIGlmIChvLmNvbG9yICE9IG51bGwpIHRoaXMuYXR0cignc3RvcC1jb2xvcicsIG8uY29sb3IpO1xuICAgIGlmIChvLm9mZnNldCAhPSBudWxsKSB0aGlzLmF0dHIoJ29mZnNldCcsIG5ldyBTVkdOdW1iZXIoby5vZmZzZXQpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59XG5yZWdpc3Rlck1ldGhvZHMoe1xuICBHcmFkaWVudDoge1xuICAgIC8vIEFkZCBhIGNvbG9yIHN0b3BcbiAgICBzdG9wOiBmdW5jdGlvbiAob2Zmc2V0LCBjb2xvciwgb3BhY2l0eSkge1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTdG9wKCkpLnVwZGF0ZShvZmZzZXQsIGNvbG9yLCBvcGFjaXR5KTtcbiAgICB9XG4gIH1cbn0pO1xucmVnaXN0ZXIoU3RvcCwgJ1N0b3AnKTtcblxuZnVuY3Rpb24gY3NzUnVsZShzZWxlY3RvciwgcnVsZSkge1xuICBpZiAoIXNlbGVjdG9yKSByZXR1cm4gJyc7XG4gIGlmICghcnVsZSkgcmV0dXJuIHNlbGVjdG9yO1xuICBsZXQgcmV0ID0gc2VsZWN0b3IgKyAneyc7XG5cbiAgZm9yIChjb25zdCBpIGluIHJ1bGUpIHtcbiAgICByZXQgKz0gdW5DYW1lbENhc2UoaSkgKyAnOicgKyBydWxlW2ldICsgJzsnO1xuICB9XG5cbiAgcmV0ICs9ICd9JztcbiAgcmV0dXJuIHJldDtcbn1cblxuY2xhc3MgU3R5bGUgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdzdHlsZScsIG5vZGUpLCBhdHRycyk7XG4gIH1cblxuICBhZGRUZXh0KHcgPSAnJykge1xuICAgIHRoaXMubm9kZS50ZXh0Q29udGVudCArPSB3O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZm9udChuYW1lLCBzcmMsIHBhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZSgnQGZvbnQtZmFjZScsIHtcbiAgICAgIGZvbnRGYW1pbHk6IG5hbWUsXG4gICAgICBzcmM6IHNyYyxcbiAgICAgIC4uLnBhcmFtc1xuICAgIH0pO1xuICB9XG5cbiAgcnVsZShzZWxlY3Rvciwgb2JqKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkVGV4dChjc3NSdWxlKHNlbGVjdG9yLCBvYmopKTtcbiAgfVxuXG59XG5yZWdpc3Rlck1ldGhvZHMoJ0RvbScsIHtcbiAgc3R5bGUoc2VsZWN0b3IsIG9iaikge1xuICAgIHJldHVybiB0aGlzLnB1dChuZXcgU3R5bGUoKSkucnVsZShzZWxlY3Rvciwgb2JqKTtcbiAgfSxcblxuICBmb250ZmFjZShuYW1lLCBzcmMsIHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnB1dChuZXcgU3R5bGUoKSkuZm9udChuYW1lLCBzcmMsIHBhcmFtcyk7XG4gIH1cblxufSk7XG5yZWdpc3RlcihTdHlsZSwgJ1N0eWxlJyk7XG5cbmNsYXNzIFRleHRQYXRoIGV4dGVuZHMgVGV4dCB7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ3RleHRQYXRoJywgbm9kZSksIGF0dHJzKTtcbiAgfSAvLyByZXR1cm4gdGhlIGFycmF5IG9mIHRoZSBwYXRoIHRyYWNrIGVsZW1lbnRcblxuXG4gIGFycmF5KCkge1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFjaygpO1xuICAgIHJldHVybiB0cmFjayA/IHRyYWNrLmFycmF5KCkgOiBudWxsO1xuICB9IC8vIFBsb3QgcGF0aCBpZiBhbnlcblxuXG4gIHBsb3QoZCkge1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFjaygpO1xuICAgIGxldCBwYXRoQXJyYXkgPSBudWxsO1xuXG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICBwYXRoQXJyYXkgPSB0cmFjay5wbG90KGQpO1xuICAgIH1cblxuICAgIHJldHVybiBkID09IG51bGwgPyBwYXRoQXJyYXkgOiB0aGlzO1xuICB9IC8vIEdldCB0aGUgcGF0aCBlbGVtZW50XG5cblxuICB0cmFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2UoJ2hyZWYnKTtcbiAgfVxuXG59XG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICB0ZXh0UGF0aDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHRleHQsIHBhdGgpIHtcbiAgICAgIC8vIENvbnZlcnQgdGV4dCB0byBpbnN0YW5jZSBpZiBuZWVkZWRcbiAgICAgIGlmICghKHRleHQgaW5zdGFuY2VvZiBUZXh0KSkge1xuICAgICAgICB0ZXh0ID0gdGhpcy50ZXh0KHRleHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGV4dC5wYXRoKHBhdGgpO1xuICAgIH0pXG4gIH0sXG4gIFRleHQ6IHtcbiAgICAvLyBDcmVhdGUgcGF0aCBmb3IgdGV4dCB0byBydW4gb25cbiAgICBwYXRoOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAodHJhY2ssIGltcG9ydE5vZGVzID0gdHJ1ZSkge1xuICAgICAgY29uc3QgdGV4dFBhdGggPSBuZXcgVGV4dFBhdGgoKTsgLy8gaWYgdHJhY2sgaXMgYSBwYXRoLCByZXVzZSBpdFxuXG4gICAgICBpZiAoISh0cmFjayBpbnN0YW5jZW9mIFBhdGgpKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBwYXRoIGVsZW1lbnRcbiAgICAgICAgdHJhY2sgPSB0aGlzLmRlZnMoKS5wYXRoKHRyYWNrKTtcbiAgICAgIH0gLy8gbGluayB0ZXh0UGF0aCB0byBwYXRoIGFuZCBhZGQgY29udGVudFxuXG5cbiAgICAgIHRleHRQYXRoLmF0dHIoJ2hyZWYnLCAnIycgKyB0cmFjaywgeGxpbmspOyAvLyBUcmFuc3BsYW50IGFsbCBub2RlcyBmcm9tIHRleHQgdG8gdGV4dFBhdGhcblxuICAgICAgbGV0IG5vZGU7XG5cbiAgICAgIGlmIChpbXBvcnROb2Rlcykge1xuICAgICAgICB3aGlsZSAobm9kZSA9IHRoaXMubm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgdGV4dFBhdGgubm9kZS5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBhZGQgdGV4dFBhdGggZWxlbWVudCBhcyBjaGlsZCBub2RlIGFuZCByZXR1cm4gdGV4dFBhdGhcblxuXG4gICAgICByZXR1cm4gdGhpcy5wdXQodGV4dFBhdGgpO1xuICAgIH0pLFxuXG4gICAgLy8gR2V0IHRoZSB0ZXh0UGF0aCBjaGlsZHJlblxuICAgIHRleHRQYXRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZE9uZSgndGV4dFBhdGgnKTtcbiAgICB9XG5cbiAgfSxcbiAgUGF0aDoge1xuICAgIC8vIGNyZWF0ZXMgYSB0ZXh0UGF0aCBmcm9tIHRoaXMgcGF0aFxuICAgIHRleHQ6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAvLyBDb252ZXJ0IHRleHQgdG8gaW5zdGFuY2UgaWYgbmVlZGVkXG4gICAgICBpZiAoISh0ZXh0IGluc3RhbmNlb2YgVGV4dCkpIHtcbiAgICAgICAgdGV4dCA9IG5ldyBUZXh0KCkuYWRkVG8odGhpcy5wYXJlbnQoKSkudGV4dCh0ZXh0KTtcbiAgICAgIH0gLy8gQ3JlYXRlIHRleHRQYXRoIGZyb20gdGV4dCBhbmQgcGF0aCBhbmQgcmV0dXJuXG5cblxuICAgICAgcmV0dXJuIHRleHQucGF0aCh0aGlzKTtcbiAgICB9KSxcblxuICAgIHRhcmdldHMoKSB7XG4gICAgICByZXR1cm4gYmFzZUZpbmQoJ3N2ZyB0ZXh0UGF0aCcpLmZpbHRlcihub2RlID0+IHtcbiAgICAgICAgcmV0dXJuIChub2RlLmF0dHIoJ2hyZWYnKSB8fCAnJykuaW5jbHVkZXModGhpcy5pZCgpKTtcbiAgICAgIH0pOyAvLyBEb2VzIG5vdCB3b3JrIGluIElFMTEuIFVzZSB3aGVuIElFIHN1cHBvcnQgaXMgZHJvcHBlZFxuICAgICAgLy8gcmV0dXJuIGJhc2VGaW5kKCdzdmcgdGV4dFBhdGhbKnxocmVmKj0nICsgdGhpcy5pZCgpICsgJ10nKVxuICAgIH1cblxuICB9XG59KTtcblRleHRQYXRoLnByb3RvdHlwZS5Nb3JwaEFycmF5ID0gUGF0aEFycmF5O1xucmVnaXN0ZXIoVGV4dFBhdGgsICdUZXh0UGF0aCcpO1xuXG5jbGFzcyBVc2UgZXh0ZW5kcyBTaGFwZSB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygndXNlJywgbm9kZSksIGF0dHJzKTtcbiAgfSAvLyBVc2UgZWxlbWVudCBhcyBhIHJlZmVyZW5jZVxuXG5cbiAgdXNlKGVsZW1lbnQsIGZpbGUpIHtcbiAgICAvLyBTZXQgbGluZWQgZWxlbWVudFxuICAgIHJldHVybiB0aGlzLmF0dHIoJ2hyZWYnLCAoZmlsZSB8fCAnJykgKyAnIycgKyBlbGVtZW50LCB4bGluayk7XG4gIH1cblxufVxucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgLy8gQ3JlYXRlIGEgdXNlIGVsZW1lbnRcbiAgICB1c2U6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uIChlbGVtZW50LCBmaWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFVzZSgpKS51c2UoZWxlbWVudCwgZmlsZSk7XG4gICAgfSlcbiAgfVxufSk7XG5yZWdpc3RlcihVc2UsICdVc2UnKTtcblxuLyogT3B0aW9uYWwgTW9kdWxlcyAqL1xuY29uc3QgU1ZHID0gbWFrZUluc3RhbmNlO1xuZXh0ZW5kKFtTdmcsIFN5bWJvbCwgSW1hZ2UsIFBhdHRlcm4sIE1hcmtlcl0sIGdldE1ldGhvZHNGb3IoJ3ZpZXdib3gnKSk7XG5leHRlbmQoW0xpbmUsIFBvbHlsaW5lLCBQb2x5Z29uLCBQYXRoXSwgZ2V0TWV0aG9kc0ZvcignbWFya2VyJykpO1xuZXh0ZW5kKFRleHQsIGdldE1ldGhvZHNGb3IoJ1RleHQnKSk7XG5leHRlbmQoUGF0aCwgZ2V0TWV0aG9kc0ZvcignUGF0aCcpKTtcbmV4dGVuZChEZWZzLCBnZXRNZXRob2RzRm9yKCdEZWZzJykpO1xuZXh0ZW5kKFtUZXh0LCBUc3Bhbl0sIGdldE1ldGhvZHNGb3IoJ1RzcGFuJykpO1xuZXh0ZW5kKFtSZWN0LCBFbGxpcHNlLCBHcmFkaWVudCwgUnVubmVyXSwgZ2V0TWV0aG9kc0ZvcigncmFkaXVzJykpO1xuZXh0ZW5kKEV2ZW50VGFyZ2V0LCBnZXRNZXRob2RzRm9yKCdFdmVudFRhcmdldCcpKTtcbmV4dGVuZChEb20sIGdldE1ldGhvZHNGb3IoJ0RvbScpKTtcbmV4dGVuZChFbGVtZW50LCBnZXRNZXRob2RzRm9yKCdFbGVtZW50JykpO1xuZXh0ZW5kKFNoYXBlLCBnZXRNZXRob2RzRm9yKCdTaGFwZScpKTtcbmV4dGVuZChbQ29udGFpbmVyLCBGcmFnbWVudF0sIGdldE1ldGhvZHNGb3IoJ0NvbnRhaW5lcicpKTtcbmV4dGVuZChHcmFkaWVudCwgZ2V0TWV0aG9kc0ZvcignR3JhZGllbnQnKSk7XG5leHRlbmQoUnVubmVyLCBnZXRNZXRob2RzRm9yKCdSdW5uZXInKSk7XG5MaXN0LmV4dGVuZChnZXRNZXRob2ROYW1lcygpKTtcbnJlZ2lzdGVyTW9ycGhhYmxlVHlwZShbU1ZHTnVtYmVyLCBDb2xvciwgQm94LCBNYXRyaXgsIFNWR0FycmF5LCBQb2ludEFycmF5LCBQYXRoQXJyYXksIFBvaW50XSk7XG5tYWtlTW9ycGhhYmxlKCk7XG5cbmV4cG9ydCB7IEEsIEFuaW1hdG9yLCBTVkdBcnJheSBhcyBBcnJheSwgQm94LCBDaXJjbGUsIENsaXBQYXRoLCBDb2xvciwgQ29udGFpbmVyLCBDb250cm9sbGVyLCBEZWZzLCBEb20sIEVhc2UsIEVsZW1lbnQsIEVsbGlwc2UsIEV2ZW50VGFyZ2V0LCBGb3JlaWduT2JqZWN0LCBGcmFnbWVudCwgRywgR3JhZGllbnQsIEltYWdlLCBMaW5lLCBMaXN0LCBNYXJrZXIsIE1hc2ssIE1hdHJpeCwgTW9ycGhhYmxlLCBOb25Nb3JwaGFibGUsIFNWR051bWJlciBhcyBOdW1iZXIsIE9iamVjdEJhZywgUElELCBQYXRoLCBQYXRoQXJyYXksIFBhdHRlcm4sIFBvaW50LCBQb2ludEFycmF5LCBQb2x5Z29uLCBQb2x5bGluZSwgUXVldWUsIFJlY3QsIFJ1bm5lciwgU1ZHLCBTaGFwZSwgU3ByaW5nLCBTdG9wLCBTdHlsZSwgU3ZnLCBTeW1ib2wsIFRleHQsIFRleHRQYXRoLCBUaW1lbGluZSwgVHJhbnNmb3JtQmFnLCBUc3BhbiwgVXNlLCBhZG9wdCwgYXNzaWduTmV3SWQsIGNsZWFyRXZlbnRzLCBjcmVhdGUsIGRlZmF1bHRzLCBkaXNwYXRjaCwgZWFzaW5nLCBlaWQsIGV4dGVuZCwgYmFzZUZpbmQgYXMgZmluZCwgZ2V0Q2xhc3MsIGdldEV2ZW50VGFyZ2V0LCBnZXRFdmVudHMsIGdldFdpbmRvdywgbWFrZUluc3RhbmNlLCBtYWtlTW9ycGhhYmxlLCBtb2NrQWRvcHQsIG5hbWVzcGFjZXMsIG5vZGVPck5ldywgb2ZmLCBvbiwgcGFyc2VyLCByZWdleCwgcmVnaXN0ZXIsIHJlZ2lzdGVyTW9ycGhhYmxlVHlwZSwgcmVnaXN0ZXJXaW5kb3csIHJlc3RvcmVXaW5kb3csIHJvb3QsIHNhdmVXaW5kb3csIHV0aWxzLCB3aW5kb3dFdmVudHMsIHdpdGhXaW5kb3csIHdyYXBXaXRoQXR0ckNoZWNrIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdmcuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@svgdotjs/svg.js/dist/svg.esm.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/Footer.module.css":
/*!******************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/Footer.module.css ***!
  \******************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".Footer_footer__pQtti {\\n  width: 100%;\\n  flex: 0 0 50px;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n}\\n\\n.Footer_logo__fUEOF {\\n  height: 3em;\\n  margin: 5px;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://components/Footer.module.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,WAAW;EACX,cAAc;EACd,aAAa;EACb,uBAAuB;EACvB,mBAAmB;AACrB;;AAEA;EACE,WAAW;EACX,WAAW;AACb\",\"sourcesContent\":[\".footer {\\n  width: 100%;\\n  flex: 0 0 50px;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n}\\n\\n.logo {\\n  height: 3em;\\n  margin: 5px;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"footer\": \"Footer_footer__pQtti\",\n\t\"logo\": \"Footer_logo__fUEOF\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS5vbmVPZls5XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0ub25lT2ZbOV0udXNlWzJdIS4vY29tcG9uZW50cy9Gb290ZXIubW9kdWxlLmNzcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLG1LQUErRTtBQUN6SDtBQUNBO0FBQ0EsaUVBQWlFLGdCQUFnQixtQkFBbUIsa0JBQWtCLDRCQUE0Qix3QkFBd0IsR0FBRyx5QkFBeUIsZ0JBQWdCLGdCQUFnQixHQUFHLFNBQVMsNkZBQTZGLFVBQVUsVUFBVSxVQUFVLFlBQVksYUFBYSxPQUFPLEtBQUssVUFBVSxVQUFVLGtDQUFrQyxnQkFBZ0IsbUJBQW1CLGtCQUFrQiw0QkFBNEIsd0JBQXdCLEdBQUcsV0FBVyxnQkFBZ0IsZ0JBQWdCLEdBQUcscUJBQXFCO0FBQ3ZuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9Gb290ZXIubW9kdWxlLmNzcz9lYmY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIuRm9vdGVyX2Zvb3Rlcl9fcFF0dGkge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBmbGV4OiAwIDAgNTBweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5Gb290ZXJfbG9nb19fZlVFT0Yge1xcbiAgaGVpZ2h0OiAzZW07XFxuICBtYXJnaW46IDVweDtcXG59XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL2NvbXBvbmVudHMvRm9vdGVyLm1vZHVsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSxXQUFXO0VBQ1gsY0FBYztFQUNkLGFBQWE7RUFDYix1QkFBdUI7RUFDdkIsbUJBQW1CO0FBQ3JCOztBQUVBO0VBQ0UsV0FBVztFQUNYLFdBQVc7QUFDYlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuZm9vdGVyIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgZmxleDogMCAwIDUwcHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG4ubG9nbyB7XFxuICBoZWlnaHQ6IDNlbTtcXG4gIG1hcmdpbjogNXB4O1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmxvY2FscyA9IHtcblx0XCJmb290ZXJcIjogXCJGb290ZXJfZm9vdGVyX19wUXR0aVwiLFxuXHRcImxvZ29cIjogXCJGb290ZXJfbG9nb19fZlVFT0ZcIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/Footer.module.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/Header.module.css":
/*!******************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/Header.module.css ***!
  \******************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_GET_URL_IMPORT___ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/getUrl.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/getUrl.js\");\nvar ___CSS_LOADER_URL_IMPORT_0___ = __webpack_require__(/*! ../public/fonts/fondamento-italic-webfont.woff2 */ \"./public/fonts/fondamento-italic-webfont.woff2\");\nvar ___CSS_LOADER_URL_IMPORT_1___ = __webpack_require__(/*! ../public/fonts/fondamento-regular-webfont.woff2 */ \"./public/fonts/fondamento-regular-webfont.woff2\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);\nvar ___CSS_LOADER_URL_REPLACEMENT_1___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_1___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"@font-face {\\n\\tfont-family: 'fondamento';\\n\\tsrc: url(\" + ___CSS_LOADER_URL_REPLACEMENT_0___ + \") format('woff2');\\n\\tfont-weight: normal;\\n\\tfont-style: italic;\\n  \\n  }\\n  \\n  @font-face {\\n\\tfont-family: 'fondamento';\\n\\tsrc: url(\" + ___CSS_LOADER_URL_REPLACEMENT_1___ + \") format('woff2');\\n\\tfont-weight: normal;\\n\\tfont-style: normal;\\n  \\n  }\\n\\n.Header_title__QYI_x {\\n\\tflex: 0 0 60px;\\n\\tmargin: 0;\\n\\tfont-family: 'fondamento'\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://components/Header.module.css\"],\"names\":[],\"mappings\":\"AAAA;CACC,yBAAyB;CACzB,4DAA2E;CAC3E,mBAAmB;CACnB,kBAAkB;;EAEjB;;EAEA;CACD,yBAAyB;CACzB,4DAA4E;CAC5E,mBAAmB;CACnB,kBAAkB;;EAEjB;;AAEF;CACC,cAAc;CACd,SAAS;CACT;AACD\",\"sourcesContent\":[\"@font-face {\\n\\tfont-family: 'fondamento';\\n\\tsrc: url('../public/fonts/fondamento-italic-webfont.woff2') format('woff2');\\n\\tfont-weight: normal;\\n\\tfont-style: italic;\\n  \\n  }\\n  \\n  @font-face {\\n\\tfont-family: 'fondamento';\\n\\tsrc: url('../public/fonts/fondamento-regular-webfont.woff2') format('woff2');\\n\\tfont-weight: normal;\\n\\tfont-style: normal;\\n  \\n  }\\n\\n.title {\\n\\tflex: 0 0 60px;\\n\\tmargin: 0;\\n\\tfont-family: 'fondamento'\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"title\": \"Header_title__QYI_x\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS5vbmVPZls5XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0ub25lT2ZbOV0udXNlWzJdIS4vY29tcG9uZW50cy9IZWFkZXIubW9kdWxlLmNzcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLG1LQUErRTtBQUN6SCxzQ0FBc0MsbUJBQU8sQ0FBQyx5S0FBa0Y7QUFDaEksb0NBQW9DLG1CQUFPLENBQUMsdUdBQWlEO0FBQzdGLG9DQUFvQyxtQkFBTyxDQUFDLHlHQUFrRDtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw4QkFBOEIseUVBQXlFLHdCQUF3Qix1QkFBdUIsU0FBUyxvQkFBb0IsOEJBQThCLHlFQUF5RSx3QkFBd0IsdUJBQXVCLFNBQVMsMEJBQTBCLG1CQUFtQixjQUFjLGdDQUFnQyxPQUFPLDZGQUE2RixZQUFZLGFBQWEsYUFBYSxjQUFjLE9BQU8sS0FBSyxZQUFZLGFBQWEsYUFBYSxjQUFjLE9BQU8sS0FBSyxVQUFVLFVBQVUsS0FBSyxxQ0FBcUMsOEJBQThCLGdGQUFnRix3QkFBd0IsdUJBQXVCLFNBQVMsb0JBQW9CLDhCQUE4QixpRkFBaUYsd0JBQXdCLHVCQUF1QixTQUFTLFlBQVksbUJBQW1CLGNBQWMsZ0NBQWdDLG1CQUFtQjtBQUN0c0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0hlYWRlci5tb2R1bGUuY3NzPzExMmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qc1wiKTtcbnZhciBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL3J1bnRpbWUvZ2V0VXJsLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8wX19fID0gcmVxdWlyZShcIi4uL3B1YmxpYy9mb250cy9mb25kYW1lbnRvLWl0YWxpYy13ZWJmb250LndvZmYyXCIpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8xX19fID0gcmVxdWlyZShcIi4uL3B1YmxpYy9mb250cy9mb25kYW1lbnRvLXJlZ3VsYXItd2ViZm9udC53b2ZmMlwiKTtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8wX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMF9fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMV9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzFfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiQGZvbnQtZmFjZSB7XFxuXFx0Zm9udC1mYW1pbHk6ICdmb25kYW1lbnRvJztcXG5cXHRzcmM6IHVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzBfX18gKyBcIikgZm9ybWF0KCd3b2ZmMicpO1xcblxcdGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuXFx0Zm9udC1zdHlsZTogaXRhbGljO1xcbiAgXFxuICB9XFxuICBcXG4gIEBmb250LWZhY2Uge1xcblxcdGZvbnQtZmFtaWx5OiAnZm9uZGFtZW50byc7XFxuXFx0c3JjOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8xX19fICsgXCIpIGZvcm1hdCgnd29mZjInKTtcXG5cXHRmb250LXdlaWdodDogbm9ybWFsO1xcblxcdGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gIFxcbiAgfVxcblxcbi5IZWFkZXJfdGl0bGVfX1FZSV94IHtcXG5cXHRmbGV4OiAwIDAgNjBweDtcXG5cXHRtYXJnaW46IDA7XFxuXFx0Zm9udC1mYW1pbHk6ICdmb25kYW1lbnRvJ1xcbn1cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vY29tcG9uZW50cy9IZWFkZXIubW9kdWxlLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtDQUNDLHlCQUF5QjtDQUN6Qiw0REFBMkU7Q0FDM0UsbUJBQW1CO0NBQ25CLGtCQUFrQjs7RUFFakI7O0VBRUE7Q0FDRCx5QkFBeUI7Q0FDekIsNERBQTRFO0NBQzVFLG1CQUFtQjtDQUNuQixrQkFBa0I7O0VBRWpCOztBQUVGO0NBQ0MsY0FBYztDQUNkLFNBQVM7Q0FDVDtBQUNEXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIkBmb250LWZhY2Uge1xcblxcdGZvbnQtZmFtaWx5OiAnZm9uZGFtZW50byc7XFxuXFx0c3JjOiB1cmwoJy4uL3B1YmxpYy9mb250cy9mb25kYW1lbnRvLWl0YWxpYy13ZWJmb250LndvZmYyJykgZm9ybWF0KCd3b2ZmMicpO1xcblxcdGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuXFx0Zm9udC1zdHlsZTogaXRhbGljO1xcbiAgXFxuICB9XFxuICBcXG4gIEBmb250LWZhY2Uge1xcblxcdGZvbnQtZmFtaWx5OiAnZm9uZGFtZW50byc7XFxuXFx0c3JjOiB1cmwoJy4uL3B1YmxpYy9mb250cy9mb25kYW1lbnRvLXJlZ3VsYXItd2ViZm9udC53b2ZmMicpIGZvcm1hdCgnd29mZjInKTtcXG5cXHRmb250LXdlaWdodDogbm9ybWFsO1xcblxcdGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gIFxcbiAgfVxcblxcbi50aXRsZSB7XFxuXFx0ZmxleDogMCAwIDYwcHg7XFxuXFx0bWFyZ2luOiAwO1xcblxcdGZvbnQtZmFtaWx5OiAnZm9uZGFtZW50bydcXG59XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwidGl0bGVcIjogXCJIZWFkZXJfdGl0bGVfX1FZSV94XCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/Header.module.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/SVGEditor.module.css":
/*!*********************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/SVGEditor.module.css ***!
  \*********************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".SVGEditor_editorContainer__Vr_BU {\\n\\tflex: 1 1 60vw;\\n\\tdisplay: flex;\\n\\tjustify-content: center;\\n\\talign-items: center;\\n\\t\\n}\\n\\n.SVGEditor_editor__tcUxT {\\n\\tborder: 1px solid rgb(229, 232, 236);\\n\\tborder-radius: 6px;\\n\\tpadding: 0px;\\n\\tmargin: 1em 0;\\n\\tbox-shadow:  0 0 25px -15px lightsteelblue;\\n\\theight: -moz-fit-content;\\n\\theight: fit-content;\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://components/SVGEditor.module.css\"],\"names\":[],\"mappings\":\"AAAA;CACC,cAAc;CACd,aAAa;CACb,uBAAuB;CACvB,mBAAmB;;AAEpB;;AAEA;CACC,oCAAoC;CACpC,kBAAkB;CAClB,YAAY;CACZ,aAAa;CACb,0CAA0C;CAC1C,wBAAmB;CAAnB,mBAAmB;AACpB\",\"sourcesContent\":[\".editorContainer {\\n\\tflex: 1 1 60vw;\\n\\tdisplay: flex;\\n\\tjustify-content: center;\\n\\talign-items: center;\\n\\t\\n}\\n\\n.editor {\\n\\tborder: 1px solid rgb(229, 232, 236);\\n\\tborder-radius: 6px;\\n\\tpadding: 0px;\\n\\tmargin: 1em 0;\\n\\tbox-shadow:  0 0 25px -15px lightsteelblue;\\n\\theight: fit-content;\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"editorContainer\": \"SVGEditor_editorContainer__Vr_BU\",\n\t\"editor\": \"SVGEditor_editor__tcUxT\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS5vbmVPZls5XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0ub25lT2ZbOV0udXNlWzJdIS4vY29tcG9uZW50cy9TVkdFZGl0b3IubW9kdWxlLmNzcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLG1LQUErRTtBQUN6SDtBQUNBO0FBQ0EsNkVBQTZFLG1CQUFtQixrQkFBa0IsNEJBQTRCLHdCQUF3QixPQUFPLDhCQUE4Qix5Q0FBeUMsdUJBQXVCLGlCQUFpQixrQkFBa0IsK0NBQStDLDZCQUE2Qix3QkFBd0IsR0FBRyxPQUFPLGdHQUFnRyxVQUFVLFVBQVUsWUFBWSxjQUFjLE9BQU8sS0FBSyxZQUFZLGFBQWEsV0FBVyxVQUFVLFlBQVksYUFBYSxhQUFhLDRDQUE0QyxtQkFBbUIsa0JBQWtCLDRCQUE0Qix3QkFBd0IsT0FBTyxhQUFhLHlDQUF5Qyx1QkFBdUIsaUJBQWlCLGtCQUFrQiwrQ0FBK0Msd0JBQXdCLEdBQUcsbUJBQW1CO0FBQ24rQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9TVkdFZGl0b3IubW9kdWxlLmNzcz85NDljIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIuU1ZHRWRpdG9yX2VkaXRvckNvbnRhaW5lcl9fVnJfQlUge1xcblxcdGZsZXg6IDEgMSA2MHZ3O1xcblxcdGRpc3BsYXk6IGZsZXg7XFxuXFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuXFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcXG5cXHRcXG59XFxuXFxuLlNWR0VkaXRvcl9lZGl0b3JfX3RjVXhUIHtcXG5cXHRib3JkZXI6IDFweCBzb2xpZCByZ2IoMjI5LCAyMzIsIDIzNik7XFxuXFx0Ym9yZGVyLXJhZGl1czogNnB4O1xcblxcdHBhZGRpbmc6IDBweDtcXG5cXHRtYXJnaW46IDFlbSAwO1xcblxcdGJveC1zaGFkb3c6ICAwIDAgMjVweCAtMTVweCBsaWdodHN0ZWVsYmx1ZTtcXG5cXHRoZWlnaHQ6IC1tb3otZml0LWNvbnRlbnQ7XFxuXFx0aGVpZ2h0OiBmaXQtY29udGVudDtcXG59XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL2NvbXBvbmVudHMvU1ZHRWRpdG9yLm1vZHVsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7Q0FDQyxjQUFjO0NBQ2QsYUFBYTtDQUNiLHVCQUF1QjtDQUN2QixtQkFBbUI7O0FBRXBCOztBQUVBO0NBQ0Msb0NBQW9DO0NBQ3BDLGtCQUFrQjtDQUNsQixZQUFZO0NBQ1osYUFBYTtDQUNiLDBDQUEwQztDQUMxQyx3QkFBbUI7Q0FBbkIsbUJBQW1CO0FBQ3BCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5lZGl0b3JDb250YWluZXIge1xcblxcdGZsZXg6IDEgMSA2MHZ3O1xcblxcdGRpc3BsYXk6IGZsZXg7XFxuXFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuXFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcXG5cXHRcXG59XFxuXFxuLmVkaXRvciB7XFxuXFx0Ym9yZGVyOiAxcHggc29saWQgcmdiKDIyOSwgMjMyLCAyMzYpO1xcblxcdGJvcmRlci1yYWRpdXM6IDZweDtcXG5cXHRwYWRkaW5nOiAwcHg7XFxuXFx0bWFyZ2luOiAxZW0gMDtcXG5cXHRib3gtc2hhZG93OiAgMCAwIDI1cHggLTE1cHggbGlnaHRzdGVlbGJsdWU7XFxuXFx0aGVpZ2h0OiBmaXQtY29udGVudDtcXG59XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwiZWRpdG9yQ29udGFpbmVyXCI6IFwiU1ZHRWRpdG9yX2VkaXRvckNvbnRhaW5lcl9fVnJfQlVcIixcblx0XCJlZGl0b3JcIjogXCJTVkdFZGl0b3JfZWRpdG9yX190Y1V4VFwiXG59O1xubW9kdWxlLmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/SVGEditor.module.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/Sidebar.module.css":
/*!*******************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/Sidebar.module.css ***!
  \*******************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".Sidebar_sidebar__G7Mzs {\\n\\tborder-left: 1px solid rgb(236, 236, 236);\\n\\tpadding-left: 3vw;\\n\\tflex: 0 0 30vw;\\n\\tmin-width: 300px;\\n\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://components/Sidebar.module.css\"],\"names\":[],\"mappings\":\"AAAA;CACC,yCAAyC;CACzC,iBAAiB;CACjB,cAAc;CACd,gBAAgB;;AAEjB\",\"sourcesContent\":[\".sidebar {\\n\\tborder-left: 1px solid rgb(236, 236, 236);\\n\\tpadding-left: 3vw;\\n\\tflex: 0 0 30vw;\\n\\tmin-width: 300px;\\n\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"sidebar\": \"Sidebar_sidebar__G7Mzs\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS5vbmVPZls5XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0ub25lT2ZbOV0udXNlWzJdIS4vY29tcG9uZW50cy9TaWRlYmFyLm1vZHVsZS5jc3MiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQ0FBa0MsbUJBQU8sQ0FBQyxtS0FBK0U7QUFDekg7QUFDQTtBQUNBLG1FQUFtRSw4Q0FBOEMsc0JBQXNCLG1CQUFtQixxQkFBcUIsS0FBSyxPQUFPLDhGQUE4RixZQUFZLGFBQWEsV0FBVyxhQUFhLG9DQUFvQyw4Q0FBOEMsc0JBQXNCLG1CQUFtQixxQkFBcUIsS0FBSyxtQkFBbUI7QUFDbGY7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL1NpZGViYXIubW9kdWxlLmNzcz81OGNlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIuU2lkZWJhcl9zaWRlYmFyX19HN016cyB7XFxuXFx0Ym9yZGVyLWxlZnQ6IDFweCBzb2xpZCByZ2IoMjM2LCAyMzYsIDIzNik7XFxuXFx0cGFkZGluZy1sZWZ0OiAzdnc7XFxuXFx0ZmxleDogMCAwIDMwdnc7XFxuXFx0bWluLXdpZHRoOiAzMDBweDtcXG5cXG59XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL2NvbXBvbmVudHMvU2lkZWJhci5tb2R1bGUuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0NBQ0MseUNBQXlDO0NBQ3pDLGlCQUFpQjtDQUNqQixjQUFjO0NBQ2QsZ0JBQWdCOztBQUVqQlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuc2lkZWJhciB7XFxuXFx0Ym9yZGVyLWxlZnQ6IDFweCBzb2xpZCByZ2IoMjM2LCAyMzYsIDIzNik7XFxuXFx0cGFkZGluZy1sZWZ0OiAzdnc7XFxuXFx0ZmxleDogMCAwIDMwdnc7XFxuXFx0bWluLXdpZHRoOiAzMDBweDtcXG5cXG59XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwic2lkZWJhclwiOiBcIlNpZGViYXJfc2lkZWJhcl9fRzdNenNcIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/Sidebar.module.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/getUrl.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/getUrl.js ***!
  \***************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nmodule.exports = function(url, options) {\n    if (!options) {\n        // eslint-disable-next-line no-param-reassign\n        options = {};\n    } // eslint-disable-next-line no-underscore-dangle, no-param-reassign\n    url = url && url.__esModule ? url.default : url;\n    if (typeof url !== \"string\") {\n        return url;\n    } // If url is already wrapped in quotes, remove them\n    if (/^['\"].*['\"]$/.test(url)) {\n        // eslint-disable-next-line no-param-reassign\n        url = url.slice(1, -1);\n    }\n    if (options.hash) {\n        // eslint-disable-next-line no-param-reassign\n        url += options.hash;\n    } // Should url be wrapped?\n    // See https://drafts.csswg.org/css-values-3/#urls\n    if (/[\"'() \\t\\n]/.test(url) || options.needQuotes) {\n        return '\"'.concat(url.replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\"), '\"');\n    }\n    return url;\n};\n\n//# sourceMappingURL=getUrl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2dldFVybC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9nZXRVcmwuanM/MGU3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXJsLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGUsIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgdXJsID0gdXJsICYmIHVybC5fX2VzTW9kdWxlID8gdXJsLmRlZmF1bHQgOiB1cmw7XG4gICAgaWYgKHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9IC8vIElmIHVybCBpcyBhbHJlYWR5IHdyYXBwZWQgaW4gcXVvdGVzLCByZW1vdmUgdGhlbVxuICAgIGlmICgvXlsnXCJdLipbJ1wiXSQvLnRlc3QodXJsKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgdXJsID0gdXJsLnNsaWNlKDEsIC0xKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaGFzaCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgdXJsICs9IG9wdGlvbnMuaGFzaDtcbiAgICB9IC8vIFNob3VsZCB1cmwgYmUgd3JhcHBlZD9cbiAgICAvLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtMy8jdXJsc1xuICAgIGlmICgvW1wiJygpIFxcdFxcbl0vLnRlc3QodXJsKSB8fCBvcHRpb25zLm5lZWRRdW90ZXMpIHtcbiAgICAgICAgcmV0dXJuICdcIicuY29uY2F0KHVybC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIiksICdcIicpO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0VXJsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/getUrl.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2FJohnJones%2FDocuments%2FProgramming%2FProjects%2Fpestle%2Fpages%2Findex.js&page=%2F!":
/*!***************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2FJohnJones%2FDocuments%2FProgramming%2FProjects%2Fpestle%2Fpages%2Findex.js&page=%2F! ***!
  \***************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return __webpack_require__(/*! ./pages/index.js */ \"./pages/index.js\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD0lMkZVc2VycyUyRkpvaG5Kb25lcyUyRkRvY3VtZW50cyUyRlByb2dyYW1taW5nJTJGUHJvamVjdHMlMkZwZXN0bGUlMkZwYWdlcyUyRmluZGV4LmpzJnBhZ2U9JTJGISIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDBDQUFrQjtBQUN6QztBQUNBO0FBQ0EsT0FBTyxJQUFVO0FBQ2pCLE1BQU0sVUFBVTtBQUNoQjtBQUNBLE9BQU87QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/NGU2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAod2luZG93Ll9fTkVYVF9QID0gd2luZG93Ll9fTkVYVF9QIHx8IFtdKS5wdXNoKFtcbiAgICAgIFwiL1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZShcIi4vcGFnZXMvaW5kZXguanNcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL1wiXSlcbiAgICAgIH0pO1xuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2FJohnJones%2FDocuments%2FProgramming%2FProjects%2Fpestle%2Fpages%2Findex.js&page=%2F!\n"));

/***/ }),

/***/ "./components/Footer.module.css":
/*!**************************************!*\
  !*** ./components/Footer.module.css ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./Footer.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/Footer.module.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./Footer.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/Footer.module.css\",\n      function () {\n        content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./Footer.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/Footer.module.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0Zvb3Rlci5tb2R1bGUuY3NzIiwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQyxvTkFBd0c7QUFDMUgsMEJBQTBCLG1CQUFPLENBQUMsdWZBQXFQOztBQUV2Ujs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsSUFBSSxJQUFVO0FBQ2QseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksaUJBQWlCO0FBQ3JCLE1BQU0sdWZBQXFQO0FBQzNQO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsdWZBQXFQOztBQUUvUTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsVUFBVTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLFVBQVU7QUFDWjtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0Zvb3Rlci5tb2R1bGUuY3NzPzY1ZTMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLm9uZU9mWzldLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0ub25lT2ZbOV0udXNlWzJdIS4vRm9vdGVyLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIHN0eWxlLWxvYWRlciBpbmplY3RzIENTUyBpbnRvIHRoZSBib3R0b21cbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgPGhlYWQ+LiBUaGlzIGNhdXNlcyBvcmRlcmluZyBwcm9ibGVtcyBiZXR3ZWVuIGRldlxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcHJvZC4gVG8gZml4IHRoaXMsIHdlIHJlbmRlciBhIDxub3NjcmlwdD4gdGFnIGFzXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuIGFuY2hvciBmb3IgdGhlIHN0eWxlcyB0byBiZSBwbGFjZWQgYmVmb3JlLiBUaGVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkIF9iZWZvcmVfIDxzdHlsZSBqc3ggZ2xvYmFsPi5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2hvckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfX1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBhbmNob3JFbGVtZW50LnBhcmVudE5vZGUvLyBOb3JtYWxseSA8aGVhZD5cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIGFuY2hvckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH07XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsIGIsIGlzTmFtZWRFeHBvcnQpIHtcbiAgICBpZiAoIWEgJiYgYiB8fCBhICYmICFiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHA7XG4gICAgZm9yKHAgaW4gYSl7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVtwXSAhPT0gYltwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcihwIGluIGIpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLm9uZU9mWzldLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0ub25lT2ZbOV0udXNlWzJdIS4vRm9vdGVyLm1vZHVsZS5jc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLm9uZU9mWzldLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0ub25lT2ZbOV0udXNlWzJdIS4vRm9vdGVyLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Footer.module.css\n"));

/***/ }),

/***/ "./components/Header.module.css":
/*!**************************************!*\
  !*** ./components/Header.module.css ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./Header.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/Header.module.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./Header.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/Header.module.css\",\n      function () {\n        content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./Header.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/Header.module.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0hlYWRlci5tb2R1bGUuY3NzIiwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQyxvTkFBd0c7QUFDMUgsMEJBQTBCLG1CQUFPLENBQUMsdWZBQXFQOztBQUV2Ujs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsSUFBSSxJQUFVO0FBQ2QseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksaUJBQWlCO0FBQ3JCLE1BQU0sdWZBQXFQO0FBQzNQO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsdWZBQXFQOztBQUUvUTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsVUFBVTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLFVBQVU7QUFDWjtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0hlYWRlci5tb2R1bGUuY3NzP2FhYTkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLm9uZU9mWzldLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0ub25lT2ZbOV0udXNlWzJdIS4vSGVhZGVyLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIHN0eWxlLWxvYWRlciBpbmplY3RzIENTUyBpbnRvIHRoZSBib3R0b21cbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgPGhlYWQ+LiBUaGlzIGNhdXNlcyBvcmRlcmluZyBwcm9ibGVtcyBiZXR3ZWVuIGRldlxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcHJvZC4gVG8gZml4IHRoaXMsIHdlIHJlbmRlciBhIDxub3NjcmlwdD4gdGFnIGFzXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuIGFuY2hvciBmb3IgdGhlIHN0eWxlcyB0byBiZSBwbGFjZWQgYmVmb3JlLiBUaGVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkIF9iZWZvcmVfIDxzdHlsZSBqc3ggZ2xvYmFsPi5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2hvckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfX1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBhbmNob3JFbGVtZW50LnBhcmVudE5vZGUvLyBOb3JtYWxseSA8aGVhZD5cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIGFuY2hvckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH07XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsIGIsIGlzTmFtZWRFeHBvcnQpIHtcbiAgICBpZiAoIWEgJiYgYiB8fCBhICYmICFiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHA7XG4gICAgZm9yKHAgaW4gYSl7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVtwXSAhPT0gYltwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcihwIGluIGIpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLm9uZU9mWzldLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0ub25lT2ZbOV0udXNlWzJdIS4vSGVhZGVyLm1vZHVsZS5jc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLm9uZU9mWzldLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0ub25lT2ZbOV0udXNlWzJdIS4vSGVhZGVyLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Header.module.css\n"));

/***/ }),

/***/ "./components/SVGEditor.module.css":
/*!*****************************************!*\
  !*** ./components/SVGEditor.module.css ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./SVGEditor.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/SVGEditor.module.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./SVGEditor.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/SVGEditor.module.css\",\n      function () {\n        content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./SVGEditor.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/SVGEditor.module.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL1NWR0VkaXRvci5tb2R1bGUuY3NzIiwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQyxvTkFBd0c7QUFDMUgsMEJBQTBCLG1CQUFPLENBQUMsNmZBQXdQOztBQUUxUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsSUFBSSxJQUFVO0FBQ2QseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksaUJBQWlCO0FBQ3JCLE1BQU0sNmZBQXdQO0FBQzlQO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsNmZBQXdQOztBQUVsUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsVUFBVTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLFVBQVU7QUFDWjtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL1NWR0VkaXRvci5tb2R1bGUuY3NzPzk1MGUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLm9uZU9mWzldLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0ub25lT2ZbOV0udXNlWzJdIS4vU1ZHRWRpdG9yLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIHN0eWxlLWxvYWRlciBpbmplY3RzIENTUyBpbnRvIHRoZSBib3R0b21cbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgPGhlYWQ+LiBUaGlzIGNhdXNlcyBvcmRlcmluZyBwcm9ibGVtcyBiZXR3ZWVuIGRldlxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcHJvZC4gVG8gZml4IHRoaXMsIHdlIHJlbmRlciBhIDxub3NjcmlwdD4gdGFnIGFzXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuIGFuY2hvciBmb3IgdGhlIHN0eWxlcyB0byBiZSBwbGFjZWQgYmVmb3JlLiBUaGVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkIF9iZWZvcmVfIDxzdHlsZSBqc3ggZ2xvYmFsPi5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2hvckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfX1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBhbmNob3JFbGVtZW50LnBhcmVudE5vZGUvLyBOb3JtYWxseSA8aGVhZD5cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIGFuY2hvckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH07XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsIGIsIGlzTmFtZWRFeHBvcnQpIHtcbiAgICBpZiAoIWEgJiYgYiB8fCBhICYmICFiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHA7XG4gICAgZm9yKHAgaW4gYSl7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVtwXSAhPT0gYltwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcihwIGluIGIpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLm9uZU9mWzldLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0ub25lT2ZbOV0udXNlWzJdIS4vU1ZHRWRpdG9yLm1vZHVsZS5jc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLm9uZU9mWzldLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0ub25lT2ZbOV0udXNlWzJdIS4vU1ZHRWRpdG9yLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/SVGEditor.module.css\n"));

/***/ }),

/***/ "./components/Sidebar.module.css":
/*!***************************************!*\
  !*** ./components/Sidebar.module.css ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./Sidebar.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/Sidebar.module.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./Sidebar.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/Sidebar.module.css\",\n      function () {\n        content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./Sidebar.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[9].use[2]!./components/Sidebar.module.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL1NpZGViYXIubW9kdWxlLmNzcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsb05BQXdHO0FBQzFILDBCQUEwQixtQkFBTyxDQUFDLHlmQUFzUDs7QUFFeFI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLElBQUksSUFBVTtBQUNkLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGlCQUFpQjtBQUNyQixNQUFNLHlmQUFzUDtBQUM1UDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHlmQUFzUDs7QUFFaFI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFVBQVU7O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxVQUFVO0FBQ1o7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9TaWRlYmFyLm1vZHVsZS5jc3M/OWZmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0ub25lT2ZbOV0udXNlWzFdIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS5vbmVPZls5XS51c2VbMl0hLi9TaWRlYmFyLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIHN0eWxlLWxvYWRlciBpbmplY3RzIENTUyBpbnRvIHRoZSBib3R0b21cbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgPGhlYWQ+LiBUaGlzIGNhdXNlcyBvcmRlcmluZyBwcm9ibGVtcyBiZXR3ZWVuIGRldlxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcHJvZC4gVG8gZml4IHRoaXMsIHdlIHJlbmRlciBhIDxub3NjcmlwdD4gdGFnIGFzXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuIGFuY2hvciBmb3IgdGhlIHN0eWxlcyB0byBiZSBwbGFjZWQgYmVmb3JlLiBUaGVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkIF9iZWZvcmVfIDxzdHlsZSBqc3ggZ2xvYmFsPi5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2hvckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfX1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBhbmNob3JFbGVtZW50LnBhcmVudE5vZGUvLyBOb3JtYWxseSA8aGVhZD5cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIGFuY2hvckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH07XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsIGIsIGlzTmFtZWRFeHBvcnQpIHtcbiAgICBpZiAoIWEgJiYgYiB8fCBhICYmICFiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHA7XG4gICAgZm9yKHAgaW4gYSl7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVtwXSAhPT0gYltwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcihwIGluIGIpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLm9uZU9mWzldLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0ub25lT2ZbOV0udXNlWzJdIS4vU2lkZWJhci5tb2R1bGUuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS5vbmVPZls5XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLm9uZU9mWzldLnVzZVsyXSEuL1NpZGViYXIubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/Sidebar.module.css\n"));

/***/ }),

/***/ "./components/Footer.js":
/*!******************************!*\
  !*** ./components/Footer.js ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Footer; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Footer_module_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Footer.module.css */ \"./components/Footer.module.css\");\n/* harmony import */ var _Footer_module_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Footer_module_css__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction Footer() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"footer\", {\n            className: (_Footer_module_css__WEBPACK_IMPORTED_MODULE_1___default().footer),\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                src: \"/svg/pestle-mortar.svg\",\n                alt: \"Pestle Logo\",\n                className: (_Footer_module_css__WEBPACK_IMPORTED_MODULE_1___default().logo)\n            }, void 0, false, {\n                fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/components/Footer.js\",\n                lineNumber: 8,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/components/Footer.js\",\n            lineNumber: 7,\n            columnNumber: 7\n        }, this)\n    }, void 0, false);\n}\n_c = Footer;\nvar _c;\n$RefreshReg$(_c, \"Footer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0Zvb3Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBd0M7QUFHekIsU0FBU0M7SUFDdEIscUJBQ0U7a0JBQ0UsNEVBQUNDO1lBQU9DLFdBQVdILGtFQUFhO3NCQUM5Qiw0RUFBQ0k7Z0JBQUlDLEtBQUk7Z0JBQXlCQyxLQUFJO2dCQUFjSCxXQUFXSCxnRUFBVzs7Ozs7Ozs7Ozs7O0FBSWxGO0tBUndCQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0Zvb3Rlci5qcz9lMWFiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHlsZXMgZnJvbSAnLi9Gb290ZXIubW9kdWxlLmNzcydcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGb290ZXIoKSB7XG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxmb290ZXIgY2xhc3NOYW1lPXtzdHlsZXMuZm9vdGVyfT5cbiAgICAgICAgPGltZyBzcmM9XCIvc3ZnL3Blc3RsZS1tb3J0YXIuc3ZnXCIgYWx0PVwiUGVzdGxlIExvZ29cIiBjbGFzc05hbWU9e3N0eWxlcy5sb2dvfSAvPlxuICAgICAgPC9mb290ZXI+XG4gICAgPC8+XG4gIClcbn1cbiJdLCJuYW1lcyI6WyJzdHlsZXMiLCJGb290ZXIiLCJmb290ZXIiLCJjbGFzc05hbWUiLCJpbWciLCJzcmMiLCJhbHQiLCJsb2dvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/Footer.js\n"));

/***/ }),

/***/ "./components/Header.js":
/*!******************************!*\
  !*** ./components/Header.js ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Header; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Header_module_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Header.module.css */ \"./components/Header.module.css\");\n/* harmony import */ var _Header_module_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Header_module_css__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction Header(param) {\n    let { title } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n        className: (_Header_module_css__WEBPACK_IMPORTED_MODULE_1___default().title),\n        children: title\n    }, void 0, false, {\n        fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/components/Header.js\",\n        lineNumber: 4,\n        columnNumber: 10\n    }, this);\n}\n_c = Header;\nvar _c;\n$RefreshReg$(_c, \"Header\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0hlYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBeUM7QUFFMUIsU0FBU0MsT0FBTyxLQUFTO1FBQVQsRUFBRUMsS0FBSyxFQUFFLEdBQVQ7SUFDN0IscUJBQU8sOERBQUNDO1FBQUdDLFdBQVdKLGlFQUFZO2tCQUFHRTs7Ozs7O0FBQ3ZDO0tBRndCRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0hlYWRlci5qcz80ZGJiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHlsZXMgZnJvbSAnLi9IZWFkZXIubW9kdWxlLmNzcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhlYWRlcih7IHRpdGxlIH0pIHtcbiAgcmV0dXJuIDxoMSBjbGFzc05hbWU9e3N0eWxlcy50aXRsZX0+e3RpdGxlfTwvaDE+XG59XG4iXSwibmFtZXMiOlsic3R5bGVzIiwiSGVhZGVyIiwidGl0bGUiLCJoMSIsImNsYXNzTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/Header.js\n"));

/***/ }),

/***/ "./components/SVGEditor.jsx":
/*!**********************************!*\
  !*** ./components/SVGEditor.jsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _svgdotjs_svg_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @svgdotjs/svg.js */ \"./node_modules/@svgdotjs/svg.js/dist/svg.esm.js\");\n/* harmony import */ var _SvgContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SvgContext */ \"./components/SvgContext.js\");\n/* harmony import */ var _SVGEditor_module_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SVGEditor.module.css */ \"./components/SVGEditor.module.css\");\n/* harmony import */ var _SVGEditor_module_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_SVGEditor_module_css__WEBPACK_IMPORTED_MODULE_4__);\n\nvar _s = $RefreshSig$();\n\n\n\n\nconst Editor = (param)=>{\n    let { svgImage } = param;\n    _s();\n    const svgRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { svgContent, setSvgContent } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(_SvgContext__WEBPACK_IMPORTED_MODULE_3__.SvgContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Fetch the SVG content\n        fetch(\"/svg/\".concat(svgImage, \".svg\")).then((response)=>response.text()).then((data)=>setSvgContent(data)).catch((error)=>console.error(\"Error loading SVG:\", error));\n    }, [\n        svgImage,\n        setSvgContent\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (svgContent && svgRef.current) {\n            // Clear the existing content\n            const draw = (0,_svgdotjs_svg_js__WEBPACK_IMPORTED_MODULE_2__.SVG)(svgRef.current);\n            draw.clear();\n            // Load the fetched SVG content into the drawing context\n            draw.svg(svgContent);\n        }\n    }, [\n        svgContent\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_SVGEditor_module_css__WEBPACK_IMPORTED_MODULE_4___default().editorContainer),\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            ref: svgRef,\n            className: (_SVGEditor_module_css__WEBPACK_IMPORTED_MODULE_4___default().editor)\n        }, void 0, false, {\n            fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/components/SVGEditor.jsx\",\n            lineNumber: 31,\n            columnNumber: 4\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/components/SVGEditor.jsx\",\n        lineNumber: 30,\n        columnNumber: 3\n    }, undefined);\n};\n_s(Editor, \"3cq33Cqz63QdcLcwXInWLmTQHKw=\");\n_c = Editor;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Editor);\nvar _c;\n$RefreshReg$(_c, \"Editor\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL1NWR0VkaXRvci5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBNkQ7QUFDdEI7QUFDRztBQUNFO0FBRTVDLE1BQU1PLFNBQVM7UUFBQyxFQUFFQyxRQUFRLEVBQUU7O0lBQzNCLE1BQU1DLFNBQVNQLDZDQUFNQSxDQUFDO0lBQ3RCLE1BQU0sRUFBRVEsVUFBVSxFQUFFQyxhQUFhLEVBQUUsR0FBR1IsaURBQVVBLENBQUNFLG1EQUFVQTtJQUUzREosZ0RBQVNBLENBQUM7UUFDVCx3QkFBd0I7UUFDeEJXLE1BQU0sUUFBaUIsT0FBVEosVUFBUyxTQUNyQkssSUFBSSxDQUFDQyxDQUFBQSxXQUFZQSxTQUFTQyxJQUFJLElBQzlCRixJQUFJLENBQUNHLENBQUFBLE9BQVFMLGNBQWNLLE9BQzNCQyxLQUFLLENBQUNDLENBQUFBLFFBQVNDLFFBQVFELEtBQUssQ0FBQyxzQkFBc0JBO0lBQ3RELEdBQUc7UUFBQ1Y7UUFBVUc7S0FBYztJQUU1QlYsZ0RBQVNBLENBQUM7UUFDVCxJQUFJUyxjQUFjRCxPQUFPVyxPQUFPLEVBQUU7WUFDakMsNkJBQTZCO1lBQzdCLE1BQU1DLE9BQU9qQixxREFBR0EsQ0FBQ0ssT0FBT1csT0FBTztZQUMvQkMsS0FBS0MsS0FBSztZQUVWLHdEQUF3RDtZQUN4REQsS0FBS0UsR0FBRyxDQUFDYjtRQUNWO0lBQ0QsR0FBRztRQUFDQTtLQUFXO0lBRWYscUJBQ0MsOERBQUNjO1FBQUlDLFdBQVduQiw4RUFBc0I7a0JBQ3JDLDRFQUFDa0I7WUFBSUcsS0FBS2xCO1lBQVFnQixXQUFXbkIscUVBQWE7Ozs7Ozs7Ozs7O0FBRzdDO0dBNUJNQztLQUFBQTtBQThCTiwrREFBZUEsTUFBTUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL1NWR0VkaXRvci5qc3g/ZGQ5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZUNvbnRleHQgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFNWRyB9IGZyb20gXCJAc3ZnZG90anMvc3ZnLmpzXCI7XG5pbXBvcnQgeyBTdmdDb250ZXh0IH0gZnJvbSBcIi4vU3ZnQ29udGV4dFwiO1xuaW1wb3J0IHN0eWxlcyBmcm9tIFwiLi9TVkdFZGl0b3IubW9kdWxlLmNzc1wiO1xuXG5jb25zdCBFZGl0b3IgPSAoeyBzdmdJbWFnZSB9KSA9PiB7XG5cdGNvbnN0IHN2Z1JlZiA9IHVzZVJlZihudWxsKTtcblx0Y29uc3QgeyBzdmdDb250ZW50LCBzZXRTdmdDb250ZW50IH0gPSB1c2VDb250ZXh0KFN2Z0NvbnRleHQpO1xuXG5cdHVzZUVmZmVjdCgoKSA9PiB7XG5cdFx0Ly8gRmV0Y2ggdGhlIFNWRyBjb250ZW50XG5cdFx0ZmV0Y2goYC9zdmcvJHtzdmdJbWFnZX0uc3ZnYClcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLnRleHQoKSlcblx0XHRcdC50aGVuKGRhdGEgPT4gc2V0U3ZnQ29udGVudChkYXRhKSlcblx0XHRcdC5jYXRjaChlcnJvciA9PiBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIFNWRzonLCBlcnJvcikpO1xuXHR9LCBbc3ZnSW1hZ2UsIHNldFN2Z0NvbnRlbnRdKTtcblxuXHR1c2VFZmZlY3QoKCkgPT4ge1xuXHRcdGlmIChzdmdDb250ZW50ICYmIHN2Z1JlZi5jdXJyZW50KSB7XG5cdFx0XHQvLyBDbGVhciB0aGUgZXhpc3RpbmcgY29udGVudFxuXHRcdFx0Y29uc3QgZHJhdyA9IFNWRyhzdmdSZWYuY3VycmVudCk7XG5cdFx0XHRkcmF3LmNsZWFyKCk7XG5cblx0XHRcdC8vIExvYWQgdGhlIGZldGNoZWQgU1ZHIGNvbnRlbnQgaW50byB0aGUgZHJhd2luZyBjb250ZXh0XG5cdFx0XHRkcmF3LnN2ZyhzdmdDb250ZW50KTtcblx0XHR9XG5cdH0sIFtzdmdDb250ZW50XSk7XG5cblx0cmV0dXJuIChcblx0XHQ8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmVkaXRvckNvbnRhaW5lcn0+XG5cdFx0XHQ8ZGl2IHJlZj17c3ZnUmVmfSBjbGFzc05hbWU9e3N0eWxlcy5lZGl0b3J9IC8+XG5cdFx0PC9kaXY+XG5cdCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBFZGl0b3I7XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VDb250ZXh0IiwiU1ZHIiwiU3ZnQ29udGV4dCIsInN0eWxlcyIsIkVkaXRvciIsInN2Z0ltYWdlIiwic3ZnUmVmIiwic3ZnQ29udGVudCIsInNldFN2Z0NvbnRlbnQiLCJmZXRjaCIsInRoZW4iLCJyZXNwb25zZSIsInRleHQiLCJkYXRhIiwiY2F0Y2giLCJlcnJvciIsImNvbnNvbGUiLCJjdXJyZW50IiwiZHJhdyIsImNsZWFyIiwic3ZnIiwiZGl2IiwiY2xhc3NOYW1lIiwiZWRpdG9yQ29udGFpbmVyIiwicmVmIiwiZWRpdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/SVGEditor.jsx\n"));

/***/ }),

/***/ "./components/Sidebar.jsx":
/*!********************************!*\
  !*** ./components/Sidebar.jsx ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _SvgContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SvgContext */ \"./components/SvgContext.js\");\n/* harmony import */ var _Sidebar_module_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Sidebar.module.css */ \"./components/Sidebar.module.css\");\n/* harmony import */ var _Sidebar_module_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_Sidebar_module_css__WEBPACK_IMPORTED_MODULE_3__);\n\nvar _s = $RefreshSig$();\n\n\n\nconst Sidebar = ()=>{\n    _s();\n    const { config } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(_SvgContext__WEBPACK_IMPORTED_MODULE_2__.SvgContext);\n    const handleInputChange = (selector, property, value)=>{\n        const applyChange = (element)=>{\n            if (element) {\n                element.style[property] = value;\n            }\n        };\n        if (Array.isArray(selector)) {\n            selector.forEach((sel)=>{\n                if (!sel || sel.trim() === \"\") return;\n                const elements = document.querySelectorAll(sel);\n                elements === null || elements === void 0 ? void 0 : elements.forEach(applyChange);\n            });\n        } else {\n            if (!selector || selector.trim() === \"\") return;\n            const elements = document.querySelectorAll(selector);\n            elements === null || elements === void 0 ? void 0 : elements.forEach(applyChange);\n        }\n    };\n    const renderInput = (input, index)=>{\n        switch(input.type){\n            case \"color\":\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                            children: input.label\n                        }, void 0, false, {\n                            fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/components/Sidebar.jsx\",\n                            lineNumber: 33,\n                            columnNumber: 7\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                            type: \"color\",\n                            defaultValue: input.defaultValue,\n                            onInput: (e)=>handleInputChange(input.selector, input.property, e.target.value)\n                        }, void 0, false, {\n                            fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/components/Sidebar.jsx\",\n                            lineNumber: 34,\n                            columnNumber: 7\n                        }, undefined)\n                    ]\n                }, index, true, {\n                    fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/components/Sidebar.jsx\",\n                    lineNumber: 32,\n                    columnNumber: 6\n                }, undefined);\n            case \"range\":\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                            children: input.label\n                        }, void 0, false, {\n                            fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/components/Sidebar.jsx\",\n                            lineNumber: 44,\n                            columnNumber: 7\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                            type: \"range\",\n                            min: input.min,\n                            max: input.max,\n                            step: input.step,\n                            defaultValue: input.defaultValue,\n                            list: input.label,\n                            onInput: (e)=>handleInputChange(input.selector, input.property, \"\".concat(e.target.value, \"px\"))\n                        }, void 0, false, {\n                            fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/components/Sidebar.jsx\",\n                            lineNumber: 45,\n                            columnNumber: 7\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"datalist\", {\n                            id: input.label,\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                value: input.defaultValue\n                            }, void 0, false, {\n                                fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/components/Sidebar.jsx\",\n                                lineNumber: 55,\n                                columnNumber: 8\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/components/Sidebar.jsx\",\n                            lineNumber: 54,\n                            columnNumber: 7\n                        }, undefined)\n                    ]\n                }, index, true, {\n                    fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/components/Sidebar.jsx\",\n                    lineNumber: 43,\n                    columnNumber: 6\n                }, undefined);\n            default:\n                return null;\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_Sidebar_module_css__WEBPACK_IMPORTED_MODULE_3___default().sidebar),\n        children: config === null || config === void 0 ? void 0 : config.inputs.map((input, index)=>renderInput(input, index))\n    }, void 0, false, {\n        fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/components/Sidebar.jsx\",\n        lineNumber: 64,\n        columnNumber: 3\n    }, undefined);\n};\n_s(Sidebar, \"T2vUeAbBksYJAoV2wJzLnuvT9X8=\");\n_c = Sidebar;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Sidebar);\nvar _c;\n$RefreshReg$(_c, \"Sidebar\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL1NpZGViYXIuanN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMEM7QUFDQTtBQUNBO0FBRTFDLE1BQU1JLFVBQVU7O0lBQ2YsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR0osaURBQVVBLENBQUNDLG1EQUFVQTtJQUV4QyxNQUFNSSxvQkFBb0IsQ0FBQ0MsVUFBVUMsVUFBVUM7UUFDOUMsTUFBTUMsY0FBYyxDQUFDQztZQUNwQixJQUFJQSxTQUFTO2dCQUNaQSxRQUFRQyxLQUFLLENBQUNKLFNBQVMsR0FBR0M7WUFDM0I7UUFDRDtRQUVBLElBQUlJLE1BQU1DLE9BQU8sQ0FBQ1AsV0FBVztZQUM1QkEsU0FBU1EsT0FBTyxDQUFDQyxDQUFBQTtnQkFDaEIsSUFBSSxDQUFDQSxPQUFPQSxJQUFJQyxJQUFJLE9BQU8sSUFBSTtnQkFDL0IsTUFBTUMsV0FBV0MsU0FBU0MsZ0JBQWdCLENBQUNKO2dCQUMzQ0UscUJBQUFBLCtCQUFBQSxTQUFVSCxPQUFPLENBQUNMO1lBQ25CO1FBQ0QsT0FBTztZQUNOLElBQUksQ0FBQ0gsWUFBWUEsU0FBU1UsSUFBSSxPQUFPLElBQUk7WUFDekMsTUFBTUMsV0FBV0MsU0FBU0MsZ0JBQWdCLENBQUNiO1lBQzNDVyxxQkFBQUEsK0JBQUFBLFNBQVVILE9BQU8sQ0FBQ0w7UUFDbkI7SUFDRDtJQUVBLE1BQU1XLGNBQWMsQ0FBQ0MsT0FBT0M7UUFDM0IsT0FBUUQsTUFBTUUsSUFBSTtZQUNqQixLQUFLO2dCQUNKLHFCQUNDLDhEQUFDQzs7c0NBQ0EsOERBQUNDO3NDQUFPSixNQUFNSSxLQUFLOzs7Ozs7c0NBQ25CLDhEQUFDSjs0QkFDQUUsTUFBSzs0QkFDTEcsY0FBY0wsTUFBTUssWUFBWTs0QkFDaENDLFNBQVMsQ0FBQ0MsSUFBTXZCLGtCQUFrQmdCLE1BQU1mLFFBQVEsRUFBRWUsTUFBTWQsUUFBUSxFQUFFcUIsRUFBRUMsTUFBTSxDQUFDckIsS0FBSzs7Ozs7OzttQkFMeEVjOzs7OztZQVNaLEtBQUs7Z0JBQ0oscUJBQ0MsOERBQUNFOztzQ0FDQSw4REFBQ0M7c0NBQU9KLE1BQU1JLEtBQUs7Ozs7OztzQ0FDbkIsOERBQUNKOzRCQUNBRSxNQUFLOzRCQUNMTyxLQUFLVCxNQUFNUyxHQUFHOzRCQUNkQyxLQUFLVixNQUFNVSxHQUFHOzRCQUNkQyxNQUFNWCxNQUFNVyxJQUFJOzRCQUNoQk4sY0FBY0wsTUFBTUssWUFBWTs0QkFDaENPLE1BQU1aLE1BQU1JLEtBQUs7NEJBQ2pCRSxTQUFTLENBQUNDLElBQU12QixrQkFBa0JnQixNQUFNZixRQUFRLEVBQUVlLE1BQU1kLFFBQVEsRUFBRSxHQUFrQixPQUFmcUIsRUFBRUMsTUFBTSxDQUFDckIsS0FBSyxFQUFDOzs7Ozs7c0NBRXJGLDhEQUFDMEI7NEJBQVNDLElBQUlkLE1BQU1JLEtBQUs7c0NBQ3hCLDRFQUFDVztnQ0FBTzVCLE9BQU9hLE1BQU1LLFlBQVk7Ozs7Ozs7Ozs7OzttQkFaekJKOzs7OztZQWdCWjtnQkFBUyxPQUFPO1FBQ2pCO0lBQ0Q7SUFFQSxxQkFDQyw4REFBQ0U7UUFBSWEsV0FBV25DLG9FQUFjO2tCQUM1QkUsbUJBQUFBLDZCQUFBQSxPQUFRbUMsTUFBTSxDQUFDQyxHQUFHLENBQUMsQ0FBQ25CLE9BQU9DLFFBQVVGLFlBQVlDLE9BQU9DOzs7Ozs7QUFHNUQ7R0EvRE1uQjtLQUFBQTtBQWlFTiwrREFBZUEsT0FBT0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL1NpZGViYXIuanN4PzRjYjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFN2Z0NvbnRleHQgfSBmcm9tIFwiLi9TdmdDb250ZXh0XCI7XG5pbXBvcnQgc3R5bGVzIGZyb20gXCIuL1NpZGViYXIubW9kdWxlLmNzc1wiO1xuXG5jb25zdCBTaWRlYmFyID0gKCkgPT4ge1xuXHRjb25zdCB7IGNvbmZpZyB9ID0gdXNlQ29udGV4dChTdmdDb250ZXh0KTtcblxuXHRjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IChzZWxlY3RvciwgcHJvcGVydHksIHZhbHVlKSA9PiB7XG5cdFx0Y29uc3QgYXBwbHlDaGFuZ2UgPSAoZWxlbWVudCkgPT4ge1xuXHRcdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdFx0ZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoc2VsZWN0b3IpKSB7XG5cdFx0XHRzZWxlY3Rvci5mb3JFYWNoKHNlbCA9PiB7XG5cdFx0XHRcdGlmICghc2VsIHx8IHNlbC50cmltKCkgPT09ICcnKSByZXR1cm47XG5cdFx0XHRcdGNvbnN0IGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWwpO1xuXHRcdFx0XHRlbGVtZW50cz8uZm9yRWFjaChhcHBseUNoYW5nZSk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCFzZWxlY3RvciB8fCBzZWxlY3Rvci50cmltKCkgPT09ICcnKSByZXR1cm47XG5cdFx0XHRjb25zdCBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuXHRcdFx0ZWxlbWVudHM/LmZvckVhY2goYXBwbHlDaGFuZ2UpO1xuXHRcdH1cblx0fTtcblxuXHRjb25zdCByZW5kZXJJbnB1dCA9IChpbnB1dCwgaW5kZXgpID0+IHtcblx0XHRzd2l0Y2ggKGlucHV0LnR5cGUpIHtcblx0XHRcdGNhc2UgJ2NvbG9yJzpcblx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHQ8ZGl2IGtleT17aW5kZXh9PlxuXHRcdFx0XHRcdFx0PGxhYmVsPntpbnB1dC5sYWJlbH08L2xhYmVsPlxuXHRcdFx0XHRcdFx0PGlucHV0XG5cdFx0XHRcdFx0XHRcdHR5cGU9XCJjb2xvclwiXG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17aW5wdXQuZGVmYXVsdFZhbHVlfVxuXHRcdFx0XHRcdFx0XHRvbklucHV0PXsoZSkgPT4gaGFuZGxlSW5wdXRDaGFuZ2UoaW5wdXQuc2VsZWN0b3IsIGlucHV0LnByb3BlcnR5LCBlLnRhcmdldC52YWx1ZSl9XG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQpO1xuXHRcdFx0Y2FzZSAncmFuZ2UnOlxuXHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdDxkaXYga2V5PXtpbmRleH0+XG5cdFx0XHRcdFx0XHQ8bGFiZWw+e2lucHV0LmxhYmVsfTwvbGFiZWw+XG5cdFx0XHRcdFx0XHQ8aW5wdXRcblx0XHRcdFx0XHRcdFx0dHlwZT1cInJhbmdlXCJcblx0XHRcdFx0XHRcdFx0bWluPXtpbnB1dC5taW59XG5cdFx0XHRcdFx0XHRcdG1heD17aW5wdXQubWF4fVxuXHRcdFx0XHRcdFx0XHRzdGVwPXtpbnB1dC5zdGVwfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2lucHV0LmRlZmF1bHRWYWx1ZX1cblx0XHRcdFx0XHRcdFx0bGlzdD17aW5wdXQubGFiZWx9XG5cdFx0XHRcdFx0XHRcdG9uSW5wdXQ9eyhlKSA9PiBoYW5kbGVJbnB1dENoYW5nZShpbnB1dC5zZWxlY3RvciwgaW5wdXQucHJvcGVydHksIGAke2UudGFyZ2V0LnZhbHVlfXB4YCl9XG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0PGRhdGFsaXN0IGlkPXtpbnB1dC5sYWJlbH0+XG5cdFx0XHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9e2lucHV0LmRlZmF1bHRWYWx1ZX0+PC9vcHRpb24+XG5cdFx0XHRcdFx0XHQ8L2RhdGFsaXN0PlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQpO1xuXHRcdFx0ZGVmYXVsdDogcmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiAoXG5cdFx0PGRpdiBjbGFzc05hbWU9e3N0eWxlcy5zaWRlYmFyfSA+XG5cdFx0XHR7Y29uZmlnPy5pbnB1dHMubWFwKChpbnB1dCwgaW5kZXgpID0+IHJlbmRlcklucHV0KGlucHV0LCBpbmRleCkpfVxuXHRcdDwvZGl2PlxuXHQpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgU2lkZWJhcjtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUNvbnRleHQiLCJTdmdDb250ZXh0Iiwic3R5bGVzIiwiU2lkZWJhciIsImNvbmZpZyIsImhhbmRsZUlucHV0Q2hhbmdlIiwic2VsZWN0b3IiLCJwcm9wZXJ0eSIsInZhbHVlIiwiYXBwbHlDaGFuZ2UiLCJlbGVtZW50Iiwic3R5bGUiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwic2VsIiwidHJpbSIsImVsZW1lbnRzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwicmVuZGVySW5wdXQiLCJpbnB1dCIsImluZGV4IiwidHlwZSIsImRpdiIsImxhYmVsIiwiZGVmYXVsdFZhbHVlIiwib25JbnB1dCIsImUiLCJ0YXJnZXQiLCJtaW4iLCJtYXgiLCJzdGVwIiwibGlzdCIsImRhdGFsaXN0IiwiaWQiLCJvcHRpb24iLCJjbGFzc05hbWUiLCJzaWRlYmFyIiwiaW5wdXRzIiwibWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/Sidebar.jsx\n"));

/***/ }),

/***/ "./components/SvgContext.js":
/*!**********************************!*\
  !*** ./components/SvgContext.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SvgContext: function() { return /* binding */ SvgContext; },\n/* harmony export */   SvgProvider: function() { return /* binding */ SvgProvider; },\n/* harmony export */   useSvg: function() { return /* binding */ useSvg; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n// Create a context\nconst SvgContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)();\n// Create a provider component\nconst SvgProvider = (param)=>{\n    let { children, initialConfig } = param;\n    _s();\n    const [svgContent, setSvgContent] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [config, setConfig] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialConfig);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(SvgContext.Provider, {\n        value: {\n            svgContent,\n            setSvgContent,\n            config,\n            setConfig\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/components/SvgContext.js\",\n        lineNumber: 12,\n        columnNumber: 3\n    }, undefined);\n};\n_s(SvgProvider, \"o4mEHsHjI+IUKejXhKwCiL8hFLg=\");\n_c = SvgProvider;\n// Create a custom hook to use the SVG context\nconst useSvg = ()=>{\n    _s1();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(SvgContext);\n};\n_s1(useSvg, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar _c;\n$RefreshReg$(_c, \"SvgProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL1N2Z0NvbnRleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQTREO0FBRTVELG1CQUFtQjtBQUNaLE1BQU1HLDJCQUFhSCxvREFBYUEsR0FBRztBQUUxQyw4QkFBOEI7QUFDdkIsTUFBTUksY0FBYztRQUFDLEVBQUVDLFFBQVEsRUFBRUMsYUFBYSxFQUFFOztJQUN0RCxNQUFNLENBQUNDLFlBQVlDLGNBQWMsR0FBR04sK0NBQVFBLENBQUM7SUFDN0MsTUFBTSxDQUFDTyxRQUFRQyxVQUFVLEdBQUdSLCtDQUFRQSxDQUFDSTtJQUVyQyxxQkFDQyw4REFBQ0gsV0FBV1EsUUFBUTtRQUFDQyxPQUFPO1lBQUVMO1lBQVlDO1lBQWVDO1lBQVFDO1FBQVU7a0JBQ3pFTDs7Ozs7O0FBR0osRUFBRTtHQVRXRDtLQUFBQTtBQVdiLDhDQUE4QztBQUN2QyxNQUFNUyxTQUFTOztJQUFNWixPQUFBQSxpREFBVUEsQ0FBQ0U7QUFBVSxFQUFFO0lBQXRDVSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL1N2Z0NvbnRleHQuanM/M2FjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuLy8gQ3JlYXRlIGEgY29udGV4dFxuZXhwb3J0IGNvbnN0IFN2Z0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KCk7XG5cbi8vIENyZWF0ZSBhIHByb3ZpZGVyIGNvbXBvbmVudFxuZXhwb3J0IGNvbnN0IFN2Z1Byb3ZpZGVyID0gKHsgY2hpbGRyZW4sIGluaXRpYWxDb25maWcgfSkgPT4ge1xuXHRjb25zdCBbc3ZnQ29udGVudCwgc2V0U3ZnQ29udGVudF0gPSB1c2VTdGF0ZShudWxsKTtcblx0Y29uc3QgW2NvbmZpZywgc2V0Q29uZmlnXSA9IHVzZVN0YXRlKGluaXRpYWxDb25maWcpO1xuXG5cdHJldHVybiAoXG5cdFx0PFN2Z0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3sgc3ZnQ29udGVudCwgc2V0U3ZnQ29udGVudCwgY29uZmlnLCBzZXRDb25maWcgfX0+XG5cdFx0XHR7Y2hpbGRyZW59XG5cdFx0PC9TdmdDb250ZXh0LlByb3ZpZGVyPlxuXHQpO1xufTtcblxuLy8gQ3JlYXRlIGEgY3VzdG9tIGhvb2sgdG8gdXNlIHRoZSBTVkcgY29udGV4dFxuZXhwb3J0IGNvbnN0IHVzZVN2ZyA9ICgpID0+IHVzZUNvbnRleHQoU3ZnQ29udGV4dCk7XG4iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsIlN2Z0NvbnRleHQiLCJTdmdQcm92aWRlciIsImNoaWxkcmVuIiwiaW5pdGlhbENvbmZpZyIsInN2Z0NvbnRlbnQiLCJzZXRTdmdDb250ZW50IiwiY29uZmlnIiwic2V0Q29uZmlnIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZVN2ZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/SvgContext.js\n"));

/***/ }),

/***/ "./config/classTable.js":
/*!******************************!*\
  !*** ./config/classTable.js ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nconst config = {\n    \"hiddenElements\": [\n        \"#text\",\n        \"#rows\"\n    ],\n    \"inputs\": [\n        {\n            \"label\": \"Outer Stroke Color\",\n            \"type\": \"color\",\n            \"selector\": \"#outer-color-frame > *\",\n            \"property\": \"stroke\",\n            \"defaultValue\": \"#f2ce4a\"\n        },\n        {\n            \"label\": \"Inner Stroke Color\",\n            \"type\": \"color\",\n            \"selector\": [\n                \"#inner-color-frame > *\",\n                \"#inner-color-frame-circles > *\"\n            ],\n            \"property\": \"stroke\",\n            \"defaultValue\": \"#141414\"\n        },\n        {\n            \"label\": \"Outer Stroke Width\",\n            \"type\": \"range\",\n            \"selector\": \"#outer-color-frame > *\",\n            \"property\": \"stroke-width\",\n            \"min\": 0,\n            \"max\": 20,\n            \"step\": 0.2,\n            \"defaultValue\": 15\n        },\n        {\n            \"label\": \"Inner Stroke Width\",\n            \"type\": \"range\",\n            \"selector\": \"#inner-color-frame > *\",\n            \"property\": \"stroke-width\",\n            \"min\": 0,\n            \"max\": 20,\n            \"step\": 0.2,\n            \"defaultValue\": 8\n        },\n        {\n            \"label\": \"Inside Color\",\n            \"type\": \"color\",\n            \"selector\": \"#frame-body\",\n            \"property\": \"fill\",\n            \"defaultValue\": \"#FFF\"\n        },\n        {\n            \"label\": \"Text Color\",\n            \"type\": \"color\",\n            \"selector\": \"text\",\n            \"property\": \"fill\",\n            \"defaultValue\": \"#000\"\n        },\n        {\n            \"label\": \"Row Color\",\n            \"type\": \"color\",\n            \"selector\": \"#rows > *\",\n            \"property\": \"fill\",\n            \"defaultValue\": \"#D4F7A1\"\n        }\n    ]\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (config);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb25maWcvY2xhc3NUYWJsZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsU0FBUztJQUNkLGtCQUFrQjtRQUFDO1FBQVM7S0FBUTtJQUNwQyxVQUFVO1FBQ1Q7WUFDQyxTQUFTO1lBQ1QsUUFBUTtZQUNSLFlBQVk7WUFDWixZQUFZO1lBQ1osZ0JBQWlCO1FBQ2xCO1FBQ0E7WUFDQyxTQUFTO1lBQ1QsUUFBUTtZQUNSLFlBQVk7Z0JBQUM7Z0JBQTBCO2FBQWlDO1lBQ3hFLFlBQVk7WUFDWixnQkFBaUI7UUFDbEI7UUFDQTtZQUNDLFNBQVM7WUFDVCxRQUFRO1lBQ1IsWUFBWTtZQUNaLFlBQVk7WUFDWixPQUFPO1lBQ1AsT0FBTztZQUNQLFFBQVE7WUFDUixnQkFBZ0I7UUFDakI7UUFDQTtZQUNDLFNBQVM7WUFDVCxRQUFRO1lBQ1IsWUFBWTtZQUNaLFlBQVk7WUFDWixPQUFPO1lBQ1AsT0FBTztZQUNQLFFBQVE7WUFDUixnQkFBZ0I7UUFDakI7UUFDQTtZQUNDLFNBQVM7WUFDVCxRQUFRO1lBQ1IsWUFBWTtZQUNaLFlBQVk7WUFDWixnQkFBZ0I7UUFDakI7UUFDQTtZQUNDLFNBQVM7WUFDVCxRQUFRO1lBQ1IsWUFBWTtZQUNaLFlBQVk7WUFDWixnQkFBZ0I7UUFDakI7UUFDQTtZQUNDLFNBQVM7WUFDVCxRQUFRO1lBQ1IsWUFBWTtZQUNaLFlBQVk7WUFDWixnQkFBZ0I7UUFDakI7S0FDQTtBQUNGO0FBRUEsK0RBQWVBLE1BQU1BLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29uZmlnL2NsYXNzVGFibGUuanM/Mzk1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb25maWcgPSB7XG5cdFwiaGlkZGVuRWxlbWVudHNcIjogWycjdGV4dCcsICcjcm93cyddLFxuXHRcImlucHV0c1wiOiBbXG5cdFx0e1xuXHRcdFx0XCJsYWJlbFwiOiBcIk91dGVyIFN0cm9rZSBDb2xvclwiLFxuXHRcdFx0XCJ0eXBlXCI6IFwiY29sb3JcIixcblx0XHRcdFwic2VsZWN0b3JcIjogXCIjb3V0ZXItY29sb3ItZnJhbWUgPiAqXCIsXG5cdFx0XHRcInByb3BlcnR5XCI6IFwic3Ryb2tlXCIsXG5cdFx0XHRcImRlZmF1bHRWYWx1ZVwiIDogXCIjZjJjZTRhXCIsXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRcImxhYmVsXCI6IFwiSW5uZXIgU3Ryb2tlIENvbG9yXCIsXG5cdFx0XHRcInR5cGVcIjogXCJjb2xvclwiLFxuXHRcdFx0XCJzZWxlY3RvclwiOiBbXCIjaW5uZXItY29sb3ItZnJhbWUgPiAqXCIsIFwiI2lubmVyLWNvbG9yLWZyYW1lLWNpcmNsZXMgPiAqXCJdLFxuXHRcdFx0XCJwcm9wZXJ0eVwiOiBcInN0cm9rZVwiLFxuXHRcdFx0XCJkZWZhdWx0VmFsdWVcIiA6IFwiIzE0MTQxNFwiXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRcImxhYmVsXCI6IFwiT3V0ZXIgU3Ryb2tlIFdpZHRoXCIsXG5cdFx0XHRcInR5cGVcIjogXCJyYW5nZVwiLFxuXHRcdFx0XCJzZWxlY3RvclwiOiBcIiNvdXRlci1jb2xvci1mcmFtZSA+ICpcIixcblx0XHRcdFwicHJvcGVydHlcIjogXCJzdHJva2Utd2lkdGhcIixcblx0XHRcdFwibWluXCI6IDAsXG5cdFx0XHRcIm1heFwiOiAyMCxcblx0XHRcdFwic3RlcFwiOiAwLjIsXG5cdFx0XHRcImRlZmF1bHRWYWx1ZVwiOiAxNVxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0XCJsYWJlbFwiOiBcIklubmVyIFN0cm9rZSBXaWR0aFwiLFxuXHRcdFx0XCJ0eXBlXCI6IFwicmFuZ2VcIixcblx0XHRcdFwic2VsZWN0b3JcIjogXCIjaW5uZXItY29sb3ItZnJhbWUgPiAqXCIsXG5cdFx0XHRcInByb3BlcnR5XCI6IFwic3Ryb2tlLXdpZHRoXCIsXG5cdFx0XHRcIm1pblwiOiAwLFxuXHRcdFx0XCJtYXhcIjogMjAsXG5cdFx0XHRcInN0ZXBcIjogMC4yLFxuXHRcdFx0XCJkZWZhdWx0VmFsdWVcIjogOFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0XCJsYWJlbFwiOiBcIkluc2lkZSBDb2xvclwiLFxuXHRcdFx0XCJ0eXBlXCI6IFwiY29sb3JcIixcblx0XHRcdFwic2VsZWN0b3JcIjogXCIjZnJhbWUtYm9keVwiLFxuXHRcdFx0XCJwcm9wZXJ0eVwiOiBcImZpbGxcIixcblx0XHRcdFwiZGVmYXVsdFZhbHVlXCI6IFwiI0ZGRlwiXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRcImxhYmVsXCI6IFwiVGV4dCBDb2xvclwiLFxuXHRcdFx0XCJ0eXBlXCI6IFwiY29sb3JcIixcblx0XHRcdFwic2VsZWN0b3JcIjogXCJ0ZXh0XCIsXG5cdFx0XHRcInByb3BlcnR5XCI6IFwiZmlsbFwiLFxuXHRcdFx0XCJkZWZhdWx0VmFsdWVcIjogXCIjMDAwXCJcblx0XHR9LFxuXHRcdHtcblx0XHRcdFwibGFiZWxcIjogXCJSb3cgQ29sb3JcIixcblx0XHRcdFwidHlwZVwiOiBcImNvbG9yXCIsXG5cdFx0XHRcInNlbGVjdG9yXCI6IFwiI3Jvd3MgPiAqXCIsXG5cdFx0XHRcInByb3BlcnR5XCI6IFwiZmlsbFwiLFxuXHRcdFx0XCJkZWZhdWx0VmFsdWVcIjogXCIjRDRGN0ExXCJcblx0XHR9XG5cdF1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY29uZmlnO1xuIl0sIm5hbWVzIjpbImNvbmZpZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./config/classTable.js\n"));

/***/ }),

/***/ "./config/noteFrame.js":
/*!*****************************!*\
  !*** ./config/noteFrame.js ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nconst config = {\n    \"hiddenElements\": [\n        \"#body\"\n    ],\n    \"inputs\": [\n        {\n            \"label\": \"Frame Color\",\n            \"type\": \"color\",\n            \"selector\": [\n                \"#top-curve\",\n                \"#bottom-curve\"\n            ],\n            \"property\": \"fill\",\n            \"defaultValue\": \"#000\"\n        },\n        {\n            \"label\": \"Body Color\",\n            \"type\": \"color\",\n            \"selector\": \"#background\",\n            \"property\": \"fill\",\n            \"defaultValue\": \"#D3D99F\"\n        },\n        {\n            \"label\": \"Text Color\",\n            \"type\": \"color\",\n            \"selector\": \"#body-text > text\",\n            \"property\": \"fill\",\n            \"defaultValue\": \"#000\"\n        }\n    ]\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (config);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb25maWcvbm90ZUZyYW1lLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxTQUFTO0lBQ2Qsa0JBQWtCO1FBQUM7S0FBUTtJQUMzQixVQUFXO1FBQ1Y7WUFDQyxTQUFVO1lBQ1YsUUFBUztZQUNULFlBQWE7Z0JBQUM7Z0JBQWM7YUFBZ0I7WUFDNUMsWUFBYTtZQUNiLGdCQUFpQjtRQUNsQjtRQUNBO1lBQ0MsU0FBVTtZQUNWLFFBQVM7WUFDVCxZQUFhO1lBQ2IsWUFBYTtZQUNiLGdCQUFpQjtRQUNsQjtRQUNBO1lBQ0MsU0FBVTtZQUNWLFFBQVM7WUFDVCxZQUFhO1lBQ2IsWUFBYTtZQUNiLGdCQUFpQjtRQUNsQjtLQUNBO0FBQ0Y7QUFFQSwrREFBZUEsTUFBTUEsRUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb25maWcvbm90ZUZyYW1lLmpzP2YxNTMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29uZmlnID0ge1xuXHRcImhpZGRlbkVsZW1lbnRzXCI6IFsnI2JvZHknXSxcblx0XCJpbnB1dHNcIiA6IFtcblx0XHR7XG5cdFx0XHRcImxhYmVsXCIgOiBcIkZyYW1lIENvbG9yXCIsXG5cdFx0XHRcInR5cGVcIiA6IFwiY29sb3JcIixcblx0XHRcdFwic2VsZWN0b3JcIiA6IFtcIiN0b3AtY3VydmVcIiwgXCIjYm90dG9tLWN1cnZlXCJdLFxuXHRcdFx0XCJwcm9wZXJ0eVwiIDogXCJmaWxsXCIsXG5cdFx0XHRcImRlZmF1bHRWYWx1ZVwiIDogXCIjMDAwXCJcblx0XHR9LFxuXHRcdHtcblx0XHRcdFwibGFiZWxcIiA6IFwiQm9keSBDb2xvclwiLFxuXHRcdFx0XCJ0eXBlXCIgOiBcImNvbG9yXCIsXG5cdFx0XHRcInNlbGVjdG9yXCIgOiBcIiNiYWNrZ3JvdW5kXCIsXG5cdFx0XHRcInByb3BlcnR5XCIgOiBcImZpbGxcIixcblx0XHRcdFwiZGVmYXVsdFZhbHVlXCIgOiBcIiNEM0Q5OUZcIlxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0XCJsYWJlbFwiIDogXCJUZXh0IENvbG9yXCIsXG5cdFx0XHRcInR5cGVcIiA6IFwiY29sb3JcIixcblx0XHRcdFwic2VsZWN0b3JcIiA6IFwiI2JvZHktdGV4dCA+IHRleHRcIixcblx0XHRcdFwicHJvcGVydHlcIiA6IFwiZmlsbFwiLFxuXHRcdFx0XCJkZWZhdWx0VmFsdWVcIiA6IFwiIzAwMFwiXG5cdFx0fVxuXHRdXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbmZpZyJdLCJuYW1lcyI6WyJjb25maWciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./config/noteFrame.js\n"));

/***/ }),

/***/ "./pages/index.js":
/*!************************!*\
  !*** ./pages/index.js ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_Header__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @components/Header */ \"./components/Header.js\");\n/* harmony import */ var _components_Footer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @components/Footer */ \"./components/Footer.js\");\n/* harmony import */ var _components_SVGEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @components/SVGEditor */ \"./components/SVGEditor.jsx\");\n/* harmony import */ var _components_Sidebar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @components/Sidebar */ \"./components/Sidebar.jsx\");\n/* harmony import */ var _components_SvgContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @components/SvgContext */ \"./components/SvgContext.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _config_classTable_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../config/classTable.js */ \"./config/classTable.js\");\n/* harmony import */ var _config_noteFrame_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../config/noteFrame.js */ \"./config/noteFrame.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\nconst svgConfigs = {\n    classTable: _config_classTable_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"],\n    noteFrame: _config_noteFrame_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]\n};\nfunction Home() {\n    _s();\n    const [svgImage, setSvgImage] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(\"classTable\");\n    const [config, setConfig] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(svgConfigs[\"classTable\"]);\n    const handleSvgSelect = (evt)=>{\n        const selectedSvg = evt.target.value;\n        setSvgImage(selectedSvg);\n        setConfig(svgConfigs[selectedSvg]);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_SvgContext__WEBPACK_IMPORTED_MODULE_6__.SvgProvider, {\n        initialConfig: config,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"container\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_1___default()), {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                            children: \"Pestle\"\n                        }, void 0, false, {\n                            fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/pages/index.js\",\n                            lineNumber: 31,\n                            columnNumber: 6\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                            rel: \"icon\",\n                            href: \"/favicon.ico\"\n                        }, void 0, false, {\n                            fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/pages/index.js\",\n                            lineNumber: 32,\n                            columnNumber: 6\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/pages/index.js\",\n                    lineNumber: 30,\n                    columnNumber: 5\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Header__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                            title: \"Pestle\"\n                        }, void 0, false, {\n                            fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/pages/index.js\",\n                            lineNumber: 36,\n                            columnNumber: 6\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n                            onChange: handleSvgSelect,\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                    value: \"classTable\",\n                                    children: \"Class Table\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/pages/index.js\",\n                                    lineNumber: 39,\n                                    columnNumber: 7\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                    value: \"noteFrame\",\n                                    children: \"Note\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/pages/index.js\",\n                                    lineNumber: 40,\n                                    columnNumber: 7\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/pages/index.js\",\n                            lineNumber: 38,\n                            columnNumber: 6\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"layout\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_SVGEditor__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                                    svgImage: svgImage\n                                }, void 0, false, {\n                                    fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/pages/index.js\",\n                                    lineNumber: 44,\n                                    columnNumber: 7\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Sidebar__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {}, void 0, false, {\n                                    fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/pages/index.js\",\n                                    lineNumber: 45,\n                                    columnNumber: 7\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/pages/index.js\",\n                            lineNumber: 43,\n                            columnNumber: 6\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/pages/index.js\",\n                    lineNumber: 35,\n                    columnNumber: 5\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Footer__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n                    fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/pages/index.js\",\n                    lineNumber: 49,\n                    columnNumber: 5\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/pages/index.js\",\n            lineNumber: 29,\n            columnNumber: 4\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/JohnJones/Documents/Programming/Projects/pestle/pages/index.js\",\n        lineNumber: 28,\n        columnNumber: 3\n    }, this);\n}\n_s(Home, \"UXl1Ipc5xfEpkPGl7w2VPI5uiHs=\");\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZCO0FBQ1c7QUFDQTtBQUNHO0FBQ0Q7QUFDbUI7QUFDakI7QUFFVztBQUNGO0FBRXJELE1BQU1XLGFBQWE7SUFDbEJDLFlBQVlILDZEQUFnQkE7SUFDNUJJLFdBQVdILDREQUFlQTtBQUMzQjtBQUVlLFNBQVNJOztJQUN2QixNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR1QsK0NBQVFBLENBQUM7SUFDekMsTUFBTSxDQUFDVSxRQUFRQyxVQUFVLEdBQUdYLCtDQUFRQSxDQUFDSSxVQUFVLENBQUMsYUFBYTtJQUU3RCxNQUFNUSxrQkFBa0IsQ0FBQ0M7UUFDeEIsTUFBTUMsY0FBY0QsSUFBSUUsTUFBTSxDQUFDQyxLQUFLO1FBQ3BDUCxZQUFZSztRQUNaSCxVQUFVUCxVQUFVLENBQUNVLFlBQVk7SUFDbEM7SUFFQSxxQkFDQyw4REFBQ2hCLCtEQUFXQTtRQUFDbUIsZUFBZVA7a0JBQzNCLDRFQUFDUTtZQUFJQyxXQUFVOzs4QkFDZCw4REFBQzFCLGtEQUFJQTs7c0NBQ0osOERBQUMyQjtzQ0FBTTs7Ozs7O3NDQUNQLDhEQUFDQzs0QkFBS0MsS0FBSTs0QkFBT0MsTUFBSzs7Ozs7Ozs7Ozs7OzhCQUd2Qiw4REFBQ0M7O3NDQUNBLDhEQUFDOUIsMERBQU1BOzRCQUFDMEIsT0FBTTs7Ozs7O3NDQUVkLDhEQUFDSzs0QkFBT0MsVUFBVWQ7OzhDQUNqQiw4REFBQ2U7b0NBQU9YLE9BQU07OENBQWE7Ozs7Ozs4Q0FDM0IsOERBQUNXO29DQUFPWCxPQUFNOzhDQUFZOzs7Ozs7Ozs7Ozs7c0NBRzNCLDhEQUFDRTs0QkFBSUMsV0FBVTs7OENBQ2QsOERBQUN2Qiw2REFBTUE7b0NBQUNZLFVBQVVBOzs7Ozs7OENBQ2xCLDhEQUFDWCwyREFBT0E7Ozs7Ozs7Ozs7Ozs7Ozs7OzhCQUlWLDhEQUFDRiwwREFBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJWDtHQXBDd0JZO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3BhZ2VzL2luZGV4LmpzP2JlZTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEhlYWQgZnJvbSAnbmV4dC9oZWFkJztcbmltcG9ydCBIZWFkZXIgZnJvbSAnQGNvbXBvbmVudHMvSGVhZGVyJztcbmltcG9ydCBGb290ZXIgZnJvbSAnQGNvbXBvbmVudHMvRm9vdGVyJztcbmltcG9ydCBFZGl0b3IgZnJvbSAnQGNvbXBvbmVudHMvU1ZHRWRpdG9yJztcbmltcG9ydCBTaWRlYmFyIGZyb20gJ0Bjb21wb25lbnRzL1NpZGViYXInO1xuaW1wb3J0IHsgU3ZnUHJvdmlkZXIsIHVzZVN2ZyB9IGZyb20gJ0Bjb21wb25lbnRzL1N2Z0NvbnRleHQnO1xuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IGNsYXNzVGFibGVDb25maWcgZnJvbSAnLi4vY29uZmlnL2NsYXNzVGFibGUuanMnO1xuaW1wb3J0IG5vdGVGcmFtZUNvbmZpZyBmcm9tICcuLi9jb25maWcvbm90ZUZyYW1lLmpzJztcblxuY29uc3Qgc3ZnQ29uZmlncyA9IHtcblx0Y2xhc3NUYWJsZTogY2xhc3NUYWJsZUNvbmZpZyxcblx0bm90ZUZyYW1lOiBub3RlRnJhbWVDb25maWcsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIb21lKCkge1xuXHRjb25zdCBbc3ZnSW1hZ2UsIHNldFN2Z0ltYWdlXSA9IHVzZVN0YXRlKCdjbGFzc1RhYmxlJyk7XG5cdGNvbnN0IFtjb25maWcsIHNldENvbmZpZ10gPSB1c2VTdGF0ZShzdmdDb25maWdzWydjbGFzc1RhYmxlJ10pO1xuXG5cdGNvbnN0IGhhbmRsZVN2Z1NlbGVjdCA9IChldnQpID0+IHtcblx0XHRjb25zdCBzZWxlY3RlZFN2ZyA9IGV2dC50YXJnZXQudmFsdWU7XG5cdFx0c2V0U3ZnSW1hZ2Uoc2VsZWN0ZWRTdmcpO1xuXHRcdHNldENvbmZpZyhzdmdDb25maWdzW3NlbGVjdGVkU3ZnXSk7XG5cdH07XG5cblx0cmV0dXJuIChcblx0XHQ8U3ZnUHJvdmlkZXIgaW5pdGlhbENvbmZpZz17Y29uZmlnfT5cblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiY29udGFpbmVyXCI+XG5cdFx0XHRcdDxIZWFkPlxuXHRcdFx0XHRcdDx0aXRsZT5QZXN0bGU8L3RpdGxlPlxuXHRcdFx0XHRcdDxsaW5rIHJlbD1cImljb25cIiBocmVmPVwiL2Zhdmljb24uaWNvXCIgLz5cblx0XHRcdFx0PC9IZWFkPlxuXG5cdFx0XHRcdDxtYWluPlxuXHRcdFx0XHRcdDxIZWFkZXIgdGl0bGU9XCJQZXN0bGVcIiAvPlxuXG5cdFx0XHRcdFx0PHNlbGVjdCBvbkNoYW5nZT17aGFuZGxlU3ZnU2VsZWN0fT5cblx0XHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9J2NsYXNzVGFibGUnPkNsYXNzIFRhYmxlPC9vcHRpb24+XG5cdFx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPSdub3RlRnJhbWUnPk5vdGU8L29wdGlvbj5cblx0XHRcdFx0XHQ8L3NlbGVjdD5cblxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwibGF5b3V0XCI+XG5cdFx0XHRcdFx0XHQ8RWRpdG9yIHN2Z0ltYWdlPXtzdmdJbWFnZX0gLz5cblx0XHRcdFx0XHRcdDxTaWRlYmFyIC8+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvbWFpbj5cblxuXHRcdFx0XHQ8Rm9vdGVyIC8+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L1N2Z1Byb3ZpZGVyPlxuXHQpO1xufVxuIl0sIm5hbWVzIjpbIkhlYWQiLCJIZWFkZXIiLCJGb290ZXIiLCJFZGl0b3IiLCJTaWRlYmFyIiwiU3ZnUHJvdmlkZXIiLCJ1c2VTdmciLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImNsYXNzVGFibGVDb25maWciLCJub3RlRnJhbWVDb25maWciLCJzdmdDb25maWdzIiwiY2xhc3NUYWJsZSIsIm5vdGVGcmFtZSIsIkhvbWUiLCJzdmdJbWFnZSIsInNldFN2Z0ltYWdlIiwiY29uZmlnIiwic2V0Q29uZmlnIiwiaGFuZGxlU3ZnU2VsZWN0IiwiZXZ0Iiwic2VsZWN0ZWRTdmciLCJ0YXJnZXQiLCJ2YWx1ZSIsImluaXRpYWxDb25maWciLCJkaXYiLCJjbGFzc05hbWUiLCJ0aXRsZSIsImxpbmsiLCJyZWwiLCJocmVmIiwibWFpbiIsInNlbGVjdCIsIm9uQ2hhbmdlIiwib3B0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/index.js\n"));

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlIQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzPzg4NDkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvc2hhcmVkL2xpYi9oZWFkJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/head.js\n"));

/***/ }),

/***/ "./public/fonts/fondamento-italic-webfont.woff2":
/*!******************************************************!*\
  !*** ./public/fonts/fondamento-italic-webfont.woff2 ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
module.exports = __webpack_require__.p + "static/media/fondamento-italic-webfont.bb658b6a.woff2";

/***/ }),

/***/ "./public/fonts/fondamento-regular-webfont.woff2":
/*!*******************************************************!*\
  !*** ./public/fonts/fondamento-regular-webfont.woff2 ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
module.exports = __webpack_require__.p + "static/media/fondamento-regular-webfont.f75111a3.woff2";

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2FJohnJones%2FDocuments%2FProgramming%2FProjects%2Fpestle%2Fpages%2Findex.js&page=%2F!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);